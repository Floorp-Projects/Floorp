// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csd.proto

#include "csd.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
PROTOBUF_CONSTEXPR ChromeUserPopulation::ChromeUserPopulation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.finch_active_groups_)*/{}
  , /*decltype(_impl_.user_population_)*/0
  , /*decltype(_impl_.is_history_sync_enabled_)*/false} {}
struct ChromeUserPopulationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeUserPopulationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeUserPopulationDefaultTypeInternal() {}
  union {
    ChromeUserPopulation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeUserPopulationDefaultTypeInternal _ChromeUserPopulation_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0} {}
struct ClientPhishingRequest_FeatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientPhishingRequest_FeatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientPhishingRequest_FeatureDefaultTypeInternal() {}
  union {
    ClientPhishingRequest_Feature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingRequest_FeatureDefaultTypeInternal _ClientPhishingRequest_Feature_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingRequest::ClientPhishingRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.feature_map_)*/{}
  , /*decltype(_impl_.non_model_feature_map_)*/{}
  , /*decltype(_impl_.shingle_hashes_)*/{}
  , /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/{0}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_referrer_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.obsolete_hash_prefix_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.population_)*/nullptr
  , /*decltype(_impl_.client_score_)*/0
  , /*decltype(_impl_.is_phishing_)*/false
  , /*decltype(_impl_.model_version_)*/0} {}
struct ClientPhishingRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientPhishingRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientPhishingRequestDefaultTypeInternal() {}
  union {
    ClientPhishingRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingRequestDefaultTypeInternal _ClientPhishingRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingResponse::ClientPhishingResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_whitelist_expression_)*/{}
  , /*decltype(_impl_.phishy_)*/false} {}
struct ClientPhishingResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientPhishingResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientPhishingResponseDefaultTypeInternal() {}
  union {
    ClientPhishingResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingResponseDefaultTypeInternal _ClientPhishingResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientMalwareRequest_UrlInfo::ClientMalwareRequest_UrlInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resource_type_)*/0} {}
struct ClientMalwareRequest_UrlInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMalwareRequest_UrlInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMalwareRequest_UrlInfoDefaultTypeInternal() {}
  union {
    ClientMalwareRequest_UrlInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMalwareRequest_UrlInfoDefaultTypeInternal _ClientMalwareRequest_UrlInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientMalwareRequest::ClientMalwareRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bad_ip_url_info_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.population_)*/nullptr} {}
struct ClientMalwareRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMalwareRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMalwareRequestDefaultTypeInternal() {}
  union {
    ClientMalwareRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMalwareRequestDefaultTypeInternal _ClientMalwareRequest_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.action_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.has_password_field_)*/false} {}
struct LoginReputationClientRequest_Frame_FormDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame_FormDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReputationClientRequest_Frame_FormDefaultTypeInternal() {}
  union {
    LoginReputationClientRequest_Frame_Form _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_Frame_FormDefaultTypeInternal _LoginReputationClientRequest_Frame_Form_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.referrer_chain_)*/{}
  , /*decltype(_impl_.forms_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.frame_index_)*/0
  , /*decltype(_impl_.parent_frame_index_)*/0
  , /*decltype(_impl_.has_password_field_)*/false} {}
struct LoginReputationClientRequest_FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReputationClientRequest_FrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReputationClientRequest_FrameDefaultTypeInternal() {}
  union {
    LoginReputationClientRequest_Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_FrameDefaultTypeInternal _LoginReputationClientRequest_Frame_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.domains_matching_password_)*/{}
  , /*decltype(_impl_.frame_id_)*/0
  , /*decltype(_impl_.is_chrome_signin_password_)*/false
  , /*decltype(_impl_.sync_account_type_)*/0} {}
struct LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal() {}
  union {
    LoginReputationClientRequest_PasswordReuseEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal _LoginReputationClientRequest_PasswordReuseEvent_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest::LoginReputationClientRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frames_)*/{}
  , /*decltype(_impl_.page_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_reuse_event_)*/nullptr
  , /*decltype(_impl_.population_)*/nullptr
  , /*decltype(_impl_.trigger_type_)*/0
  , /*decltype(_impl_.stored_verdict_cnt_)*/0
  , /*decltype(_impl_.clicked_through_interstitial_)*/false} {}
struct LoginReputationClientRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReputationClientRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReputationClientRequestDefaultTypeInternal() {}
  union {
    LoginReputationClientRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequestDefaultTypeInternal _LoginReputationClientRequest_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientResponse::LoginReputationClientResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cache_expression_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.verdict_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cache_duration_sec_)*/int64_t{0}
  , /*decltype(_impl_.verdict_type_)*/0
  , /*decltype(_impl_.deprecated_cache_expression_exact_match_)*/false} {}
struct LoginReputationClientResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginReputationClientResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginReputationClientResponseDefaultTypeInternal() {}
  union {
    LoginReputationClientResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientResponseDefaultTypeInternal _LoginReputationClientResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientMalwareResponse::ClientMalwareResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bad_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bad_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.blacklist_)*/false} {}
struct ClientMalwareResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMalwareResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMalwareResponseDefaultTypeInternal() {}
  union {
    ClientMalwareResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMalwareResponseDefaultTypeInternal _ClientMalwareResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sha256_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sha1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.md5_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_DigestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_DigestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_DigestsDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_Digests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_DigestsDefaultTypeInternal _ClientDownloadRequest_Digests_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.remote_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct ClientDownloadRequest_ResourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_ResourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_ResourceDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_Resource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ResourceDefaultTypeInternal _ClientDownloadRequest_Resource_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.certificate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_CertificateChain_Element _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal _ClientDownloadRequest_CertificateChain_Element_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.element_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientDownloadRequest_CertificateChainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_CertificateChainDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_CertificateChain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_CertificateChainDefaultTypeInternal _ClientDownloadRequest_CertificateChain_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_ExtendedAttrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_ExtendedAttrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_ExtendedAttrDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_ExtendedAttr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ExtendedAttrDefaultTypeInternal _ClientDownloadRequest_ExtendedAttr_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.certificate_chain_)*/{}
  , /*decltype(_impl_.signed_data_)*/{}
  , /*decltype(_impl_.xattr_)*/{}
  , /*decltype(_impl_.trusted_)*/false} {}
struct ClientDownloadRequest_SignatureInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_SignatureInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_SignatureInfoDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_SignatureInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_SignatureInfoDefaultTypeInternal _ClientDownloadRequest_SignatureInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.directory_entry_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.raw_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_PEImageHeaders_DebugData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal _ClientDownloadRequest_PEImageHeaders_DebugData_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.section_header_)*/{}
  , /*decltype(_impl_.debug_data_)*/{}
  , /*decltype(_impl_.dos_header_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_header_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.optional_headers32_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.optional_headers64_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.export_section_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_PEImageHeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_PEImageHeadersDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_PEImageHeaders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_PEImageHeadersDefaultTypeInternal _ClientDownloadRequest_PEImageHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_id_)*/0u} {}
struct ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_MachOHeaders_LoadCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal _ClientDownloadRequest_MachOHeaders_LoadCommand_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.load_commands_)*/{}
  , /*decltype(_impl_.mach_header_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadRequest_MachOHeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_MachOHeadersDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_MachOHeaders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_MachOHeadersDefaultTypeInternal _ClientDownloadRequest_MachOHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mach_o_headers_)*/{}
  , /*decltype(_impl_.pe_headers_)*/nullptr} {}
struct ClientDownloadRequest_ImageHeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_ImageHeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_ImageHeadersDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_ImageHeaders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ImageHeadersDefaultTypeInternal _ClientDownloadRequest_ImageHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.file_basename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.digests_)*/nullptr
  , /*decltype(_impl_.signature_)*/nullptr
  , /*decltype(_impl_.image_headers_)*/nullptr
  , /*decltype(_impl_.length_)*/int64_t{0}
  , /*decltype(_impl_.download_type_)*/0} {}
struct ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal() {}
  union {
    ClientDownloadRequest_ArchivedBinary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal _ClientDownloadRequest_ArchivedBinary_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest::ClientDownloadRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resources_)*/{}
  , /*decltype(_impl_.archived_binary_)*/{}
  , /*decltype(_impl_.alternate_extensions_)*/{}
  , /*decltype(_impl_.referrer_chain_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_basename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.locale_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.udif_code_signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.digests_)*/nullptr
  , /*decltype(_impl_.signature_)*/nullptr
  , /*decltype(_impl_.image_headers_)*/nullptr
  , /*decltype(_impl_.population_)*/nullptr
  , /*decltype(_impl_.length_)*/int64_t{0}
  , /*decltype(_impl_.download_type_)*/0
  , /*decltype(_impl_.user_initiated_)*/false
  , /*decltype(_impl_.archive_valid_)*/false
  , /*decltype(_impl_.skipped_url_whitelist_)*/false
  , /*decltype(_impl_.skipped_certificate_whitelist_)*/false
  , /*decltype(_impl_.deprecated_download_attribution_finch_enabled_)*/false} {}
struct ClientDownloadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadRequestDefaultTypeInternal() {}
  union {
    ClientDownloadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequestDefaultTypeInternal _ClientDownloadRequest_default_instance_;
PROTOBUF_CONSTEXPR ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReferrerChainEntry_ServerRedirectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferrerChainEntry_ServerRedirectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferrerChainEntry_ServerRedirectDefaultTypeInternal() {}
  union {
    ReferrerChainEntry_ServerRedirect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferrerChainEntry_ServerRedirectDefaultTypeInternal _ReferrerChainEntry_ServerRedirect_default_instance_;
PROTOBUF_CONSTEXPR ReferrerChainEntry::ReferrerChainEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_addresses_)*/{}
  , /*decltype(_impl_.server_redirect_chain_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_main_frame_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.main_frame_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.navigation_time_msec_)*/0
  , /*decltype(_impl_.is_retargeting_)*/false
  , /*decltype(_impl_.type_)*/4} {}
struct ReferrerChainEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferrerChainEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferrerChainEntryDefaultTypeInternal() {}
  union {
    ReferrerChainEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferrerChainEntryDefaultTypeInternal _ReferrerChainEntry_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadResponse_MoreInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadResponse_MoreInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadResponse_MoreInfoDefaultTypeInternal() {}
  union {
    ClientDownloadResponse_MoreInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadResponse_MoreInfoDefaultTypeInternal _ClientDownloadResponse_MoreInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadResponse::ClientDownloadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.more_info_)*/nullptr
  , /*decltype(_impl_.verdict_)*/0
  , /*decltype(_impl_.upload_)*/false} {}
struct ClientDownloadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadResponseDefaultTypeInternal() {}
  union {
    ClientDownloadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadResponseDefaultTypeInternal _ClientDownloadResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientDownloadReport_UserInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadReport_UserInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadReport_UserInformationDefaultTypeInternal() {}
  union {
    ClientDownloadReport_UserInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadReport_UserInformationDefaultTypeInternal _ClientDownloadReport_UserInformation_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadReport::ClientDownloadReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.download_request_)*/nullptr
  , /*decltype(_impl_.user_information_)*/nullptr
  , /*decltype(_impl_.download_response_)*/nullptr
  , /*decltype(_impl_.reason_)*/0} {}
struct ClientDownloadReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDownloadReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDownloadReportDefaultTypeInternal() {}
  union {
    ClientDownloadReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadReportDefaultTypeInternal _ClientDownloadReport_default_instance_;
PROTOBUF_CONSTEXPR ClientUploadResponse::ClientUploadResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.permalink_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0} {}
struct ClientUploadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientUploadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientUploadResponseDefaultTypeInternal() {}
  union {
    ClientUploadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientUploadResponseDefaultTypeInternal _ClientUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.split_key_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.atomic_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_state_)*/0} {}
struct ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal() {}
  union {
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal _ClientIncidentReport_IncidentData_TrackedPreferenceIncident_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.relative_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/nullptr
  , /*decltype(_impl_.image_headers_)*/nullptr} {}
struct ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal() {}
  union {
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal _ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.contained_file_)*/{}
  , /*decltype(_impl_.file_basename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/nullptr
  , /*decltype(_impl_.image_headers_)*/nullptr
  , /*decltype(_impl_.sec_error_)*/0} {}
struct ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal() {}
  union {
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal _ClientIncidentReport_IncidentData_BinaryIntegrityIncident_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.digest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.origin_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal() {}
  union {
    ClientIncidentReport_IncidentData_ResourceRequestIncident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal _ClientIncidentReport_IncidentData_ResourceRequestIncident_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tracked_preference_)*/nullptr
  , /*decltype(_impl_.binary_integrity_)*/nullptr
  , /*decltype(_impl_.resource_request_)*/nullptr
  , /*decltype(_impl_.incident_time_msec_)*/int64_t{0}} {}
struct ClientIncidentReport_IncidentDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_IncidentDataDefaultTypeInternal() {}
  union {
    ClientIncidentReport_IncidentData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentDataDefaultTypeInternal _ClientIncidentReport_IncidentData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.download_)*/nullptr
  , /*decltype(_impl_.download_time_msec_)*/int64_t{0}
  , /*decltype(_impl_.open_time_msec_)*/int64_t{0}} {}
struct ClientIncidentReport_DownloadDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_DownloadDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_DownloadDetailsDefaultTypeInternal() {}
  union {
    ClientIncidentReport_DownloadDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_DownloadDetailsDefaultTypeInternal _ClientIncidentReport_DownloadDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0u} {}
struct ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_OS_RegistryValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal _ClientIncidentReport_EnvironmentData_OS_RegistryValue_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{}
  , /*decltype(_impl_.key_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_OS_RegistryKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal _ClientIncidentReport_EnvironmentData_OS_RegistryKey_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.registry_key_)*/{}
  , /*decltype(_impl_.os_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_enrolled_to_domain_)*/false} {}
struct ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_OS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal _ClientIncidentReport_EnvironmentData_OS_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cpu_architecture_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpu_vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpuid_)*/0u} {}
struct ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Machine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Machine_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.function_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_dll_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process_Patch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_Patch_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process_NetworkProvider _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_NetworkProvider_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.feature_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_headers_)*/nullptr
  , /*decltype(_impl_.base_address_)*/uint64_t{0u}
  , /*decltype(_impl_.length_)*/0u} {}
struct ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process_Dll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_Dll_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.modified_bytes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.export_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_offset_)*/0u
  , /*decltype(_impl_.byte_count_)*/0} {}
struct ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_modified_export_)*/{}
  , /*decltype(_impl_.modification_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.modified_state_)*/0} {}
struct ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process_ModuleState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_ModuleState_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obsolete_dlls_)*/{}
  , /*decltype(_impl_.patches_)*/{}
  , /*decltype(_impl_.network_providers_)*/{}
  , /*decltype(_impl_.dll_)*/{}
  , /*decltype(_impl_.blacklisted_dll_)*/{}
  , /*decltype(_impl_.module_state_)*/{}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uptime_msec_)*/int64_t{0}
  , /*decltype(_impl_.chrome_update_channel_)*/0
  , /*decltype(_impl_.metrics_consent_)*/false
  , /*decltype(_impl_.obsolete_extended_consent_)*/false
  , /*decltype(_impl_.obsolete_field_trial_participant_)*/false} {}
struct ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData_Process _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal _ClientIncidentReport_EnvironmentData_Process_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.os_)*/nullptr
  , /*decltype(_impl_.machine_)*/nullptr
  , /*decltype(_impl_.process_)*/nullptr} {}
struct ClientIncidentReport_EnvironmentDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_EnvironmentDataDefaultTypeInternal() {}
  union {
    ClientIncidentReport_EnvironmentData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentDataDefaultTypeInternal _ClientIncidentReport_EnvironmentData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.update_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.has_signature_validation_)*/false
  , /*decltype(_impl_.signature_is_valid_)*/false
  , /*decltype(_impl_.installed_by_custodian_)*/false
  , /*decltype(_impl_.installed_by_default_)*/false
  , /*decltype(_impl_.installed_by_oem_)*/false
  , /*decltype(_impl_.from_bookmark_)*/false
  , /*decltype(_impl_.from_webstore_)*/false
  , /*decltype(_impl_.converted_from_user_script_)*/false
  , /*decltype(_impl_.install_time_msec_)*/int64_t{0}
  , /*decltype(_impl_.may_be_untrusted_)*/false
  , /*decltype(_impl_.manifest_location_type_)*/0} {}
struct ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal() {}
  union {
    ClientIncidentReport_ExtensionData_ExtensionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal _ClientIncidentReport_ExtensionData_ExtensionInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.last_installed_extension_)*/nullptr} {}
struct ClientIncidentReport_ExtensionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_ExtensionDataDefaultTypeInternal() {}
  union {
    ClientIncidentReport_ExtensionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_ExtensionDataDefaultTypeInternal _ClientIncidentReport_ExtensionData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.file_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_spec_sha256_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.length_)*/int64_t{0}} {}
struct ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal() {}
  union {
    ClientIncidentReport_NonBinaryDownloadDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal _ClientIncidentReport_NonBinaryDownloadDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport::ClientIncidentReport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.incident_)*/{}
  , /*decltype(_impl_.download_)*/nullptr
  , /*decltype(_impl_.environment_)*/nullptr
  , /*decltype(_impl_.population_)*/nullptr
  , /*decltype(_impl_.extension_data_)*/nullptr
  , /*decltype(_impl_.non_binary_download_)*/nullptr} {}
struct ClientIncidentReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentReportDefaultTypeInternal() {}
  union {
    ClientIncidentReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReportDefaultTypeInternal _ClientIncidentReport_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dll_index_)*/0} {}
struct ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal() {}
  union {
    ClientIncidentResponse_EnvironmentRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal _ClientIncidentResponse_EnvironmentRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentResponse::ClientIncidentResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.environment_requests_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.download_requested_)*/false} {}
struct ClientIncidentResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientIncidentResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientIncidentResponseDefaultTypeInternal() {}
  union {
    ClientIncidentResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentResponseDefaultTypeInternal _ClientIncidentResponse_default_instance_;
PROTOBUF_CONSTEXPR DownloadMetadata::DownloadMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.download_)*/nullptr
  , /*decltype(_impl_.download_id_)*/0u} {}
struct DownloadMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadMetadataDefaultTypeInternal() {}
  union {
    DownloadMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadMetadataDefaultTypeInternal _DownloadMetadata_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_HTTPHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal _ClientSafeBrowsingReportRequest_HTTPHeader_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.verb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uri_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal _ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bodydigest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.firstline_)*/nullptr
  , /*decltype(_impl_.bodylength_)*/0} {}
struct ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_HTTPRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal _ClientSafeBrowsingReportRequest_HTTPRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_)*/0} {}
struct ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal _ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bodydigest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.remote_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.firstline_)*/nullptr
  , /*decltype(_impl_.bodylength_)*/0} {}
struct ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_HTTPResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal _ClientSafeBrowsingReportRequest_HTTPResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.child_ids_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tag_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.request_)*/nullptr
  , /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.parent_id_)*/0} {}
struct ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_Resource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal _ClientSafeBrowsingReportRequest_Resource_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.google_play_services_version_)*/int64_t{0}
  , /*decltype(_impl_.is_instant_apps_)*/false
  , /*decltype(_impl_.url_api_type_)*/0} {}
struct ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal _ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resources_)*/{}
  , /*decltype(_impl_.client_asn_)*/{}
  , /*decltype(_impl_.dom_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_country_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_properties_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.complete_)*/false
  , /*decltype(_impl_.did_proceed_)*/false
  , /*decltype(_impl_.repeat_visit_)*/false
  , /*decltype(_impl_.show_download_in_folder_)*/false
  , /*decltype(_impl_.download_verdict_)*/0} {}
struct ClientSafeBrowsingReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSafeBrowsingReportRequestDefaultTypeInternal() {}
  union {
    ClientSafeBrowsingReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequestDefaultTypeInternal _ClientSafeBrowsingReportRequest_default_instance_;
PROTOBUF_CONSTEXPR HTMLElement_Attribute::HTMLElement_Attribute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HTMLElement_AttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HTMLElement_AttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HTMLElement_AttributeDefaultTypeInternal() {}
  union {
    HTMLElement_Attribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTMLElement_AttributeDefaultTypeInternal _HTMLElement_Attribute_default_instance_;
PROTOBUF_CONSTEXPR HTMLElement::HTMLElement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.child_ids_)*/{}
  , /*decltype(_impl_.attribute_)*/{}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.resource_id_)*/0} {}
struct HTMLElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HTMLElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HTMLElementDefaultTypeInternal() {}
  union {
    HTMLElement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTMLElementDefaultTypeInternal _HTMLElement_default_instance_;
PROTOBUF_CONSTEXPR ImageData_Dimensions::ImageData_Dimensions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0} {}
struct ImageData_DimensionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageData_DimensionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageData_DimensionsDefaultTypeInternal() {}
  union {
    ImageData_Dimensions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageData_DimensionsDefaultTypeInternal _ImageData_Dimensions_default_instance_;
PROTOBUF_CONSTEXPR ImageData::ImageData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mime_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dimensions_)*/nullptr
  , /*decltype(_impl_.original_dimensions_)*/nullptr} {}
struct ImageDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageDataDefaultTypeInternal() {}
  union {
    ImageData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageDataDefaultTypeInternal _ImageData_default_instance_;
PROTOBUF_CONSTEXPR NotificationImageReportRequest::NotificationImageReportRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.notification_origin_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.image_)*/nullptr} {}
struct NotificationImageReportRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NotificationImageReportRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NotificationImageReportRequestDefaultTypeInternal() {}
  union {
    NotificationImageReportRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NotificationImageReportRequestDefaultTypeInternal _NotificationImageReportRequest_default_instance_;
}  // namespace safe_browsing
namespace safe_browsing {
bool ChromeUserPopulation_UserPopulation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeUserPopulation_UserPopulation_strings[3] = {};

static const char ChromeUserPopulation_UserPopulation_names[] =
  "EXTENDED_REPORTING"
  "SAFE_BROWSING"
  "UNKNOWN_USER_POPULATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeUserPopulation_UserPopulation_entries[] = {
  { {ChromeUserPopulation_UserPopulation_names + 0, 18}, 2 },
  { {ChromeUserPopulation_UserPopulation_names + 18, 13}, 1 },
  { {ChromeUserPopulation_UserPopulation_names + 31, 23}, 0 },
};

static const int ChromeUserPopulation_UserPopulation_entries_by_number[] = {
  2, // 0 -> UNKNOWN_USER_POPULATION
  1, // 1 -> SAFE_BROWSING
  0, // 2 -> EXTENDED_REPORTING
};

const std::string& ChromeUserPopulation_UserPopulation_Name(
    ChromeUserPopulation_UserPopulation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChromeUserPopulation_UserPopulation_entries,
          ChromeUserPopulation_UserPopulation_entries_by_number,
          3, ChromeUserPopulation_UserPopulation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChromeUserPopulation_UserPopulation_entries,
      ChromeUserPopulation_UserPopulation_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChromeUserPopulation_UserPopulation_strings[idx].get();
}
bool ChromeUserPopulation_UserPopulation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeUserPopulation_UserPopulation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChromeUserPopulation_UserPopulation_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ChromeUserPopulation_UserPopulation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UNKNOWN_USER_POPULATION;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::SAFE_BROWSING;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::EXTENDED_REPORTING;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UserPopulation_MIN;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UserPopulation_MAX;
constexpr int ChromeUserPopulation::UserPopulation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings[3] = {};

static const char LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names[] =
  "GMAIL"
  "GSUITE"
  "NOT_SIGNED_IN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries[] = {
  { {LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 0, 5}, 1 },
  { {LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 5, 6}, 2 },
  { {LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 11, 13}, 0 },
};

static const int LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number[] = {
  2, // 0 -> NOT_SIGNED_IN
  0, // 1 -> GMAIL
  1, // 2 -> GSUITE
};

const std::string& LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_Name(
    LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries,
          LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number,
          3, LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries,
      LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings[idx].get();
}
bool LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::NOT_SIGNED_IN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::GMAIL;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::GSUITE;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_MIN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_MAX;
constexpr int LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_TriggerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_TriggerType_strings[3] = {};

static const char LoginReputationClientRequest_TriggerType_names[] =
  "PASSWORD_REUSE_EVENT"
  "TRIGGER_TYPE_UNSPECIFIED"
  "UNFAMILIAR_LOGIN_PAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_TriggerType_entries[] = {
  { {LoginReputationClientRequest_TriggerType_names + 0, 20}, 2 },
  { {LoginReputationClientRequest_TriggerType_names + 20, 24}, 0 },
  { {LoginReputationClientRequest_TriggerType_names + 44, 21}, 1 },
};

static const int LoginReputationClientRequest_TriggerType_entries_by_number[] = {
  1, // 0 -> TRIGGER_TYPE_UNSPECIFIED
  2, // 1 -> UNFAMILIAR_LOGIN_PAGE
  0, // 2 -> PASSWORD_REUSE_EVENT
};

const std::string& LoginReputationClientRequest_TriggerType_Name(
    LoginReputationClientRequest_TriggerType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginReputationClientRequest_TriggerType_entries,
          LoginReputationClientRequest_TriggerType_entries_by_number,
          3, LoginReputationClientRequest_TriggerType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginReputationClientRequest_TriggerType_entries,
      LoginReputationClientRequest_TriggerType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginReputationClientRequest_TriggerType_strings[idx].get();
}
bool LoginReputationClientRequest_TriggerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_TriggerType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginReputationClientRequest_TriggerType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<LoginReputationClientRequest_TriggerType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TRIGGER_TYPE_UNSPECIFIED;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::UNFAMILIAR_LOGIN_PAGE;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::PASSWORD_REUSE_EVENT;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TriggerType_MIN;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TriggerType_MAX;
constexpr int LoginReputationClientRequest::TriggerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientResponse_VerdictType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientResponse_VerdictType_strings[4] = {};

static const char LoginReputationClientResponse_VerdictType_names[] =
  "LOW_REPUTATION"
  "PHISHING"
  "SAFE"
  "VERDICT_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientResponse_VerdictType_entries[] = {
  { {LoginReputationClientResponse_VerdictType_names + 0, 14}, 2 },
  { {LoginReputationClientResponse_VerdictType_names + 14, 8}, 3 },
  { {LoginReputationClientResponse_VerdictType_names + 22, 4}, 1 },
  { {LoginReputationClientResponse_VerdictType_names + 26, 24}, 0 },
};

static const int LoginReputationClientResponse_VerdictType_entries_by_number[] = {
  3, // 0 -> VERDICT_TYPE_UNSPECIFIED
  2, // 1 -> SAFE
  0, // 2 -> LOW_REPUTATION
  1, // 3 -> PHISHING
};

const std::string& LoginReputationClientResponse_VerdictType_Name(
    LoginReputationClientResponse_VerdictType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LoginReputationClientResponse_VerdictType_entries,
          LoginReputationClientResponse_VerdictType_entries_by_number,
          4, LoginReputationClientResponse_VerdictType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LoginReputationClientResponse_VerdictType_entries,
      LoginReputationClientResponse_VerdictType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LoginReputationClientResponse_VerdictType_strings[idx].get();
}
bool LoginReputationClientResponse_VerdictType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientResponse_VerdictType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LoginReputationClientResponse_VerdictType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<LoginReputationClientResponse_VerdictType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::SAFE;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::LOW_REPUTATION;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::PHISHING;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VerdictType_MIN;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VerdictType_MAX;
constexpr int LoginReputationClientResponse::VerdictType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadRequest_ResourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadRequest_ResourceType_strings[6] = {};

static const char ClientDownloadRequest_ResourceType_names[] =
  "DOWNLOAD_REDIRECT"
  "DOWNLOAD_URL"
  "PPAPI_DOCUMENT"
  "PPAPI_PLUGIN"
  "TAB_REDIRECT"
  "TAB_URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadRequest_ResourceType_entries[] = {
  { {ClientDownloadRequest_ResourceType_names + 0, 17}, 1 },
  { {ClientDownloadRequest_ResourceType_names + 17, 12}, 0 },
  { {ClientDownloadRequest_ResourceType_names + 29, 14}, 4 },
  { {ClientDownloadRequest_ResourceType_names + 43, 12}, 5 },
  { {ClientDownloadRequest_ResourceType_names + 55, 12}, 3 },
  { {ClientDownloadRequest_ResourceType_names + 67, 7}, 2 },
};

static const int ClientDownloadRequest_ResourceType_entries_by_number[] = {
  1, // 0 -> DOWNLOAD_URL
  0, // 1 -> DOWNLOAD_REDIRECT
  5, // 2 -> TAB_URL
  4, // 3 -> TAB_REDIRECT
  2, // 4 -> PPAPI_DOCUMENT
  3, // 5 -> PPAPI_PLUGIN
};

const std::string& ClientDownloadRequest_ResourceType_Name(
    ClientDownloadRequest_ResourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientDownloadRequest_ResourceType_entries,
          ClientDownloadRequest_ResourceType_entries_by_number,
          6, ClientDownloadRequest_ResourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientDownloadRequest_ResourceType_entries,
      ClientDownloadRequest_ResourceType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientDownloadRequest_ResourceType_strings[idx].get();
}
bool ClientDownloadRequest_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_ResourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientDownloadRequest_ResourceType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ClientDownloadRequest_ResourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::DOWNLOAD_URL;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::DOWNLOAD_REDIRECT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::TAB_URL;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::TAB_REDIRECT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::PPAPI_DOCUMENT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::PPAPI_PLUGIN;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::ResourceType_MIN;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::ResourceType_MAX;
constexpr int ClientDownloadRequest::ResourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadRequest_DownloadType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadRequest_DownloadType_strings[11] = {};

static const char ClientDownloadRequest_DownloadType_names[] =
  "ANDROID_APK"
  "ARCHIVE"
  "CHROME_EXTENSION"
  "INVALID_MAC_ARCHIVE"
  "INVALID_ZIP"
  "MAC_EXECUTABLE"
  "PPAPI_SAVE_REQUEST"
  "SAMPLED_UNSUPPORTED_FILE"
  "WIN_EXECUTABLE"
  "ZIPPED_ARCHIVE"
  "ZIPPED_EXECUTABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadRequest_DownloadType_entries[] = {
  { {ClientDownloadRequest_DownloadType_names + 0, 11}, 2 },
  { {ClientDownloadRequest_DownloadType_names + 11, 7}, 6 },
  { {ClientDownloadRequest_DownloadType_names + 18, 16}, 1 },
  { {ClientDownloadRequest_DownloadType_names + 34, 19}, 8 },
  { {ClientDownloadRequest_DownloadType_names + 53, 11}, 7 },
  { {ClientDownloadRequest_DownloadType_names + 64, 14}, 4 },
  { {ClientDownloadRequest_DownloadType_names + 78, 18}, 9 },
  { {ClientDownloadRequest_DownloadType_names + 96, 24}, 10 },
  { {ClientDownloadRequest_DownloadType_names + 120, 14}, 0 },
  { {ClientDownloadRequest_DownloadType_names + 134, 14}, 5 },
  { {ClientDownloadRequest_DownloadType_names + 148, 17}, 3 },
};

static const int ClientDownloadRequest_DownloadType_entries_by_number[] = {
  8, // 0 -> WIN_EXECUTABLE
  2, // 1 -> CHROME_EXTENSION
  0, // 2 -> ANDROID_APK
  10, // 3 -> ZIPPED_EXECUTABLE
  5, // 4 -> MAC_EXECUTABLE
  9, // 5 -> ZIPPED_ARCHIVE
  1, // 6 -> ARCHIVE
  4, // 7 -> INVALID_ZIP
  3, // 8 -> INVALID_MAC_ARCHIVE
  6, // 9 -> PPAPI_SAVE_REQUEST
  7, // 10 -> SAMPLED_UNSUPPORTED_FILE
};

const std::string& ClientDownloadRequest_DownloadType_Name(
    ClientDownloadRequest_DownloadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientDownloadRequest_DownloadType_entries,
          ClientDownloadRequest_DownloadType_entries_by_number,
          11, ClientDownloadRequest_DownloadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientDownloadRequest_DownloadType_entries,
      ClientDownloadRequest_DownloadType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientDownloadRequest_DownloadType_strings[idx].get();
}
bool ClientDownloadRequest_DownloadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_DownloadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientDownloadRequest_DownloadType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ClientDownloadRequest_DownloadType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::WIN_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::CHROME_EXTENSION;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ANDROID_APK;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ZIPPED_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::MAC_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ZIPPED_ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::INVALID_ZIP;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::INVALID_MAC_ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::PPAPI_SAVE_REQUEST;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::SAMPLED_UNSUPPORTED_FILE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::DownloadType_MIN;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::DownloadType_MAX;
constexpr int ClientDownloadRequest::DownloadType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReferrerChainEntry_URLType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReferrerChainEntry_URLType_strings[5] = {};

static const char ReferrerChainEntry_URLType_names[] =
  "CLIENT_REDIRECT"
  "DEPRECATED_SERVER_REDIRECT"
  "EVENT_URL"
  "LANDING_PAGE"
  "LANDING_REFERRER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReferrerChainEntry_URLType_entries[] = {
  { {ReferrerChainEntry_URLType_names + 0, 15}, 4 },
  { {ReferrerChainEntry_URLType_names + 15, 26}, 5 },
  { {ReferrerChainEntry_URLType_names + 41, 9}, 1 },
  { {ReferrerChainEntry_URLType_names + 50, 12}, 2 },
  { {ReferrerChainEntry_URLType_names + 62, 16}, 3 },
};

static const int ReferrerChainEntry_URLType_entries_by_number[] = {
  2, // 1 -> EVENT_URL
  3, // 2 -> LANDING_PAGE
  4, // 3 -> LANDING_REFERRER
  0, // 4 -> CLIENT_REDIRECT
  1, // 5 -> DEPRECATED_SERVER_REDIRECT
};

const std::string& ReferrerChainEntry_URLType_Name(
    ReferrerChainEntry_URLType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReferrerChainEntry_URLType_entries,
          ReferrerChainEntry_URLType_entries_by_number,
          5, ReferrerChainEntry_URLType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReferrerChainEntry_URLType_entries,
      ReferrerChainEntry_URLType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReferrerChainEntry_URLType_strings[idx].get();
}
bool ReferrerChainEntry_URLType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferrerChainEntry_URLType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReferrerChainEntry_URLType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ReferrerChainEntry_URLType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::EVENT_URL;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::LANDING_PAGE;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::LANDING_REFERRER;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::CLIENT_REDIRECT;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::DEPRECATED_SERVER_REDIRECT;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::URLType_MIN;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::URLType_MAX;
constexpr int ReferrerChainEntry::URLType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadResponse_Verdict_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadResponse_Verdict_strings[6] = {};

static const char ClientDownloadResponse_Verdict_names[] =
  "DANGEROUS"
  "DANGEROUS_HOST"
  "POTENTIALLY_UNWANTED"
  "SAFE"
  "UNCOMMON"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadResponse_Verdict_entries[] = {
  { {ClientDownloadResponse_Verdict_names + 0, 9}, 1 },
  { {ClientDownloadResponse_Verdict_names + 9, 14}, 4 },
  { {ClientDownloadResponse_Verdict_names + 23, 20}, 3 },
  { {ClientDownloadResponse_Verdict_names + 43, 4}, 0 },
  { {ClientDownloadResponse_Verdict_names + 47, 8}, 2 },
  { {ClientDownloadResponse_Verdict_names + 55, 7}, 5 },
};

static const int ClientDownloadResponse_Verdict_entries_by_number[] = {
  3, // 0 -> SAFE
  0, // 1 -> DANGEROUS
  4, // 2 -> UNCOMMON
  2, // 3 -> POTENTIALLY_UNWANTED
  1, // 4 -> DANGEROUS_HOST
  5, // 5 -> UNKNOWN
};

const std::string& ClientDownloadResponse_Verdict_Name(
    ClientDownloadResponse_Verdict value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientDownloadResponse_Verdict_entries,
          ClientDownloadResponse_Verdict_entries_by_number,
          6, ClientDownloadResponse_Verdict_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientDownloadResponse_Verdict_entries,
      ClientDownloadResponse_Verdict_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientDownloadResponse_Verdict_strings[idx].get();
}
bool ClientDownloadResponse_Verdict_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadResponse_Verdict* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientDownloadResponse_Verdict_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ClientDownloadResponse_Verdict>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::SAFE;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::DANGEROUS;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::UNCOMMON;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::POTENTIALLY_UNWANTED;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::DANGEROUS_HOST;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::UNKNOWN;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::Verdict_MIN;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::Verdict_MAX;
constexpr int ClientDownloadResponse::Verdict_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadReport_Reason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadReport_Reason_strings[3] = {};

static const char ClientDownloadReport_Reason_names[] =
  "APPEAL"
  "FALSE_POSITIVE"
  "SHARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadReport_Reason_entries[] = {
  { {ClientDownloadReport_Reason_names + 0, 6}, 2 },
  { {ClientDownloadReport_Reason_names + 6, 14}, 1 },
  { {ClientDownloadReport_Reason_names + 20, 5}, 0 },
};

static const int ClientDownloadReport_Reason_entries_by_number[] = {
  2, // 0 -> SHARE
  1, // 1 -> FALSE_POSITIVE
  0, // 2 -> APPEAL
};

const std::string& ClientDownloadReport_Reason_Name(
    ClientDownloadReport_Reason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientDownloadReport_Reason_entries,
          ClientDownloadReport_Reason_entries_by_number,
          3, ClientDownloadReport_Reason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientDownloadReport_Reason_entries,
      ClientDownloadReport_Reason_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientDownloadReport_Reason_strings[idx].get();
}
bool ClientDownloadReport_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadReport_Reason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientDownloadReport_Reason_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientDownloadReport_Reason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadReport_Reason ClientDownloadReport::SHARE;
constexpr ClientDownloadReport_Reason ClientDownloadReport::FALSE_POSITIVE;
constexpr ClientDownloadReport_Reason ClientDownloadReport::APPEAL;
constexpr ClientDownloadReport_Reason ClientDownloadReport::Reason_MIN;
constexpr ClientDownloadReport_Reason ClientDownloadReport::Reason_MAX;
constexpr int ClientDownloadReport::Reason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientUploadResponse_UploadStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientUploadResponse_UploadStatus_strings[2] = {};

static const char ClientUploadResponse_UploadStatus_names[] =
  "SUCCESS"
  "UPLOAD_FAILURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientUploadResponse_UploadStatus_entries[] = {
  { {ClientUploadResponse_UploadStatus_names + 0, 7}, 0 },
  { {ClientUploadResponse_UploadStatus_names + 7, 14}, 1 },
};

static const int ClientUploadResponse_UploadStatus_entries_by_number[] = {
  0, // 0 -> SUCCESS
  1, // 1 -> UPLOAD_FAILURE
};

const std::string& ClientUploadResponse_UploadStatus_Name(
    ClientUploadResponse_UploadStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientUploadResponse_UploadStatus_entries,
          ClientUploadResponse_UploadStatus_entries_by_number,
          2, ClientUploadResponse_UploadStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientUploadResponse_UploadStatus_entries,
      ClientUploadResponse_UploadStatus_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientUploadResponse_UploadStatus_strings[idx].get();
}
bool ClientUploadResponse_UploadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientUploadResponse_UploadStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientUploadResponse_UploadStatus_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ClientUploadResponse_UploadStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::SUCCESS;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UPLOAD_FAILURE;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UploadStatus_MIN;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UploadStatus_MAX;
constexpr int ClientUploadResponse::UploadStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings[7] = {};

static const char ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names[] =
  "BYPASS_CHANGED"
  "BYPASS_CLEARED"
  "CHANGED"
  "CLEARED"
  "UNKNOWN"
  "UNTRUSTED_UNKNOWN_VALUE"
  "WEAK_LEGACY_OBSOLETE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries[] = {
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 0, 14}, 6 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 14, 14}, 5 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 28, 7}, 3 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 35, 7}, 1 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 42, 7}, 0 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 49, 23}, 4 },
  { {ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 72, 20}, 2 },
};

static const int ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number[] = {
  4, // 0 -> UNKNOWN
  3, // 1 -> CLEARED
  6, // 2 -> WEAK_LEGACY_OBSOLETE
  2, // 3 -> CHANGED
  5, // 4 -> UNTRUSTED_UNKNOWN_VALUE
  1, // 5 -> BYPASS_CLEARED
  0, // 6 -> BYPASS_CHANGED
};

const std::string& ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_Name(
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries,
          ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number,
          7, ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries,
      ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings[idx].get();
}
bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::UNKNOWN;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CLEARED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::WEAK_LEGACY_OBSOLETE;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CHANGED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::UNTRUSTED_UNKNOWN_VALUE;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::BYPASS_CLEARED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::BYPASS_CHANGED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_MIN;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_MAX;
constexpr int ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings[2] = {};

static const char ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names[] =
  "TYPE_PATTERN"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries[] = {
  { {ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names + 0, 12}, 3 },
  { {ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names + 12, 7}, 0 },
};

static const int ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number[] = {
  1, // 0 -> UNKNOWN
  0, // 3 -> TYPE_PATTERN
};

const std::string& ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_Name(
    ClientIncidentReport_IncidentData_ResourceRequestIncident_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries,
          ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number,
          2, ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries,
      ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings[idx].get();
}
bool ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_IncidentData_ResourceRequestIncident_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_IncidentData_ResourceRequestIncident_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::UNKNOWN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::TYPE_PATTERN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_MIN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_MAX;
constexpr int ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings[2] = {};

static const char ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names[] =
  "LSP"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries[] = {
  { {ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names + 0, 3}, 1 },
  { {ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names + 3, 7}, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number[] = {
  1, // 0 -> UNKNOWN
  0, // 1 -> LSP
};

const std::string& ClientIncidentReport_EnvironmentData_Process_Dll_Feature_Name(
    ClientIncidentReport_EnvironmentData_Process_Dll_Feature value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries,
          ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number,
          2, ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries,
      ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_Dll_Feature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_Dll_Feature* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_EnvironmentData_Process_Dll_Feature>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::LSP;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::Feature_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::Feature_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process_Dll::Feature_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings[4] = {};

static const char ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names[] =
  "MODULE_STATE_MODIFIED"
  "MODULE_STATE_UNKNOWN"
  "MODULE_STATE_UNMODIFIED"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries[] = {
  { {ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 0, 21}, 3 },
  { {ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 21, 20}, 1 },
  { {ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 41, 23}, 2 },
  { {ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 64, 7}, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  1, // 1 -> MODULE_STATE_UNKNOWN
  2, // 2 -> MODULE_STATE_UNMODIFIED
  0, // 3 -> MODULE_STATE_MODIFIED
};

const std::string& ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_Name(
    ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries,
          ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number,
          4, ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries,
      ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_UNMODIFIED;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_MODIFIED;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_Channel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_Channel_strings[5] = {};

static const char ClientIncidentReport_EnvironmentData_Process_Channel_names[] =
  "CHANNEL_BETA"
  "CHANNEL_CANARY"
  "CHANNEL_DEV"
  "CHANNEL_STABLE"
  "CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_Channel_entries[] = {
  { {ClientIncidentReport_EnvironmentData_Process_Channel_names + 0, 12}, 3 },
  { {ClientIncidentReport_EnvironmentData_Process_Channel_names + 12, 14}, 1 },
  { {ClientIncidentReport_EnvironmentData_Process_Channel_names + 26, 11}, 2 },
  { {ClientIncidentReport_EnvironmentData_Process_Channel_names + 37, 14}, 4 },
  { {ClientIncidentReport_EnvironmentData_Process_Channel_names + 51, 15}, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number[] = {
  4, // 0 -> CHANNEL_UNKNOWN
  1, // 1 -> CHANNEL_CANARY
  2, // 2 -> CHANNEL_DEV
  0, // 3 -> CHANNEL_BETA
  3, // 4 -> CHANNEL_STABLE
};

const std::string& ClientIncidentReport_EnvironmentData_Process_Channel_Name(
    ClientIncidentReport_EnvironmentData_Process_Channel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_EnvironmentData_Process_Channel_entries,
          ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number,
          5, ClientIncidentReport_EnvironmentData_Process_Channel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_EnvironmentData_Process_Channel_entries,
      ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_EnvironmentData_Process_Channel_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_Channel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_EnvironmentData_Process_Channel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_EnvironmentData_Process_Channel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_CANARY;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_DEV;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_BETA;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_STABLE;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::Channel_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::Channel_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process::Channel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings[6] = {};

static const char ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names[] =
  "STATE_BLACKLISTED"
  "STATE_BLOCKED"
  "STATE_DISABLED"
  "STATE_ENABLED"
  "STATE_TERMINATED"
  "STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries[] = {
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 0, 17}, 3 },
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 17, 13}, 4 },
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 30, 14}, 2 },
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 44, 13}, 1 },
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 57, 16}, 5 },
  { {ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 73, 13}, 0 },
};

static const int ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number[] = {
  5, // 0 -> STATE_UNKNOWN
  3, // 1 -> STATE_ENABLED
  2, // 2 -> STATE_DISABLED
  0, // 3 -> STATE_BLACKLISTED
  1, // 4 -> STATE_BLOCKED
  4, // 5 -> STATE_TERMINATED
};

const std::string& ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_Name(
    ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries,
          ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number,
          6, ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries,
      ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings[idx].get();
}
bool ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_UNKNOWN;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_ENABLED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_DISABLED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_BLACKLISTED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_BLOCKED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_TERMINATED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_MIN;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_MAX;
constexpr int ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_ReportType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_ReportType_strings[12] = {};

static const char ClientSafeBrowsingReportRequest_ReportType_names[] =
  "AD_SAMPLE"
  "DANGEROUS_DOWNLOAD_BY_API"
  "DANGEROUS_DOWNLOAD_OPENED"
  "DANGEROUS_DOWNLOAD_RECOVERY"
  "DANGEROUS_DOWNLOAD_WARNING"
  "UNKNOWN"
  "URL_CLIENT_SIDE_MALWARE"
  "URL_CLIENT_SIDE_PHISHING"
  "URL_MALWARE"
  "URL_PASSWORD_PROTECTION_PHISHING"
  "URL_PHISHING"
  "URL_UNWANTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_ReportType_entries[] = {
  { {ClientSafeBrowsingReportRequest_ReportType_names + 0, 9}, 14 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 9, 25}, 10 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 34, 25}, 13 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 59, 27}, 6 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 86, 26}, 7 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 112, 7}, 0 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 119, 23}, 5 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 142, 24}, 4 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 166, 11}, 2 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 177, 32}, 12 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 209, 12}, 1 },
  { {ClientSafeBrowsingReportRequest_ReportType_names + 221, 12}, 3 },
};

static const int ClientSafeBrowsingReportRequest_ReportType_entries_by_number[] = {
  5, // 0 -> UNKNOWN
  10, // 1 -> URL_PHISHING
  8, // 2 -> URL_MALWARE
  11, // 3 -> URL_UNWANTED
  7, // 4 -> URL_CLIENT_SIDE_PHISHING
  6, // 5 -> URL_CLIENT_SIDE_MALWARE
  3, // 6 -> DANGEROUS_DOWNLOAD_RECOVERY
  4, // 7 -> DANGEROUS_DOWNLOAD_WARNING
  1, // 10 -> DANGEROUS_DOWNLOAD_BY_API
  9, // 12 -> URL_PASSWORD_PROTECTION_PHISHING
  2, // 13 -> DANGEROUS_DOWNLOAD_OPENED
  0, // 14 -> AD_SAMPLE
};

const std::string& ClientSafeBrowsingReportRequest_ReportType_Name(
    ClientSafeBrowsingReportRequest_ReportType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientSafeBrowsingReportRequest_ReportType_entries,
          ClientSafeBrowsingReportRequest_ReportType_entries_by_number,
          12, ClientSafeBrowsingReportRequest_ReportType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientSafeBrowsingReportRequest_ReportType_entries,
      ClientSafeBrowsingReportRequest_ReportType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientSafeBrowsingReportRequest_ReportType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_ReportType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_ReportType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientSafeBrowsingReportRequest_ReportType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<ClientSafeBrowsingReportRequest_ReportType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::UNKNOWN;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_MALWARE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_UNWANTED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_CLIENT_SIDE_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_CLIENT_SIDE_MALWARE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_RECOVERY;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_WARNING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_BY_API;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_PASSWORD_PROTECTION_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_OPENED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::AD_SAMPLE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::ReportType_MIN;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::ReportType_MAX;
constexpr int ClientSafeBrowsingReportRequest::ReportType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings[5] = {};

static const char ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names[] =
  "ANDROID_SAFETYNET"
  "FLYWHEEL"
  "PVER3_NATIVE"
  "PVER4_NATIVE"
  "SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries[] = {
  { {ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 0, 17}, 3 },
  { {ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 17, 8}, 4 },
  { {ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 25, 12}, 1 },
  { {ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 37, 12}, 2 },
  { {ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 49, 38}, 0 },
};

static const int ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number[] = {
  4, // 0 -> SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED
  2, // 1 -> PVER3_NATIVE
  3, // 2 -> PVER4_NATIVE
  0, // 3 -> ANDROID_SAFETYNET
  1, // 4 -> FLYWHEEL
};

const std::string& ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_Name(
    ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries,
          ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number,
          5, ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries,
      ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::PVER3_NATIVE;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::PVER4_NATIVE;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::ANDROID_SAFETYNET;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::FLYWHEEL;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_MIN;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_MAX;
constexpr int ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ChromeUserPopulation::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeUserPopulation>()._impl_._has_bits_);
  static void set_has_user_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_history_sync_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ChromeUserPopulation::ChromeUserPopulation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ChromeUserPopulation)
}
ChromeUserPopulation::ChromeUserPopulation(const ChromeUserPopulation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeUserPopulation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.finch_active_groups_){from._impl_.finch_active_groups_}
    , decltype(_impl_.user_population_){}
    , decltype(_impl_.is_history_sync_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.user_population_, &from._impl_.user_population_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_history_sync_enabled_) -
    reinterpret_cast<char*>(&_impl_.user_population_)) + sizeof(_impl_.is_history_sync_enabled_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ChromeUserPopulation)
}

inline void ChromeUserPopulation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.finch_active_groups_){arena}
    , decltype(_impl_.user_population_){0}
    , decltype(_impl_.is_history_sync_enabled_){false}
  };
}

ChromeUserPopulation::~ChromeUserPopulation() {
  // @@protoc_insertion_point(destructor:safe_browsing.ChromeUserPopulation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeUserPopulation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.finch_active_groups_.~RepeatedPtrField();
}

void ChromeUserPopulation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeUserPopulation::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ChromeUserPopulation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.finch_active_groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.user_population_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_history_sync_enabled_) -
        reinterpret_cast<char*>(&_impl_.user_population_)) + sizeof(_impl_.is_history_sync_enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeUserPopulation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ChromeUserPopulation_UserPopulation_IsValid(val))) {
            _internal_set_user_population(static_cast<::safe_browsing::ChromeUserPopulation_UserPopulation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_history_sync_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_history_sync_enabled(&has_bits);
          _impl_.is_history_sync_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string finch_active_groups = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_finch_active_groups();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeUserPopulation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ChromeUserPopulation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_user_population(), target);
  }

  // optional bool is_history_sync_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_history_sync_enabled(), target);
  }

  // repeated string finch_active_groups = 4;
  for (int i = 0, n = this->_internal_finch_active_groups_size(); i < n; i++) {
    const auto& s = this->_internal_finch_active_groups(i);
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ChromeUserPopulation)
  return target;
}

size_t ChromeUserPopulation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ChromeUserPopulation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string finch_active_groups = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.finch_active_groups_.size());
  for (int i = 0, n = _impl_.finch_active_groups_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.finch_active_groups_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_user_population());
    }

    // optional bool is_history_sync_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeUserPopulation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeUserPopulation*>(
      &from));
}

void ChromeUserPopulation::MergeFrom(const ChromeUserPopulation& from) {
  ChromeUserPopulation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ChromeUserPopulation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.finch_active_groups_.MergeFrom(from._impl_.finch_active_groups_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.user_population_ = from._impl_.user_population_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_history_sync_enabled_ = from._impl_.is_history_sync_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeUserPopulation::CopyFrom(const ChromeUserPopulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ChromeUserPopulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeUserPopulation::IsInitialized() const {
  return true;
}

void ChromeUserPopulation::InternalSwap(ChromeUserPopulation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.finch_active_groups_.InternalSwap(&other->_impl_.finch_active_groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChromeUserPopulation, _impl_.is_history_sync_enabled_)
      + sizeof(ChromeUserPopulation::_impl_.is_history_sync_enabled_)
      - PROTOBUF_FIELD_OFFSET(ChromeUserPopulation, _impl_.user_population_)>(
          reinterpret_cast<char*>(&_impl_.user_population_),
          reinterpret_cast<char*>(&other->_impl_.user_population_));
}

std::string ChromeUserPopulation::GetTypeName() const {
  return "safe_browsing.ChromeUserPopulation";
}


// ===================================================================

class ClientPhishingRequest_Feature::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientPhishingRequest_Feature>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingRequest.Feature)
}
ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(const ClientPhishingRequest_Feature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientPhishingRequest_Feature* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingRequest.Feature)
}

inline void ClientPhishingRequest_Feature::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientPhishingRequest_Feature::~ClientPhishingRequest_Feature() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingRequest.Feature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientPhishingRequest_Feature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ClientPhishingRequest_Feature::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientPhishingRequest_Feature::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingRequest.Feature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingRequest_Feature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingRequest_Feature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingRequest.Feature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required double value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingRequest.Feature)
  return target;
}

size_t ClientPhishingRequest_Feature::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientPhishingRequest.Feature)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_value()) {
    // required double value = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t ClientPhishingRequest_Feature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingRequest.Feature)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required double value = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientPhishingRequest_Feature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientPhishingRequest_Feature*>(
      &from));
}

void ClientPhishingRequest_Feature::MergeFrom(const ClientPhishingRequest_Feature& from) {
  ClientPhishingRequest_Feature* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingRequest.Feature)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingRequest_Feature::CopyFrom(const ClientPhishingRequest_Feature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingRequest.Feature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientPhishingRequest_Feature::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientPhishingRequest_Feature::InternalSwap(ClientPhishingRequest_Feature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

std::string ClientPhishingRequest_Feature::GetTypeName() const {
  return "safe_browsing.ClientPhishingRequest.Feature";
}


// ===================================================================

class ClientPhishingRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientPhishingRequest>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obsolete_hash_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_client_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_phishing(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_model_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_obsolete_referrer_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::safe_browsing::ChromeUserPopulation& population(const ClientPhishingRequest* msg);
  static void set_has_population(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000020) ^ 0x00000020) != 0;
  }
};

const ::safe_browsing::ChromeUserPopulation&
ClientPhishingRequest::_Internal::population(const ClientPhishingRequest* msg) {
  return *msg->_impl_.population_;
}
ClientPhishingRequest::ClientPhishingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingRequest)
}
ClientPhishingRequest::ClientPhishingRequest(const ClientPhishingRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientPhishingRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feature_map_){from._impl_.feature_map_}
    , decltype(_impl_.non_model_feature_map_){from._impl_.non_model_feature_map_}
    , decltype(_impl_.shingle_hashes_){from._impl_.shingle_hashes_}
    , /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/{0}
    , decltype(_impl_.url_){}
    , decltype(_impl_.obsolete_referrer_url_){}
    , decltype(_impl_.obsolete_hash_prefix_){}
    , decltype(_impl_.model_filename_){}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.client_score_){}
    , decltype(_impl_.is_phishing_){}
    , decltype(_impl_.model_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_referrer_url()) {
    _this->_impl_.obsolete_referrer_url_.Set(from._internal_obsolete_referrer_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.obsolete_hash_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_hash_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_obsolete_hash_prefix()) {
    _this->_impl_.obsolete_hash_prefix_.Set(from._internal_obsolete_hash_prefix(),
      _this->GetArenaForAllocation());
  }
  _impl_.model_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_filename()) {
    _this->_impl_.model_filename_.Set(from._internal_model_filename(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_population()) {
    _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
  }
  ::memcpy(&_impl_.client_score_, &from._impl_.client_score_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.model_version_) -
    reinterpret_cast<char*>(&_impl_.client_score_)) + sizeof(_impl_.model_version_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingRequest)
}

inline void ClientPhishingRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feature_map_){arena}
    , decltype(_impl_.non_model_feature_map_){arena}
    , decltype(_impl_.shingle_hashes_){arena}
    , /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/{0}
    , decltype(_impl_.url_){}
    , decltype(_impl_.obsolete_referrer_url_){}
    , decltype(_impl_.obsolete_hash_prefix_){}
    , decltype(_impl_.model_filename_){}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.client_score_){0}
    , decltype(_impl_.is_phishing_){false}
    , decltype(_impl_.model_version_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.obsolete_hash_prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_hash_prefix_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientPhishingRequest::~ClientPhishingRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientPhishingRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feature_map_.~RepeatedPtrField();
  _impl_.non_model_feature_map_.~RepeatedPtrField();
  _impl_.shingle_hashes_.~RepeatedField();
  _impl_.url_.Destroy();
  _impl_.obsolete_referrer_url_.Destroy();
  _impl_.obsolete_hash_prefix_.Destroy();
  _impl_.model_filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.population_;
}

void ClientPhishingRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientPhishingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feature_map_.Clear();
  _impl_.non_model_feature_map_.Clear();
  _impl_.shingle_hashes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.obsolete_referrer_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.obsolete_hash_prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.model_filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.population_ != nullptr);
      _impl_.population_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.client_score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.model_version_) -
        reinterpret_cast<char*>(&_impl_.client_score_)) + sizeof(_impl_.model_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float client_score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_client_score(&has_bits);
          _impl_.client_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_phishing = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_phishing(&has_bits);
          _impl_.is_phishing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_feature_map(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 model_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_model_version(&has_bits);
          _impl_.model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_non_model_feature_map(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string OBSOLETE_referrer_url = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_obsolete_referrer_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes OBSOLETE_hash_prefix = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_obsolete_hash_prefix();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 shingle_hashes = 12 [packed = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_shingle_hashes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 96) {
          _internal_add_shingle_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_filename = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_model_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeUserPopulation population = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // required float client_score = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_client_score(), target);
  }

  // optional bool is_phishing = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_phishing(), target);
  }

  // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_feature_map_size()); i < n; i++) {
    const auto& repfield = this->_internal_feature_map(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 model_version = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_model_version(), target);
  }

  // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_non_model_feature_map_size()); i < n; i++) {
    const auto& repfield = this->_internal_non_model_feature_map(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string OBSOLETE_referrer_url = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_obsolete_referrer_url(), target);
  }

  // optional bytes OBSOLETE_hash_prefix = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_obsolete_hash_prefix(), target);
  }

  // repeated uint32 shingle_hashes = 12 [packed = true];
  {
    int byte_size = _impl_._shingle_hashes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          12, _internal_shingle_hashes(), byte_size, target);
    }
  }

  // optional string model_filename = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_model_filename(), target);
  }

  // optional .safe_browsing.ChromeUserPopulation population = 14;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::population(this),
        _Internal::population(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingRequest)
  return target;
}

size_t ClientPhishingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingRequest)
  size_t total_size = 0;

  // required float client_score = 2;
  if (_internal_has_client_score()) {
    total_size += 1 + 4;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
  total_size += 1UL * this->_internal_feature_map_size();
  for (const auto& msg : this->_impl_.feature_map_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
  total_size += 1UL * this->_internal_non_model_feature_map_size();
  for (const auto& msg : this->_impl_.non_model_feature_map_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 shingle_hashes = 12 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.shingle_hashes_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._shingle_hashes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string OBSOLETE_referrer_url = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_obsolete_referrer_url());
    }

    // optional bytes OBSOLETE_hash_prefix = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_obsolete_hash_prefix());
    }

    // optional string model_filename = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_filename());
    }

    // optional .safe_browsing.ChromeUserPopulation population = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.population_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional bool is_phishing = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 model_version = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientPhishingRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientPhishingRequest*>(
      &from));
}

void ClientPhishingRequest::MergeFrom(const ClientPhishingRequest& from) {
  ClientPhishingRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.feature_map_.MergeFrom(from._impl_.feature_map_);
  _this->_impl_.non_model_feature_map_.MergeFrom(from._impl_.non_model_feature_map_);
  _this->_impl_.shingle_hashes_.MergeFrom(from._impl_.shingle_hashes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_obsolete_referrer_url(from._internal_obsolete_referrer_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_obsolete_hash_prefix(from._internal_obsolete_hash_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_model_filename(from._internal_model_filename());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(
          from._internal_population());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.client_score_ = from._impl_.client_score_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_phishing_ = from._impl_.is_phishing_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.model_version_ = from._impl_.model_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingRequest::CopyFrom(const ClientPhishingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientPhishingRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.feature_map_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.non_model_feature_map_))
    return false;
  return true;
}

void ClientPhishingRequest::InternalSwap(ClientPhishingRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.feature_map_.InternalSwap(&other->_impl_.feature_map_);
  _impl_.non_model_feature_map_.InternalSwap(&other->_impl_.non_model_feature_map_);
  _impl_.shingle_hashes_.InternalSwap(&other->_impl_.shingle_hashes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_referrer_url_, lhs_arena,
      &other->_impl_.obsolete_referrer_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.obsolete_hash_prefix_, lhs_arena,
      &other->_impl_.obsolete_hash_prefix_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_filename_, lhs_arena,
      &other->_impl_.model_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientPhishingRequest, _impl_.model_version_)
      + sizeof(ClientPhishingRequest::_impl_.model_version_)
      - PROTOBUF_FIELD_OFFSET(ClientPhishingRequest, _impl_.population_)>(
          reinterpret_cast<char*>(&_impl_.population_),
          reinterpret_cast<char*>(&other->_impl_.population_));
}

std::string ClientPhishingRequest::GetTypeName() const {
  return "safe_browsing.ClientPhishingRequest";
}


// ===================================================================

class ClientPhishingResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientPhishingResponse>()._impl_._has_bits_);
  static void set_has_phishy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClientPhishingResponse::ClientPhishingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingResponse)
}
ClientPhishingResponse::ClientPhishingResponse(const ClientPhishingResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientPhishingResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_whitelist_expression_){from._impl_.obsolete_whitelist_expression_}
    , decltype(_impl_.phishy_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.phishy_ = from._impl_.phishy_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingResponse)
}

inline void ClientPhishingResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_whitelist_expression_){arena}
    , decltype(_impl_.phishy_){false}
  };
}

ClientPhishingResponse::~ClientPhishingResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientPhishingResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_whitelist_expression_.~RepeatedPtrField();
}

void ClientPhishingResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientPhishingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_whitelist_expression_.Clear();
  _impl_.phishy_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool phishy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_phishy(&has_bits);
          _impl_.phishy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string OBSOLETE_whitelist_expression = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_obsolete_whitelist_expression();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool phishy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_phishy(), target);
  }

  // repeated string OBSOLETE_whitelist_expression = 2;
  for (int i = 0, n = this->_internal_obsolete_whitelist_expression_size(); i < n; i++) {
    const auto& s = this->_internal_obsolete_whitelist_expression(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingResponse)
  return target;
}

size_t ClientPhishingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingResponse)
  size_t total_size = 0;

  // required bool phishy = 1;
  if (_internal_has_phishy()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string OBSOLETE_whitelist_expression = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_whitelist_expression_.size());
  for (int i = 0, n = _impl_.obsolete_whitelist_expression_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.obsolete_whitelist_expression_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientPhishingResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientPhishingResponse*>(
      &from));
}

void ClientPhishingResponse::MergeFrom(const ClientPhishingResponse& from) {
  ClientPhishingResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.obsolete_whitelist_expression_.MergeFrom(from._impl_.obsolete_whitelist_expression_);
  if (from._internal_has_phishy()) {
    _this->_internal_set_phishy(from._internal_phishy());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingResponse::CopyFrom(const ClientPhishingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientPhishingResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientPhishingResponse::InternalSwap(ClientPhishingResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.obsolete_whitelist_expression_.InternalSwap(&other->_impl_.obsolete_whitelist_expression_);
  swap(_impl_.phishy_, other->_impl_.phishy_);
}

std::string ClientPhishingResponse::GetTypeName() const {
  return "safe_browsing.ClientPhishingResponse";
}


// ===================================================================

class ClientMalwareRequest_UrlInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMalwareRequest_UrlInfo>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referrer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_resource_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ClientMalwareRequest_UrlInfo::ClientMalwareRequest_UrlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientMalwareRequest.UrlInfo)
}
ClientMalwareRequest_UrlInfo::ClientMalwareRequest_UrlInfo(const ClientMalwareRequest_UrlInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientMalwareRequest_UrlInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.resource_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(),
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_method()) {
    _this->_impl_.method_.Set(from._internal_method(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer()) {
    _this->_impl_.referrer_.Set(from._internal_referrer(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.resource_type_ = from._impl_.resource_type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientMalwareRequest.UrlInfo)
}

inline void ClientMalwareRequest_UrlInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.resource_type_){0}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMalwareRequest_UrlInfo::~ClientMalwareRequest_UrlInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientMalwareRequest.UrlInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMalwareRequest_UrlInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
  _impl_.url_.Destroy();
  _impl_.method_.Destroy();
  _impl_.referrer_.Destroy();
}

void ClientMalwareRequest_UrlInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientMalwareRequest_UrlInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.referrer_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.resource_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMalwareRequest_UrlInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string method = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 resource_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_resource_type(&has_bits);
          _impl_.resource_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMalwareRequest_UrlInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required string url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // optional string method = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_method(), target);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer(), target);
  }

  // optional int32 resource_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_resource_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientMalwareRequest.UrlInfo)
  return target;
}

size_t ClientMalwareRequest_UrlInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_url()) {
    // required string url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  return total_size;
}
size_t ClientMalwareRequest_UrlInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required string url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional string method = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_method());
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer());
    }

    // optional int32 resource_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resource_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMalwareRequest_UrlInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMalwareRequest_UrlInfo*>(
      &from));
}

void ClientMalwareRequest_UrlInfo::MergeFrom(const ClientMalwareRequest_UrlInfo& from) {
  ClientMalwareRequest_UrlInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_method(from._internal_method());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_referrer(from._internal_referrer());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.resource_type_ = from._impl_.resource_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMalwareRequest_UrlInfo::CopyFrom(const ClientMalwareRequest_UrlInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientMalwareRequest.UrlInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMalwareRequest_UrlInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientMalwareRequest_UrlInfo::InternalSwap(ClientMalwareRequest_UrlInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_, lhs_arena,
      &other->_impl_.referrer_, rhs_arena
  );
  swap(_impl_.resource_type_, other->_impl_.resource_type_);
}

std::string ClientMalwareRequest_UrlInfo::GetTypeName() const {
  return "safe_browsing.ClientMalwareRequest.UrlInfo";
}


// ===================================================================

class ClientMalwareRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMalwareRequest>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_referrer_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ChromeUserPopulation& population(const ClientMalwareRequest* msg);
  static void set_has_population(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::safe_browsing::ChromeUserPopulation&
ClientMalwareRequest::_Internal::population(const ClientMalwareRequest* msg) {
  return *msg->_impl_.population_;
}
ClientMalwareRequest::ClientMalwareRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientMalwareRequest)
}
ClientMalwareRequest::ClientMalwareRequest(const ClientMalwareRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientMalwareRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bad_ip_url_info_){from._impl_.bad_ip_url_info_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.population_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer_url()) {
    _this->_impl_.referrer_url_.Set(from._internal_referrer_url(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_population()) {
    _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientMalwareRequest)
}

inline void ClientMalwareRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bad_ip_url_info_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.population_){nullptr}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMalwareRequest::~ClientMalwareRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientMalwareRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMalwareRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bad_ip_url_info_.~RepeatedPtrField();
  _impl_.url_.Destroy();
  _impl_.referrer_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.population_;
}

void ClientMalwareRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientMalwareRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientMalwareRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bad_ip_url_info_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.referrer_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.population_ != nullptr);
      _impl_.population_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMalwareRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientMalwareRequest.UrlInfo bad_ip_url_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bad_ip_url_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeUserPopulation population = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMalwareRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientMalwareRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string referrer_url = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer_url(), target);
  }

  // repeated .safe_browsing.ClientMalwareRequest.UrlInfo bad_ip_url_info = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bad_ip_url_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_bad_ip_url_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ChromeUserPopulation population = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::population(this),
        _Internal::population(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientMalwareRequest)
  return target;
}

size_t ClientMalwareRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientMalwareRequest)
  size_t total_size = 0;

  // required string url = 1;
  if (_internal_has_url()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientMalwareRequest.UrlInfo bad_ip_url_info = 7;
  total_size += 1UL * this->_internal_bad_ip_url_info_size();
  for (const auto& msg : this->_impl_.bad_ip_url_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string referrer_url = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer_url());
    }

    // optional .safe_browsing.ChromeUserPopulation population = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.population_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMalwareRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMalwareRequest*>(
      &from));
}

void ClientMalwareRequest::MergeFrom(const ClientMalwareRequest& from) {
  ClientMalwareRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientMalwareRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bad_ip_url_info_.MergeFrom(from._impl_.bad_ip_url_info_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_referrer_url(from._internal_referrer_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(
          from._internal_population());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMalwareRequest::CopyFrom(const ClientMalwareRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientMalwareRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMalwareRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.bad_ip_url_info_))
    return false;
  return true;
}

void ClientMalwareRequest::InternalSwap(ClientMalwareRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bad_ip_url_info_.InternalSwap(&other->_impl_.bad_ip_url_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_url_, lhs_arena,
      &other->_impl_.referrer_url_, rhs_arena
  );
  swap(_impl_.population_, other->_impl_.population_);
}

std::string ClientMalwareRequest::GetTypeName() const {
  return "safe_browsing.ClientMalwareRequest";
}


// ===================================================================

class LoginReputationClientRequest_Frame_Form::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReputationClientRequest_Frame_Form>()._impl_._has_bits_);
  static void set_has_action_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_password_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
}
LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(const LoginReputationClientRequest_Frame_Form& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginReputationClientRequest_Frame_Form* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_url_){}
    , decltype(_impl_.has_password_field_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.action_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action_url()) {
    _this->_impl_.action_url_.Set(from._internal_action_url(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
}

inline void LoginReputationClientRequest_Frame_Form::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.action_url_){}
    , decltype(_impl_.has_password_field_){false}
  };
  _impl_.action_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest_Frame_Form::~LoginReputationClientRequest_Frame_Form() {
  // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReputationClientRequest_Frame_Form::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.action_url_.Destroy();
}

void LoginReputationClientRequest_Frame_Form::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_Frame_Form::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.action_url_.ClearNonDefaultToEmpty();
  }
  _impl_.has_password_field_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_Frame_Form::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string action_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_action_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_password_field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_has_password_field(&has_bits);
          _impl_.has_password_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_Frame_Form::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string action_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_action_url(), target);
  }

  // optional bool has_password_field = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_password_field(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.Frame.Form)
  return target;
}

size_t LoginReputationClientRequest_Frame_Form::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string action_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action_url());
    }

    // optional bool has_password_field = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginReputationClientRequest_Frame_Form::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_Frame_Form*>(
      &from));
}

void LoginReputationClientRequest_Frame_Form::MergeFrom(const LoginReputationClientRequest_Frame_Form& from) {
  LoginReputationClientRequest_Frame_Form* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_action_url(from._internal_action_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_Frame_Form::CopyFrom(const LoginReputationClientRequest_Frame_Form& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReputationClientRequest_Frame_Form::IsInitialized() const {
  return true;
}

void LoginReputationClientRequest_Frame_Form::InternalSwap(LoginReputationClientRequest_Frame_Form* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.action_url_, lhs_arena,
      &other->_impl_.action_url_, rhs_arena
  );
  swap(_impl_.has_password_field_, other->_impl_.has_password_field_);
}

std::string LoginReputationClientRequest_Frame_Form::GetTypeName() const {
  return "safe_browsing.LoginReputationClientRequest.Frame.Form";
}


// ===================================================================

class LoginReputationClientRequest_Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReputationClientRequest_Frame>()._impl_._has_bits_);
  static void set_has_frame_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent_frame_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_password_field(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.Frame)
}
LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(const LoginReputationClientRequest_Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginReputationClientRequest_Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referrer_chain_){from._impl_.referrer_chain_}
    , decltype(_impl_.forms_){from._impl_.forms_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.frame_index_){}
    , decltype(_impl_.parent_frame_index_){}
    , decltype(_impl_.has_password_field_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.frame_index_, &from._impl_.frame_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_password_field_) -
    reinterpret_cast<char*>(&_impl_.frame_index_)) + sizeof(_impl_.has_password_field_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.Frame)
}

inline void LoginReputationClientRequest_Frame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referrer_chain_){arena}
    , decltype(_impl_.forms_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.frame_index_){0}
    , decltype(_impl_.parent_frame_index_){0}
    , decltype(_impl_.has_password_field_){false}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest_Frame::~LoginReputationClientRequest_Frame() {
  // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReputationClientRequest_Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.referrer_chain_.~RepeatedPtrField();
  _impl_.forms_.~RepeatedPtrField();
  _impl_.url_.Destroy();
}

void LoginReputationClientRequest_Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.referrer_chain_.Clear();
  _impl_.forms_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.frame_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.has_password_field_) -
        reinterpret_cast<char*>(&_impl_.frame_index_)) + sizeof(_impl_.has_password_field_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 frame_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_frame_index(&has_bits);
          _impl_.frame_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 parent_frame_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_parent_frame_index(&has_bits);
          _impl_.parent_frame_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_password_field = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_has_password_field(&has_bits);
          _impl_.has_password_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_forms(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 frame_index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_frame_index(), target);
  }

  // optional int32 parent_frame_index = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_parent_frame_index(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  // optional bool has_password_field = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_has_password_field(), target);
  }

  // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
    const auto& repfield = this->_internal_referrer_chain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_forms_size()); i < n; i++) {
    const auto& repfield = this->_internal_forms(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.Frame)
  return target;
}

size_t LoginReputationClientRequest_Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
  total_size += 1UL * this->_internal_referrer_chain_size();
  for (const auto& msg : this->_impl_.referrer_chain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
  total_size += 1UL * this->_internal_forms_size();
  for (const auto& msg : this->_impl_.forms_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional int32 frame_index = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_index());
    }

    // optional int32 parent_frame_index = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_frame_index());
    }

    // optional bool has_password_field = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginReputationClientRequest_Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_Frame*>(
      &from));
}

void LoginReputationClientRequest_Frame::MergeFrom(const LoginReputationClientRequest_Frame& from) {
  LoginReputationClientRequest_Frame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.Frame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
  _this->_impl_.forms_.MergeFrom(from._impl_.forms_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.frame_index_ = from._impl_.frame_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_frame_index_ = from._impl_.parent_frame_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_Frame::CopyFrom(const LoginReputationClientRequest_Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReputationClientRequest_Frame::IsInitialized() const {
  return true;
}

void LoginReputationClientRequest_Frame::InternalSwap(LoginReputationClientRequest_Frame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
  _impl_.forms_.InternalSwap(&other->_impl_.forms_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_Frame, _impl_.has_password_field_)
      + sizeof(LoginReputationClientRequest_Frame::_impl_.has_password_field_)
      - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_Frame, _impl_.frame_index_)>(
          reinterpret_cast<char*>(&_impl_.frame_index_),
          reinterpret_cast<char*>(&other->_impl_.frame_index_));
}

std::string LoginReputationClientRequest_Frame::GetTypeName() const {
  return "safe_browsing.LoginReputationClientRequest.Frame";
}


// ===================================================================

class LoginReputationClientRequest_PasswordReuseEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReputationClientRequest_PasswordReuseEvent>()._impl_._has_bits_);
  static void set_has_frame_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_chrome_signin_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sync_account_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
}
LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(const LoginReputationClientRequest_PasswordReuseEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginReputationClientRequest_PasswordReuseEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domains_matching_password_){from._impl_.domains_matching_password_}
    , decltype(_impl_.frame_id_){}
    , decltype(_impl_.is_chrome_signin_password_){}
    , decltype(_impl_.sync_account_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.frame_id_, &from._impl_.frame_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sync_account_type_) -
    reinterpret_cast<char*>(&_impl_.frame_id_)) + sizeof(_impl_.sync_account_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
}

inline void LoginReputationClientRequest_PasswordReuseEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.domains_matching_password_){arena}
    , decltype(_impl_.frame_id_){0}
    , decltype(_impl_.is_chrome_signin_password_){false}
    , decltype(_impl_.sync_account_type_){0}
  };
}

LoginReputationClientRequest_PasswordReuseEvent::~LoginReputationClientRequest_PasswordReuseEvent() {
  // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReputationClientRequest_PasswordReuseEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.domains_matching_password_.~RepeatedPtrField();
}

void LoginReputationClientRequest_PasswordReuseEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_PasswordReuseEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.domains_matching_password_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.frame_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sync_account_type_) -
        reinterpret_cast<char*>(&_impl_.frame_id_)) + sizeof(_impl_.sync_account_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_PasswordReuseEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string domains_matching_password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_domains_matching_password();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 frame_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_frame_id(&has_bits);
          _impl_.frame_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_chrome_signin_password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_chrome_signin_password(&has_bits);
          _impl_.is_chrome_signin_password_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_IsValid(val))) {
            _internal_set_sync_account_type(static_cast<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_PasswordReuseEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string domains_matching_password = 1;
  for (int i = 0, n = this->_internal_domains_matching_password_size(); i < n; i++) {
    const auto& s = this->_internal_domains_matching_password(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 frame_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_frame_id(), target);
  }

  // optional bool is_chrome_signin_password = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_chrome_signin_password(), target);
  }

  // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_sync_account_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  return target;
}

size_t LoginReputationClientRequest_PasswordReuseEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string domains_matching_password = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.domains_matching_password_.size());
  for (int i = 0, n = _impl_.domains_matching_password_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.domains_matching_password_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 frame_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_id());
    }

    // optional bool is_chrome_signin_password = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sync_account_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginReputationClientRequest_PasswordReuseEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_PasswordReuseEvent*>(
      &from));
}

void LoginReputationClientRequest_PasswordReuseEvent::MergeFrom(const LoginReputationClientRequest_PasswordReuseEvent& from) {
  LoginReputationClientRequest_PasswordReuseEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.domains_matching_password_.MergeFrom(from._impl_.domains_matching_password_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.frame_id_ = from._impl_.frame_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_chrome_signin_password_ = from._impl_.is_chrome_signin_password_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_account_type_ = from._impl_.sync_account_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_PasswordReuseEvent::CopyFrom(const LoginReputationClientRequest_PasswordReuseEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReputationClientRequest_PasswordReuseEvent::IsInitialized() const {
  return true;
}

void LoginReputationClientRequest_PasswordReuseEvent::InternalSwap(LoginReputationClientRequest_PasswordReuseEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.domains_matching_password_.InternalSwap(&other->_impl_.domains_matching_password_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_PasswordReuseEvent, _impl_.sync_account_type_)
      + sizeof(LoginReputationClientRequest_PasswordReuseEvent::_impl_.sync_account_type_)
      - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_PasswordReuseEvent, _impl_.frame_id_)>(
          reinterpret_cast<char*>(&_impl_.frame_id_),
          reinterpret_cast<char*>(&other->_impl_.frame_id_));
}

std::string LoginReputationClientRequest_PasswordReuseEvent::GetTypeName() const {
  return "safe_browsing.LoginReputationClientRequest.PasswordReuseEvent";
}


// ===================================================================

class LoginReputationClientRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReputationClientRequest>()._impl_._has_bits_);
  static void set_has_page_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trigger_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent& password_reuse_event(const LoginReputationClientRequest* msg);
  static void set_has_password_reuse_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stored_verdict_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::ChromeUserPopulation& population(const LoginReputationClientRequest* msg);
  static void set_has_population(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clicked_through_interstitial(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent&
LoginReputationClientRequest::_Internal::password_reuse_event(const LoginReputationClientRequest* msg) {
  return *msg->_impl_.password_reuse_event_;
}
const ::safe_browsing::ChromeUserPopulation&
LoginReputationClientRequest::_Internal::population(const LoginReputationClientRequest* msg) {
  return *msg->_impl_.population_;
}
LoginReputationClientRequest::LoginReputationClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest)
}
LoginReputationClientRequest::LoginReputationClientRequest(const LoginReputationClientRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginReputationClientRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frames_){from._impl_.frames_}
    , decltype(_impl_.page_url_){}
    , decltype(_impl_.password_reuse_event_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.trigger_type_){}
    , decltype(_impl_.stored_verdict_cnt_){}
    , decltype(_impl_.clicked_through_interstitial_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.page_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_page_url()) {
    _this->_impl_.page_url_.Set(from._internal_page_url(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_password_reuse_event()) {
    _this->_impl_.password_reuse_event_ = new ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent(*from._impl_.password_reuse_event_);
  }
  if (from._internal_has_population()) {
    _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
  }
  ::memcpy(&_impl_.trigger_type_, &from._impl_.trigger_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clicked_through_interstitial_) -
    reinterpret_cast<char*>(&_impl_.trigger_type_)) + sizeof(_impl_.clicked_through_interstitial_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest)
}

inline void LoginReputationClientRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frames_){arena}
    , decltype(_impl_.page_url_){}
    , decltype(_impl_.password_reuse_event_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.trigger_type_){0}
    , decltype(_impl_.stored_verdict_cnt_){0}
    , decltype(_impl_.clicked_through_interstitial_){false}
  };
  _impl_.page_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest::~LoginReputationClientRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReputationClientRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.frames_.~RepeatedPtrField();
  _impl_.page_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.password_reuse_event_;
  if (this != internal_default_instance()) delete _impl_.population_;
}

void LoginReputationClientRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.frames_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.page_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.password_reuse_event_ != nullptr);
      _impl_.password_reuse_event_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.population_ != nullptr);
      _impl_.population_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.trigger_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clicked_through_interstitial_) -
        reinterpret_cast<char*>(&_impl_.trigger_type_)) + sizeof(_impl_.clicked_through_interstitial_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string page_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_page_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_TriggerType_IsValid(val))) {
            _internal_set_trigger_type(static_cast<::safe_browsing::LoginReputationClientRequest_TriggerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_frames(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_password_reuse_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 stored_verdict_cnt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_stored_verdict_cnt(&has_bits);
          _impl_.stored_verdict_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeUserPopulation population = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clicked_through_interstitial = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_clicked_through_interstitial(&has_bits);
          _impl_.clicked_through_interstitial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string page_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_page_url(), target);
  }

  // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_trigger_type(), target);
  }

  // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_frames_size()); i < n; i++) {
    const auto& repfield = this->_internal_frames(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::password_reuse_event(this),
        _Internal::password_reuse_event(this).GetCachedSize(), target, stream);
  }

  // optional int32 stored_verdict_cnt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_stored_verdict_cnt(), target);
  }

  // optional .safe_browsing.ChromeUserPopulation population = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::population(this),
        _Internal::population(this).GetCachedSize(), target, stream);
  }

  // optional bool clicked_through_interstitial = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_clicked_through_interstitial(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest)
  return target;
}

size_t LoginReputationClientRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
  total_size += 1UL * this->_internal_frames_size();
  for (const auto& msg : this->_impl_.frames_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string page_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_page_url());
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.password_reuse_event_);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.population_);
    }

    // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_trigger_type());
    }

    // optional int32 stored_verdict_cnt = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stored_verdict_cnt());
    }

    // optional bool clicked_through_interstitial = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginReputationClientRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest*>(
      &from));
}

void LoginReputationClientRequest::MergeFrom(const LoginReputationClientRequest& from) {
  LoginReputationClientRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.frames_.MergeFrom(from._impl_.frames_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_page_url(from._internal_page_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_password_reuse_event()->::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent::MergeFrom(
          from._internal_password_reuse_event());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(
          from._internal_population());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.trigger_type_ = from._impl_.trigger_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.stored_verdict_cnt_ = from._impl_.stored_verdict_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.clicked_through_interstitial_ = from._impl_.clicked_through_interstitial_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest::CopyFrom(const LoginReputationClientRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReputationClientRequest::IsInitialized() const {
  return true;
}

void LoginReputationClientRequest::InternalSwap(LoginReputationClientRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.frames_.InternalSwap(&other->_impl_.frames_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_url_, lhs_arena,
      &other->_impl_.page_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest, _impl_.clicked_through_interstitial_)
      + sizeof(LoginReputationClientRequest::_impl_.clicked_through_interstitial_)
      - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest, _impl_.password_reuse_event_)>(
          reinterpret_cast<char*>(&_impl_.password_reuse_event_),
          reinterpret_cast<char*>(&other->_impl_.password_reuse_event_));
}

std::string LoginReputationClientRequest::GetTypeName() const {
  return "safe_browsing.LoginReputationClientRequest";
}


// ===================================================================

class LoginReputationClientResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginReputationClientResponse>()._impl_._has_bits_);
  static void set_has_verdict_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cache_duration_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cache_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_deprecated_cache_expression_exact_match(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_verdict_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LoginReputationClientResponse::LoginReputationClientResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientResponse)
}
LoginReputationClientResponse::LoginReputationClientResponse(const LoginReputationClientResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginReputationClientResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cache_expression_){}
    , decltype(_impl_.verdict_token_){}
    , decltype(_impl_.cache_duration_sec_){}
    , decltype(_impl_.verdict_type_){}
    , decltype(_impl_.deprecated_cache_expression_exact_match_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.cache_expression_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cache_expression()) {
    _this->_impl_.cache_expression_.Set(from._internal_cache_expression(),
      _this->GetArenaForAllocation());
  }
  _impl_.verdict_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verdict_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verdict_token()) {
    _this->_impl_.verdict_token_.Set(from._internal_verdict_token(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cache_duration_sec_, &from._impl_.cache_duration_sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deprecated_cache_expression_exact_match_) -
    reinterpret_cast<char*>(&_impl_.cache_duration_sec_)) + sizeof(_impl_.deprecated_cache_expression_exact_match_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientResponse)
}

inline void LoginReputationClientResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cache_expression_){}
    , decltype(_impl_.verdict_token_){}
    , decltype(_impl_.cache_duration_sec_){int64_t{0}}
    , decltype(_impl_.verdict_type_){0}
    , decltype(_impl_.deprecated_cache_expression_exact_match_){false}
  };
  _impl_.cache_expression_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.verdict_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verdict_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientResponse::~LoginReputationClientResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginReputationClientResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cache_expression_.Destroy();
  _impl_.verdict_token_.Destroy();
}

void LoginReputationClientResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginReputationClientResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cache_expression_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.verdict_token_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.cache_duration_sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.deprecated_cache_expression_exact_match_) -
        reinterpret_cast<char*>(&_impl_.cache_duration_sec_)) + sizeof(_impl_.deprecated_cache_expression_exact_match_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientResponse_VerdictType_IsValid(val))) {
            _internal_set_verdict_type(static_cast<::safe_browsing::LoginReputationClientResponse_VerdictType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 cache_duration_sec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cache_duration_sec(&has_bits);
          _impl_.cache_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cache_expression = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_cache_expression();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_deprecated_cache_expression_exact_match(&has_bits);
          _impl_.deprecated_cache_expression_exact_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes verdict_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_verdict_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_verdict_type(), target);
  }

  // optional int64 cache_duration_sec = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_cache_duration_sec(), target);
  }

  // optional string cache_expression = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_cache_expression(), target);
  }

  // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_deprecated_cache_expression_exact_match(), target);
  }

  // optional bytes verdict_token = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_verdict_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientResponse)
  return target;
}

size_t LoginReputationClientResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string cache_expression = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cache_expression());
    }

    // optional bytes verdict_token = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_verdict_token());
    }

    // optional int64 cache_duration_sec = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_cache_duration_sec());
    }

    // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict_type());
    }

    // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginReputationClientResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginReputationClientResponse*>(
      &from));
}

void LoginReputationClientResponse::MergeFrom(const LoginReputationClientResponse& from) {
  LoginReputationClientResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cache_expression(from._internal_cache_expression());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_verdict_token(from._internal_verdict_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cache_duration_sec_ = from._impl_.cache_duration_sec_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.verdict_type_ = from._impl_.verdict_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.deprecated_cache_expression_exact_match_ = from._impl_.deprecated_cache_expression_exact_match_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientResponse::CopyFrom(const LoginReputationClientResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReputationClientResponse::IsInitialized() const {
  return true;
}

void LoginReputationClientResponse::InternalSwap(LoginReputationClientResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cache_expression_, lhs_arena,
      &other->_impl_.cache_expression_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verdict_token_, lhs_arena,
      &other->_impl_.verdict_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginReputationClientResponse, _impl_.deprecated_cache_expression_exact_match_)
      + sizeof(LoginReputationClientResponse::_impl_.deprecated_cache_expression_exact_match_)
      - PROTOBUF_FIELD_OFFSET(LoginReputationClientResponse, _impl_.cache_duration_sec_)>(
          reinterpret_cast<char*>(&_impl_.cache_duration_sec_),
          reinterpret_cast<char*>(&other->_impl_.cache_duration_sec_));
}

std::string LoginReputationClientResponse::GetTypeName() const {
  return "safe_browsing.LoginReputationClientResponse";
}


// ===================================================================

class ClientMalwareResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMalwareResponse>()._impl_._has_bits_);
  static void set_has_blacklist(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bad_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bad_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

ClientMalwareResponse::ClientMalwareResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientMalwareResponse)
}
ClientMalwareResponse::ClientMalwareResponse(const ClientMalwareResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientMalwareResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bad_ip_){}
    , decltype(_impl_.bad_url_){}
    , decltype(_impl_.blacklist_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.bad_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bad_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bad_ip()) {
    _this->_impl_.bad_ip_.Set(from._internal_bad_ip(),
      _this->GetArenaForAllocation());
  }
  _impl_.bad_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bad_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bad_url()) {
    _this->_impl_.bad_url_.Set(from._internal_bad_url(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.blacklist_ = from._impl_.blacklist_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientMalwareResponse)
}

inline void ClientMalwareResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bad_ip_){}
    , decltype(_impl_.bad_url_){}
    , decltype(_impl_.blacklist_){false}
  };
  _impl_.bad_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bad_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bad_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bad_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMalwareResponse::~ClientMalwareResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientMalwareResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMalwareResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bad_ip_.Destroy();
  _impl_.bad_url_.Destroy();
}

void ClientMalwareResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientMalwareResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientMalwareResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.bad_ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bad_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.blacklist_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMalwareResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool blacklist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_blacklist(&has_bits);
          _impl_.blacklist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bad_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bad_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bad_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bad_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMalwareResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientMalwareResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool blacklist = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_blacklist(), target);
  }

  // optional string bad_ip = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bad_ip(), target);
  }

  // optional string bad_url = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bad_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientMalwareResponse)
  return target;
}

size_t ClientMalwareResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientMalwareResponse)
  size_t total_size = 0;

  // required bool blacklist = 1;
  if (_internal_has_blacklist()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string bad_ip = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bad_ip());
    }

    // optional string bad_url = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bad_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMalwareResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMalwareResponse*>(
      &from));
}

void ClientMalwareResponse::MergeFrom(const ClientMalwareResponse& from) {
  ClientMalwareResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientMalwareResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_bad_ip(from._internal_bad_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bad_url(from._internal_bad_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blacklist_ = from._impl_.blacklist_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMalwareResponse::CopyFrom(const ClientMalwareResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientMalwareResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMalwareResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientMalwareResponse::InternalSwap(ClientMalwareResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bad_ip_, lhs_arena,
      &other->_impl_.bad_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bad_url_, lhs_arena,
      &other->_impl_.bad_url_, rhs_arena
  );
  swap(_impl_.blacklist_, other->_impl_.blacklist_);
}

std::string ClientMalwareResponse::GetTypeName() const {
  return "safe_browsing.ClientMalwareResponse";
}


// ===================================================================

class ClientDownloadRequest_Digests::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_Digests>()._impl_._has_bits_);
  static void set_has_sha256(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sha1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_md5(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.Digests)
}
ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(const ClientDownloadRequest_Digests& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_Digests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sha256_){}
    , decltype(_impl_.sha1_){}
    , decltype(_impl_.md5_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sha256()) {
    _this->_impl_.sha256_.Set(from._internal_sha256(),
      _this->GetArenaForAllocation());
  }
  _impl_.sha1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sha1()) {
    _this->_impl_.sha1_.Set(from._internal_sha1(),
      _this->GetArenaForAllocation());
  }
  _impl_.md5_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_md5()) {
    _this->_impl_.md5_.Set(from._internal_md5(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.Digests)
}

inline void ClientDownloadRequest_Digests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sha256_){}
    , decltype(_impl_.sha1_){}
    , decltype(_impl_.md5_){}
  };
  _impl_.sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sha1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.md5_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_Digests::~ClientDownloadRequest_Digests() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.Digests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_Digests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sha256_.Destroy();
  _impl_.sha1_.Destroy();
  _impl_.md5_.Destroy();
}

void ClientDownloadRequest_Digests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_Digests::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.Digests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sha256_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sha1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.md5_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_Digests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes sha256 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sha256();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes sha1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sha1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes md5 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_md5();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_Digests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.Digests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes sha256 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha256(), target);
  }

  // optional bytes sha1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sha1(), target);
  }

  // optional bytes md5 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_md5(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.Digests)
  return target;
}

size_t ClientDownloadRequest_Digests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.Digests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes sha256 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sha256());
    }

    // optional bytes sha1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sha1());
    }

    // optional bytes md5 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_md5());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_Digests::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_Digests*>(
      &from));
}

void ClientDownloadRequest_Digests::MergeFrom(const ClientDownloadRequest_Digests& from) {
  ClientDownloadRequest_Digests* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.Digests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sha256(from._internal_sha256());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sha1(from._internal_sha1());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_md5(from._internal_md5());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_Digests::CopyFrom(const ClientDownloadRequest_Digests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.Digests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_Digests::IsInitialized() const {
  return true;
}

void ClientDownloadRequest_Digests::InternalSwap(ClientDownloadRequest_Digests* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sha256_, lhs_arena,
      &other->_impl_.sha256_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sha1_, lhs_arena,
      &other->_impl_.sha1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.md5_, lhs_arena,
      &other->_impl_.md5_, rhs_arena
  );
}

std::string ClientDownloadRequest_Digests::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.Digests";
}


// ===================================================================

class ClientDownloadRequest_Resource::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_Resource>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.Resource)
}
ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(const ClientDownloadRequest_Resource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_Resource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_ip()) {
    _this->_impl_.remote_ip_.Set(from._internal_remote_ip(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer()) {
    _this->_impl_.referrer_.Set(from._internal_referrer(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.Resource)
}

inline void ClientDownloadRequest_Resource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_Resource::~ClientDownloadRequest_Resource() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.Resource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_Resource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.remote_ip_.Destroy();
  _impl_.referrer_.Destroy();
}

void ClientDownloadRequest_Resource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_Resource::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.Resource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.remote_ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.referrer_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_Resource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_ResourceType_IsValid(val))) {
            _internal_set_type(static_cast<::safe_browsing::ClientDownloadRequest_ResourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes remote_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_remote_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_Resource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.Resource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional bytes remote_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_remote_ip(), target);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.Resource)
  return target;
}

size_t ClientDownloadRequest_Resource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest.Resource)
  size_t total_size = 0;

  if (_internal_has_url()) {
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (_internal_has_type()) {
    // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t ClientDownloadRequest_Resource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.Resource)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());

    // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bytes remote_ip = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_remote_ip());
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_Resource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_Resource*>(
      &from));
}

void ClientDownloadRequest_Resource::MergeFrom(const ClientDownloadRequest_Resource& from) {
  ClientDownloadRequest_Resource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.Resource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_remote_ip(from._internal_remote_ip());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_referrer(from._internal_referrer());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_Resource::CopyFrom(const ClientDownloadRequest_Resource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_Resource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientDownloadRequest_Resource::InternalSwap(ClientDownloadRequest_Resource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_ip_, lhs_arena,
      &other->_impl_.remote_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_, lhs_arena,
      &other->_impl_.referrer_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientDownloadRequest_Resource::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.Resource";
}


// ===================================================================

class ClientDownloadRequest_CertificateChain_Element::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_CertificateChain_Element>()._impl_._has_bits_);
  static void set_has_certificate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
}
ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(const ClientDownloadRequest_CertificateChain_Element& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_CertificateChain_Element* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_certificate()) {
    _this->_impl_.certificate_.Set(from._internal_certificate(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
}

inline void ClientDownloadRequest_CertificateChain_Element::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_){}
  };
  _impl_.certificate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_CertificateChain_Element::~ClientDownloadRequest_CertificateChain_Element() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_CertificateChain_Element::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.certificate_.Destroy();
}

void ClientDownloadRequest_CertificateChain_Element::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_CertificateChain_Element::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.certificate_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_CertificateChain_Element::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_certificate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_CertificateChain_Element::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes certificate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_certificate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  return target;
}

size_t ClientDownloadRequest_CertificateChain_Element::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes certificate = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_certificate());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_CertificateChain_Element::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_CertificateChain_Element*>(
      &from));
}

void ClientDownloadRequest_CertificateChain_Element::MergeFrom(const ClientDownloadRequest_CertificateChain_Element& from) {
  ClientDownloadRequest_CertificateChain_Element* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_certificate()) {
    _this->_internal_set_certificate(from._internal_certificate());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_CertificateChain_Element::CopyFrom(const ClientDownloadRequest_CertificateChain_Element& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_CertificateChain_Element::IsInitialized() const {
  return true;
}

void ClientDownloadRequest_CertificateChain_Element::InternalSwap(ClientDownloadRequest_CertificateChain_Element* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.certificate_, lhs_arena,
      &other->_impl_.certificate_, rhs_arena
  );
}

std::string ClientDownloadRequest_CertificateChain_Element::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.CertificateChain.Element";
}


// ===================================================================

class ClientDownloadRequest_CertificateChain::_Internal {
 public:
};

ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.CertificateChain)
}
ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(const ClientDownloadRequest_CertificateChain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_CertificateChain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.element_){from._impl_.element_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.CertificateChain)
}

inline void ClientDownloadRequest_CertificateChain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.element_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ClientDownloadRequest_CertificateChain::~ClientDownloadRequest_CertificateChain() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.CertificateChain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_CertificateChain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.element_.~RepeatedPtrField();
}

void ClientDownloadRequest_CertificateChain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_CertificateChain::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.CertificateChain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.element_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_CertificateChain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_element(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_CertificateChain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.CertificateChain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_element_size()); i < n; i++) {
    const auto& repfield = this->_internal_element(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.CertificateChain)
  return target;
}

size_t ClientDownloadRequest_CertificateChain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.CertificateChain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
  total_size += 1UL * this->_internal_element_size();
  for (const auto& msg : this->_impl_.element_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_CertificateChain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_CertificateChain*>(
      &from));
}

void ClientDownloadRequest_CertificateChain::MergeFrom(const ClientDownloadRequest_CertificateChain& from) {
  ClientDownloadRequest_CertificateChain* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.CertificateChain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.element_.MergeFrom(from._impl_.element_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_CertificateChain::CopyFrom(const ClientDownloadRequest_CertificateChain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.CertificateChain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_CertificateChain::IsInitialized() const {
  return true;
}

void ClientDownloadRequest_CertificateChain::InternalSwap(ClientDownloadRequest_CertificateChain* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.element_.InternalSwap(&other->_impl_.element_);
}

std::string ClientDownloadRequest_CertificateChain::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.CertificateChain";
}


// ===================================================================

class ClientDownloadRequest_ExtendedAttr::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_ExtendedAttr>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
}
ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(const ClientDownloadRequest_ExtendedAttr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_ExtendedAttr* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(),
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
}

inline void ClientDownloadRequest_ExtendedAttr::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_ExtendedAttr::~ClientDownloadRequest_ExtendedAttr() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_ExtendedAttr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void ClientDownloadRequest_ExtendedAttr::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ExtendedAttr::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ExtendedAttr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ExtendedAttr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  return target;
}

size_t ClientDownloadRequest_ExtendedAttr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  size_t total_size = 0;

  // required string key = 1;
  if (_internal_has_key()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes value = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_ExtendedAttr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ExtendedAttr*>(
      &from));
}

void ClientDownloadRequest_ExtendedAttr::MergeFrom(const ClientDownloadRequest_ExtendedAttr& from) {
  ClientDownloadRequest_ExtendedAttr* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ExtendedAttr::CopyFrom(const ClientDownloadRequest_ExtendedAttr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_ExtendedAttr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientDownloadRequest_ExtendedAttr::InternalSwap(ClientDownloadRequest_ExtendedAttr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string ClientDownloadRequest_ExtendedAttr::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.ExtendedAttr";
}


// ===================================================================

class ClientDownloadRequest_SignatureInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_SignatureInfo>()._impl_._has_bits_);
  static void set_has_trusted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
}
ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(const ClientDownloadRequest_SignatureInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_SignatureInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_chain_){from._impl_.certificate_chain_}
    , decltype(_impl_.signed_data_){from._impl_.signed_data_}
    , decltype(_impl_.xattr_){from._impl_.xattr_}
    , decltype(_impl_.trusted_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.trusted_ = from._impl_.trusted_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
}

inline void ClientDownloadRequest_SignatureInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.certificate_chain_){arena}
    , decltype(_impl_.signed_data_){arena}
    , decltype(_impl_.xattr_){arena}
    , decltype(_impl_.trusted_){false}
  };
}

ClientDownloadRequest_SignatureInfo::~ClientDownloadRequest_SignatureInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_SignatureInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.certificate_chain_.~RepeatedPtrField();
  _impl_.signed_data_.~RepeatedPtrField();
  _impl_.xattr_.~RepeatedPtrField();
}

void ClientDownloadRequest_SignatureInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_SignatureInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.certificate_chain_.Clear();
  _impl_.signed_data_.Clear();
  _impl_.xattr_.Clear();
  _impl_.trusted_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_SignatureInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_certificate_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool trusted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_trusted(&has_bits);
          _impl_.trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes signed_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_signed_data();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_xattr(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_SignatureInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_certificate_chain_size()); i < n; i++) {
    const auto& repfield = this->_internal_certificate_chain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool trusted = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_trusted(), target);
  }

  // repeated bytes signed_data = 3;
  for (int i = 0, n = this->_internal_signed_data_size(); i < n; i++) {
    const auto& s = this->_internal_signed_data(i);
    target = stream->WriteBytes(3, s, target);
  }

  // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_xattr_size()); i < n; i++) {
    const auto& repfield = this->_internal_xattr(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.SignatureInfo)
  return target;
}

size_t ClientDownloadRequest_SignatureInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
  total_size += 1UL * this->_internal_certificate_chain_size();
  for (const auto& msg : this->_impl_.certificate_chain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes signed_data = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signed_data_.size());
  for (int i = 0, n = _impl_.signed_data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.signed_data_.Get(i));
  }

  // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
  total_size += 1UL * this->_internal_xattr_size();
  for (const auto& msg : this->_impl_.xattr_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool trusted = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_SignatureInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_SignatureInfo*>(
      &from));
}

void ClientDownloadRequest_SignatureInfo::MergeFrom(const ClientDownloadRequest_SignatureInfo& from) {
  ClientDownloadRequest_SignatureInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.certificate_chain_.MergeFrom(from._impl_.certificate_chain_);
  _this->_impl_.signed_data_.MergeFrom(from._impl_.signed_data_);
  _this->_impl_.xattr_.MergeFrom(from._impl_.xattr_);
  if (from._internal_has_trusted()) {
    _this->_internal_set_trusted(from._internal_trusted());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_SignatureInfo::CopyFrom(const ClientDownloadRequest_SignatureInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_SignatureInfo::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.xattr_))
    return false;
  return true;
}

void ClientDownloadRequest_SignatureInfo::InternalSwap(ClientDownloadRequest_SignatureInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.certificate_chain_.InternalSwap(&other->_impl_.certificate_chain_);
  _impl_.signed_data_.InternalSwap(&other->_impl_.signed_data_);
  _impl_.xattr_.InternalSwap(&other->_impl_.xattr_);
  swap(_impl_.trusted_, other->_impl_.trusted_);
}

std::string ClientDownloadRequest_SignatureInfo::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.SignatureInfo";
}


// ===================================================================

class ClientDownloadRequest_PEImageHeaders_DebugData::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_PEImageHeaders_DebugData>()._impl_._has_bits_);
  static void set_has_directory_entry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_raw_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
}
ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(const ClientDownloadRequest_PEImageHeaders_DebugData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_PEImageHeaders_DebugData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.directory_entry_){}
    , decltype(_impl_.raw_data_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.directory_entry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_entry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_directory_entry()) {
    _this->_impl_.directory_entry_.Set(from._internal_directory_entry(),
      _this->GetArenaForAllocation());
  }
  _impl_.raw_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_data()) {
    _this->_impl_.raw_data_.Set(from._internal_raw_data(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
}

inline void ClientDownloadRequest_PEImageHeaders_DebugData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.directory_entry_){}
    , decltype(_impl_.raw_data_){}
  };
  _impl_.directory_entry_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_entry_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_PEImageHeaders_DebugData::~ClientDownloadRequest_PEImageHeaders_DebugData() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_PEImageHeaders_DebugData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.directory_entry_.Destroy();
  _impl_.raw_data_.Destroy();
}

void ClientDownloadRequest_PEImageHeaders_DebugData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_PEImageHeaders_DebugData::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.directory_entry_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.raw_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_PEImageHeaders_DebugData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes directory_entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_directory_entry();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_raw_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_PEImageHeaders_DebugData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes directory_entry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_directory_entry(), target);
  }

  // optional bytes raw_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  return target;
}

size_t ClientDownloadRequest_PEImageHeaders_DebugData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes directory_entry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_directory_entry());
    }

    // optional bytes raw_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_PEImageHeaders_DebugData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_PEImageHeaders_DebugData*>(
      &from));
}

void ClientDownloadRequest_PEImageHeaders_DebugData::MergeFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from) {
  ClientDownloadRequest_PEImageHeaders_DebugData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_directory_entry(from._internal_directory_entry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_raw_data(from._internal_raw_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_PEImageHeaders_DebugData::CopyFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_PEImageHeaders_DebugData::IsInitialized() const {
  return true;
}

void ClientDownloadRequest_PEImageHeaders_DebugData::InternalSwap(ClientDownloadRequest_PEImageHeaders_DebugData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.directory_entry_, lhs_arena,
      &other->_impl_.directory_entry_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.raw_data_, lhs_arena,
      &other->_impl_.raw_data_, rhs_arena
  );
}

std::string ClientDownloadRequest_PEImageHeaders_DebugData::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData";
}


// ===================================================================

class ClientDownloadRequest_PEImageHeaders::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_PEImageHeaders>()._impl_._has_bits_);
  static void set_has_dos_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_header(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optional_headers32(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_optional_headers64(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_export_section_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
}
ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(const ClientDownloadRequest_PEImageHeaders& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_PEImageHeaders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.section_header_){from._impl_.section_header_}
    , decltype(_impl_.debug_data_){from._impl_.debug_data_}
    , decltype(_impl_.dos_header_){}
    , decltype(_impl_.file_header_){}
    , decltype(_impl_.optional_headers32_){}
    , decltype(_impl_.optional_headers64_){}
    , decltype(_impl_.export_section_data_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.dos_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dos_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dos_header()) {
    _this->_impl_.dos_header_.Set(from._internal_dos_header(),
      _this->GetArenaForAllocation());
  }
  _impl_.file_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_header()) {
    _this->_impl_.file_header_.Set(from._internal_file_header(),
      _this->GetArenaForAllocation());
  }
  _impl_.optional_headers32_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers32_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_optional_headers32()) {
    _this->_impl_.optional_headers32_.Set(from._internal_optional_headers32(),
      _this->GetArenaForAllocation());
  }
  _impl_.optional_headers64_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers64_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_optional_headers64()) {
    _this->_impl_.optional_headers64_.Set(from._internal_optional_headers64(),
      _this->GetArenaForAllocation());
  }
  _impl_.export_section_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_section_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_export_section_data()) {
    _this->_impl_.export_section_data_.Set(from._internal_export_section_data(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
}

inline void ClientDownloadRequest_PEImageHeaders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.section_header_){arena}
    , decltype(_impl_.debug_data_){arena}
    , decltype(_impl_.dos_header_){}
    , decltype(_impl_.file_header_){}
    , decltype(_impl_.optional_headers32_){}
    , decltype(_impl_.optional_headers64_){}
    , decltype(_impl_.export_section_data_){}
  };
  _impl_.dos_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dos_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.optional_headers32_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers32_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.optional_headers64_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers64_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.export_section_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_section_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_PEImageHeaders::~ClientDownloadRequest_PEImageHeaders() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_PEImageHeaders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.section_header_.~RepeatedPtrField();
  _impl_.debug_data_.~RepeatedPtrField();
  _impl_.dos_header_.Destroy();
  _impl_.file_header_.Destroy();
  _impl_.optional_headers32_.Destroy();
  _impl_.optional_headers64_.Destroy();
  _impl_.export_section_data_.Destroy();
}

void ClientDownloadRequest_PEImageHeaders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_PEImageHeaders::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.section_header_.Clear();
  _impl_.debug_data_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.dos_header_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_header_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.optional_headers32_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.optional_headers64_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.export_section_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_PEImageHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes dos_header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dos_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes file_header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes optional_headers32 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_optional_headers32();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes optional_headers64 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_optional_headers64();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes section_header = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_section_header();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes export_section_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_export_section_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_debug_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_PEImageHeaders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes dos_header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_dos_header(), target);
  }

  // optional bytes file_header = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_file_header(), target);
  }

  // optional bytes optional_headers32 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_optional_headers32(), target);
  }

  // optional bytes optional_headers64 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_optional_headers64(), target);
  }

  // repeated bytes section_header = 5;
  for (int i = 0, n = this->_internal_section_header_size(); i < n; i++) {
    const auto& s = this->_internal_section_header(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional bytes export_section_data = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_export_section_data(), target);
  }

  // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_debug_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_debug_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  return target;
}

size_t ClientDownloadRequest_PEImageHeaders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes section_header = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.section_header_.size());
  for (int i = 0, n = _impl_.section_header_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.section_header_.Get(i));
  }

  // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
  total_size += 1UL * this->_internal_debug_data_size();
  for (const auto& msg : this->_impl_.debug_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes dos_header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dos_header());
    }

    // optional bytes file_header = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_file_header());
    }

    // optional bytes optional_headers32 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_optional_headers32());
    }

    // optional bytes optional_headers64 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_optional_headers64());
    }

    // optional bytes export_section_data = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_export_section_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_PEImageHeaders::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_PEImageHeaders*>(
      &from));
}

void ClientDownloadRequest_PEImageHeaders::MergeFrom(const ClientDownloadRequest_PEImageHeaders& from) {
  ClientDownloadRequest_PEImageHeaders* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.section_header_.MergeFrom(from._impl_.section_header_);
  _this->_impl_.debug_data_.MergeFrom(from._impl_.debug_data_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dos_header(from._internal_dos_header());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file_header(from._internal_file_header());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_optional_headers32(from._internal_optional_headers32());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_optional_headers64(from._internal_optional_headers64());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_export_section_data(from._internal_export_section_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_PEImageHeaders::CopyFrom(const ClientDownloadRequest_PEImageHeaders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_PEImageHeaders::IsInitialized() const {
  return true;
}

void ClientDownloadRequest_PEImageHeaders::InternalSwap(ClientDownloadRequest_PEImageHeaders* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.section_header_.InternalSwap(&other->_impl_.section_header_);
  _impl_.debug_data_.InternalSwap(&other->_impl_.debug_data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dos_header_, lhs_arena,
      &other->_impl_.dos_header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_header_, lhs_arena,
      &other->_impl_.file_header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.optional_headers32_, lhs_arena,
      &other->_impl_.optional_headers32_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.optional_headers64_, lhs_arena,
      &other->_impl_.optional_headers64_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.export_section_data_, lhs_arena,
      &other->_impl_.export_section_data_, rhs_arena
  );
}

std::string ClientDownloadRequest_PEImageHeaders::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.PEImageHeaders";
}


// ===================================================================

class ClientDownloadRequest_MachOHeaders_LoadCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_MachOHeaders_LoadCommand>()._impl_._has_bits_);
  static void set_has_command_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
}
ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(const ClientDownloadRequest_MachOHeaders_LoadCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_MachOHeaders_LoadCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){}
    , decltype(_impl_.command_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_command()) {
    _this->_impl_.command_.Set(from._internal_command(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.command_id_ = from._impl_.command_id_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
}

inline void ClientDownloadRequest_MachOHeaders_LoadCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){}
    , decltype(_impl_.command_id_){0u}
  };
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_MachOHeaders_LoadCommand::~ClientDownloadRequest_MachOHeaders_LoadCommand() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_MachOHeaders_LoadCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.Destroy();
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.command_.ClearNonDefaultToEmpty();
  }
  _impl_.command_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_MachOHeaders_LoadCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 command_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_command_id(&has_bits);
          _impl_.command_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_command();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_MachOHeaders_LoadCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 command_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_command_id(), target);
  }

  // required bytes command = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  return target;
}

size_t ClientDownloadRequest_MachOHeaders_LoadCommand::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  size_t total_size = 0;

  if (_internal_has_command()) {
    // required bytes command = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_command());
  }

  if (_internal_has_command_id()) {
    // required uint32 command_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_id());
  }

  return total_size;
}
size_t ClientDownloadRequest_MachOHeaders_LoadCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes command = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_command());

    // required uint32 command_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_MachOHeaders_LoadCommand*>(
      &from));
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::MergeFrom(const ClientDownloadRequest_MachOHeaders_LoadCommand& from) {
  ClientDownloadRequest_MachOHeaders_LoadCommand* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_command(from._internal_command());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.command_id_ = from._impl_.command_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::CopyFrom(const ClientDownloadRequest_MachOHeaders_LoadCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_MachOHeaders_LoadCommand::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::InternalSwap(ClientDownloadRequest_MachOHeaders_LoadCommand* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_, lhs_arena,
      &other->_impl_.command_, rhs_arena
  );
  swap(_impl_.command_id_, other->_impl_.command_id_);
}

std::string ClientDownloadRequest_MachOHeaders_LoadCommand::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand";
}


// ===================================================================

class ClientDownloadRequest_MachOHeaders::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_MachOHeaders>()._impl_._has_bits_);
  static void set_has_mach_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
}
ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(const ClientDownloadRequest_MachOHeaders& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_MachOHeaders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.load_commands_){from._impl_.load_commands_}
    , decltype(_impl_.mach_header_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.mach_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mach_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mach_header()) {
    _this->_impl_.mach_header_.Set(from._internal_mach_header(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
}

inline void ClientDownloadRequest_MachOHeaders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.load_commands_){arena}
    , decltype(_impl_.mach_header_){}
  };
  _impl_.mach_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mach_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_MachOHeaders::~ClientDownloadRequest_MachOHeaders() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_MachOHeaders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.load_commands_.~RepeatedPtrField();
  _impl_.mach_header_.Destroy();
}

void ClientDownloadRequest_MachOHeaders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_MachOHeaders::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.load_commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.mach_header_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_MachOHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes mach_header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mach_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_load_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_MachOHeaders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes mach_header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_mach_header(), target);
  }

  // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_load_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_load_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.MachOHeaders)
  return target;
}

size_t ClientDownloadRequest_MachOHeaders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
  size_t total_size = 0;

  // required bytes mach_header = 1;
  if (_internal_has_mach_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mach_header());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
  total_size += 1UL * this->_internal_load_commands_size();
  for (const auto& msg : this->_impl_.load_commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_MachOHeaders::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_MachOHeaders*>(
      &from));
}

void ClientDownloadRequest_MachOHeaders::MergeFrom(const ClientDownloadRequest_MachOHeaders& from) {
  ClientDownloadRequest_MachOHeaders* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.load_commands_.MergeFrom(from._impl_.load_commands_);
  if (from._internal_has_mach_header()) {
    _this->_internal_set_mach_header(from._internal_mach_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_MachOHeaders::CopyFrom(const ClientDownloadRequest_MachOHeaders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_MachOHeaders::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.load_commands_))
    return false;
  return true;
}

void ClientDownloadRequest_MachOHeaders::InternalSwap(ClientDownloadRequest_MachOHeaders* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.load_commands_.InternalSwap(&other->_impl_.load_commands_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mach_header_, lhs_arena,
      &other->_impl_.mach_header_, rhs_arena
  );
}

std::string ClientDownloadRequest_MachOHeaders::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.MachOHeaders";
}


// ===================================================================

class ClientDownloadRequest_ImageHeaders::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_ImageHeaders>()._impl_._has_bits_);
  static const ::safe_browsing::ClientDownloadRequest_PEImageHeaders& pe_headers(const ClientDownloadRequest_ImageHeaders* msg);
  static void set_has_pe_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::ClientDownloadRequest_PEImageHeaders&
ClientDownloadRequest_ImageHeaders::_Internal::pe_headers(const ClientDownloadRequest_ImageHeaders* msg) {
  return *msg->_impl_.pe_headers_;
}
ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
}
ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(const ClientDownloadRequest_ImageHeaders& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_ImageHeaders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mach_o_headers_){from._impl_.mach_o_headers_}
    , decltype(_impl_.pe_headers_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_pe_headers()) {
    _this->_impl_.pe_headers_ = new ::safe_browsing::ClientDownloadRequest_PEImageHeaders(*from._impl_.pe_headers_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
}

inline void ClientDownloadRequest_ImageHeaders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mach_o_headers_){arena}
    , decltype(_impl_.pe_headers_){nullptr}
  };
}

ClientDownloadRequest_ImageHeaders::~ClientDownloadRequest_ImageHeaders() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_ImageHeaders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mach_o_headers_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.pe_headers_;
}

void ClientDownloadRequest_ImageHeaders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ImageHeaders::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mach_o_headers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pe_headers_ != nullptr);
    _impl_.pe_headers_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ImageHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pe_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mach_o_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ImageHeaders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pe_headers(this),
        _Internal::pe_headers(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mach_o_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_mach_o_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ImageHeaders)
  return target;
}

size_t ClientDownloadRequest_ImageHeaders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
  total_size += 1UL * this->_internal_mach_o_headers_size();
  for (const auto& msg : this->_impl_.mach_o_headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pe_headers_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_ImageHeaders::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ImageHeaders*>(
      &from));
}

void ClientDownloadRequest_ImageHeaders::MergeFrom(const ClientDownloadRequest_ImageHeaders& from) {
  ClientDownloadRequest_ImageHeaders* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mach_o_headers_.MergeFrom(from._impl_.mach_o_headers_);
  if (from._internal_has_pe_headers()) {
    _this->_internal_mutable_pe_headers()->::safe_browsing::ClientDownloadRequest_PEImageHeaders::MergeFrom(
        from._internal_pe_headers());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ImageHeaders::CopyFrom(const ClientDownloadRequest_ImageHeaders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_ImageHeaders::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.mach_o_headers_))
    return false;
  return true;
}

void ClientDownloadRequest_ImageHeaders::InternalSwap(ClientDownloadRequest_ImageHeaders* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mach_o_headers_.InternalSwap(&other->_impl_.mach_o_headers_);
  swap(_impl_.pe_headers_, other->_impl_.pe_headers_);
}

std::string ClientDownloadRequest_ImageHeaders::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.ImageHeaders";
}


// ===================================================================

class ClientDownloadRequest_ArchivedBinary::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest_ArchivedBinary>()._impl_._has_bits_);
  static void set_has_file_basename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_download_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::safe_browsing::ClientDownloadRequest_Digests& digests(const ClientDownloadRequest_ArchivedBinary* msg);
  static void set_has_digests(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientDownloadRequest_ArchivedBinary* msg);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientDownloadRequest_ArchivedBinary* msg);
  static void set_has_image_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientDownloadRequest_Digests&
ClientDownloadRequest_ArchivedBinary::_Internal::digests(const ClientDownloadRequest_ArchivedBinary* msg) {
  return *msg->_impl_.digests_;
}
const ::safe_browsing::ClientDownloadRequest_SignatureInfo&
ClientDownloadRequest_ArchivedBinary::_Internal::signature(const ClientDownloadRequest_ArchivedBinary* msg) {
  return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders&
ClientDownloadRequest_ArchivedBinary::_Internal::image_headers(const ClientDownloadRequest_ArchivedBinary* msg) {
  return *msg->_impl_.image_headers_;
}
ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
}
ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(const ClientDownloadRequest_ArchivedBinary& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest_ArchivedBinary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.digests_){nullptr}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.length_){}
    , decltype(_impl_.download_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_basename()) {
    _this->_impl_.file_basename_.Set(from._internal_file_basename(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_digests()) {
    _this->_impl_.digests_ = new ::safe_browsing::ClientDownloadRequest_Digests(*from._impl_.digests_);
  }
  if (from._internal_has_signature()) {
    _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
  }
  if (from._internal_has_image_headers()) {
    _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
  }
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.download_type_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.download_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
}

inline void ClientDownloadRequest_ArchivedBinary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.digests_){nullptr}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.length_){int64_t{0}}
    , decltype(_impl_.download_type_){0}
  };
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_ArchivedBinary::~ClientDownloadRequest_ArchivedBinary() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest_ArchivedBinary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.file_basename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.digests_;
  if (this != internal_default_instance()) delete _impl_.signature_;
  if (this != internal_default_instance()) delete _impl_.image_headers_;
}

void ClientDownloadRequest_ArchivedBinary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ArchivedBinary::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.file_basename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.digests_ != nullptr);
      _impl_.digests_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.signature_ != nullptr);
      _impl_.signature_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
      _impl_.image_headers_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.download_type_) -
        reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.download_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ArchivedBinary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string file_basename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_file_basename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(val))) {
            _internal_set_download_type(static_cast<::safe_browsing::ClientDownloadRequest_DownloadType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_digests(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ArchivedBinary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string file_basename = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file_basename(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_download_type(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::digests(this),
        _Internal::digests(this).GetCachedSize(), target, stream);
  }

  // optional int64 length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::signature(this),
        _Internal::signature(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::image_headers(this),
        _Internal::image_headers(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  return target;
}

size_t ClientDownloadRequest_ArchivedBinary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string file_basename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_basename());
    }

    // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.digests_);
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_headers_);
    }

    // optional int64 length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
    }

    // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_download_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest_ArchivedBinary::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ArchivedBinary*>(
      &from));
}

void ClientDownloadRequest_ArchivedBinary::MergeFrom(const ClientDownloadRequest_ArchivedBinary& from) {
  ClientDownloadRequest_ArchivedBinary* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_file_basename(from._internal_file_basename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_digests()->::safe_browsing::ClientDownloadRequest_Digests::MergeFrom(
          from._internal_digests());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(
          from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(
          from._internal_image_headers());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.download_type_ = from._impl_.download_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ArchivedBinary::CopyFrom(const ClientDownloadRequest_ArchivedBinary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest_ArchivedBinary::IsInitialized() const {
  if (_internal_has_signature()) {
    if (!_impl_.signature_->IsInitialized()) return false;
  }
  if (_internal_has_image_headers()) {
    if (!_impl_.image_headers_->IsInitialized()) return false;
  }
  return true;
}

void ClientDownloadRequest_ArchivedBinary::InternalSwap(ClientDownloadRequest_ArchivedBinary* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_basename_, lhs_arena,
      &other->_impl_.file_basename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchivedBinary, _impl_.download_type_)
      + sizeof(ClientDownloadRequest_ArchivedBinary::_impl_.download_type_)
      - PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchivedBinary, _impl_.digests_)>(
          reinterpret_cast<char*>(&_impl_.digests_),
          reinterpret_cast<char*>(&other->_impl_.digests_));
}

std::string ClientDownloadRequest_ArchivedBinary::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest.ArchivedBinary";
}


// ===================================================================

class ClientDownloadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadRequest>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientDownloadRequest_Digests& digests(const ClientDownloadRequest* msg);
  static void set_has_digests(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientDownloadRequest* msg);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_user_initiated(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_file_basename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_download_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientDownloadRequest* msg);
  static void set_has_image_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::safe_browsing::ChromeUserPopulation& population(const ClientDownloadRequest* msg);
  static void set_has_population(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_archive_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_skipped_url_whitelist(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_skipped_certificate_whitelist(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_deprecated_download_attribution_finch_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_udif_code_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000111) ^ 0x00000111) != 0;
  }
};

const ::safe_browsing::ClientDownloadRequest_Digests&
ClientDownloadRequest::_Internal::digests(const ClientDownloadRequest* msg) {
  return *msg->_impl_.digests_;
}
const ::safe_browsing::ClientDownloadRequest_SignatureInfo&
ClientDownloadRequest::_Internal::signature(const ClientDownloadRequest* msg) {
  return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders&
ClientDownloadRequest::_Internal::image_headers(const ClientDownloadRequest* msg) {
  return *msg->_impl_.image_headers_;
}
const ::safe_browsing::ChromeUserPopulation&
ClientDownloadRequest::_Internal::population(const ClientDownloadRequest* msg) {
  return *msg->_impl_.population_;
}
ClientDownloadRequest::ClientDownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest)
}
ClientDownloadRequest::ClientDownloadRequest(const ClientDownloadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){from._impl_.resources_}
    , decltype(_impl_.archived_binary_){from._impl_.archived_binary_}
    , decltype(_impl_.alternate_extensions_){from._impl_.alternate_extensions_}
    , decltype(_impl_.referrer_chain_){from._impl_.referrer_chain_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.locale_){}
    , decltype(_impl_.udif_code_signature_){}
    , decltype(_impl_.digests_){nullptr}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.length_){}
    , decltype(_impl_.download_type_){}
    , decltype(_impl_.user_initiated_){}
    , decltype(_impl_.archive_valid_){}
    , decltype(_impl_.skipped_url_whitelist_){}
    , decltype(_impl_.skipped_certificate_whitelist_){}
    , decltype(_impl_.deprecated_download_attribution_finch_enabled_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_basename()) {
    _this->_impl_.file_basename_.Set(from._internal_file_basename(),
      _this->GetArenaForAllocation());
  }
  _impl_.locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    _this->_impl_.locale_.Set(from._internal_locale(),
      _this->GetArenaForAllocation());
  }
  _impl_.udif_code_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.udif_code_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_udif_code_signature()) {
    _this->_impl_.udif_code_signature_.Set(from._internal_udif_code_signature(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_digests()) {
    _this->_impl_.digests_ = new ::safe_browsing::ClientDownloadRequest_Digests(*from._impl_.digests_);
  }
  if (from._internal_has_signature()) {
    _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
  }
  if (from._internal_has_image_headers()) {
    _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
  }
  if (from._internal_has_population()) {
    _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
  }
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deprecated_download_attribution_finch_enabled_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.deprecated_download_attribution_finch_enabled_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest)
}

inline void ClientDownloadRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){arena}
    , decltype(_impl_.archived_binary_){arena}
    , decltype(_impl_.alternate_extensions_){arena}
    , decltype(_impl_.referrer_chain_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.locale_){}
    , decltype(_impl_.udif_code_signature_){}
    , decltype(_impl_.digests_){nullptr}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.length_){int64_t{0}}
    , decltype(_impl_.download_type_){0}
    , decltype(_impl_.user_initiated_){false}
    , decltype(_impl_.archive_valid_){false}
    , decltype(_impl_.skipped_url_whitelist_){false}
    , decltype(_impl_.skipped_certificate_whitelist_){false}
    , decltype(_impl_.deprecated_download_attribution_finch_enabled_){false}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.udif_code_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.udif_code_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest::~ClientDownloadRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resources_.~RepeatedPtrField();
  _impl_.archived_binary_.~RepeatedPtrField();
  _impl_.alternate_extensions_.~RepeatedPtrField();
  _impl_.referrer_chain_.~RepeatedPtrField();
  _impl_.url_.Destroy();
  _impl_.file_basename_.Destroy();
  _impl_.locale_.Destroy();
  _impl_.udif_code_signature_.Destroy();
  if (this != internal_default_instance()) delete _impl_.digests_;
  if (this != internal_default_instance()) delete _impl_.signature_;
  if (this != internal_default_instance()) delete _impl_.image_headers_;
  if (this != internal_default_instance()) delete _impl_.population_;
}

void ClientDownloadRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resources_.Clear();
  _impl_.archived_binary_.Clear();
  _impl_.alternate_extensions_.Clear();
  _impl_.referrer_chain_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_basename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.udif_code_signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.digests_ != nullptr);
      _impl_.digests_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.signature_ != nullptr);
      _impl_.signature_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
      _impl_.image_headers_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.population_ != nullptr);
      _impl_.population_->Clear();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.deprecated_download_attribution_finch_enabled_) -
        reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.deprecated_download_attribution_finch_enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_digests(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_initiated = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_user_initiated(&has_bits);
          _impl_.user_initiated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string file_basename = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_file_basename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(val))) {
            _internal_set_download_type(static_cast<::safe_browsing::ClientDownloadRequest_DownloadType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_archived_binary(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeUserPopulation population = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool archive_valid = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_archive_valid(&has_bits);
          _impl_.archive_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skipped_url_whitelist = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_skipped_url_whitelist(&has_bits);
          _impl_.skipped_url_whitelist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skipped_certificate_whitelist = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_skipped_certificate_whitelist(&has_bits);
          _impl_.skipped_certificate_whitelist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string alternate_extensions = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_alternate_extensions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<282>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<290>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_deprecated_download_attribution_finch_enabled(&has_bits);
          _impl_.deprecated_download_attribution_finch_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes udif_code_signature = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_udif_code_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::digests(this),
        _Internal::digests(this).GetCachedSize(), target, stream);
  }

  // required int64 length = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_length(), target);
  }

  // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
    const auto& repfield = this->_internal_resources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::signature(this),
        _Internal::signature(this).GetCachedSize(), target, stream);
  }

  // optional bool user_initiated = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_user_initiated(), target);
  }

  // optional string file_basename = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_file_basename(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_download_type(), target);
  }

  // optional string locale = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_locale(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::image_headers(this),
        _Internal::image_headers(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_archived_binary_size()); i < n; i++) {
    const auto& repfield = this->_internal_archived_binary(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ChromeUserPopulation population = 24;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::population(this),
        _Internal::population(this).GetCachedSize(), target, stream);
  }

  // optional bool archive_valid = 26;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_archive_valid(), target);
  }

  // optional bool skipped_url_whitelist = 28;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_skipped_url_whitelist(), target);
  }

  // optional bool skipped_certificate_whitelist = 31;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_skipped_certificate_whitelist(), target);
  }

  // repeated string alternate_extensions = 35;
  for (int i = 0, n = this->_internal_alternate_extensions_size(); i < n; i++) {
    const auto& s = this->_internal_alternate_extensions(i);
    target = stream->WriteString(35, s, target);
  }

  // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
    const auto& repfield = this->_internal_referrer_chain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_deprecated_download_attribution_finch_enabled(), target);
  }

  // optional bytes udif_code_signature = 40;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        40, this->_internal_udif_code_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest)
  return target;
}

size_t ClientDownloadRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest)
  size_t total_size = 0;

  if (_internal_has_url()) {
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (_internal_has_digests()) {
    // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.digests_);
  }

  if (_internal_has_length()) {
    // required int64 length = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
  }

  return total_size;
}
size_t ClientDownloadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000111) ^ 0x00000111) == 0) {  // All required fields are present.
    // required string url = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());

    // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.digests_);

    // required int64 length = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->_impl_.resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
  total_size += 2UL * this->_internal_archived_binary_size();
  for (const auto& msg : this->_impl_.archived_binary_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string alternate_extensions = 35;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.alternate_extensions_.size());
  for (int i = 0, n = _impl_.alternate_extensions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.alternate_extensions_.Get(i));
  }

  // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
  total_size += 2UL * this->_internal_referrer_chain_size();
  for (const auto& msg : this->_impl_.referrer_chain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional string file_basename = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_basename());
    }

    // optional string locale = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional bytes udif_code_signature = 40;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_udif_code_signature());
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_headers_);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 24;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.population_);
    }

  }
  if (cached_has_bits & 0x00007e00u) {
    // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_download_type());
    }

    // optional bool user_initiated = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool archive_valid = 26;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool skipped_url_whitelist = 28;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool skipped_certificate_whitelist = 31;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest*>(
      &from));
}

void ClientDownloadRequest::MergeFrom(const ClientDownloadRequest& from) {
  ClientDownloadRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
  _this->_impl_.archived_binary_.MergeFrom(from._impl_.archived_binary_);
  _this->_impl_.alternate_extensions_.MergeFrom(from._impl_.alternate_extensions_);
  _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file_basename(from._internal_file_basename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_udif_code_signature(from._internal_udif_code_signature());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_digests()->::safe_browsing::ClientDownloadRequest_Digests::MergeFrom(
          from._internal_digests());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(
          from._internal_signature());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(
          from._internal_image_headers());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(
          from._internal_population());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.download_type_ = from._impl_.download_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.user_initiated_ = from._impl_.user_initiated_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.archive_valid_ = from._impl_.archive_valid_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.skipped_url_whitelist_ = from._impl_.skipped_url_whitelist_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.skipped_certificate_whitelist_ = from._impl_.skipped_certificate_whitelist_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.deprecated_download_attribution_finch_enabled_ = from._impl_.deprecated_download_attribution_finch_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest::CopyFrom(const ClientDownloadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.resources_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.archived_binary_))
    return false;
  if (_internal_has_signature()) {
    if (!_impl_.signature_->IsInitialized()) return false;
  }
  if (_internal_has_image_headers()) {
    if (!_impl_.image_headers_->IsInitialized()) return false;
  }
  return true;
}

void ClientDownloadRequest::InternalSwap(ClientDownloadRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.resources_.InternalSwap(&other->_impl_.resources_);
  _impl_.archived_binary_.InternalSwap(&other->_impl_.archived_binary_);
  _impl_.alternate_extensions_.InternalSwap(&other->_impl_.alternate_extensions_);
  _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_basename_, lhs_arena,
      &other->_impl_.file_basename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.locale_, lhs_arena,
      &other->_impl_.locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.udif_code_signature_, lhs_arena,
      &other->_impl_.udif_code_signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientDownloadRequest, _impl_.deprecated_download_attribution_finch_enabled_)
      + sizeof(ClientDownloadRequest::_impl_.deprecated_download_attribution_finch_enabled_)
      - PROTOBUF_FIELD_OFFSET(ClientDownloadRequest, _impl_.digests_)>(
          reinterpret_cast<char*>(&_impl_.digests_),
          reinterpret_cast<char*>(&other->_impl_.digests_));
}

std::string ClientDownloadRequest::GetTypeName() const {
  return "safe_browsing.ClientDownloadRequest";
}


// ===================================================================

class ReferrerChainEntry_ServerRedirect::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferrerChainEntry_ServerRedirect>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
}
ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(const ReferrerChainEntry_ServerRedirect& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ReferrerChainEntry_ServerRedirect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
}

inline void ReferrerChainEntry_ServerRedirect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReferrerChainEntry_ServerRedirect::~ReferrerChainEntry_ServerRedirect() {
  // @@protoc_insertion_point(destructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferrerChainEntry_ServerRedirect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
}

void ReferrerChainEntry_ServerRedirect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferrerChainEntry_ServerRedirect::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReferrerChainEntry_ServerRedirect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferrerChainEntry_ServerRedirect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ReferrerChainEntry.ServerRedirect)
  return target;
}

size_t ReferrerChainEntry_ServerRedirect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string url = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReferrerChainEntry_ServerRedirect::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReferrerChainEntry_ServerRedirect*>(
      &from));
}

void ReferrerChainEntry_ServerRedirect::MergeFrom(const ReferrerChainEntry_ServerRedirect& from) {
  ReferrerChainEntry_ServerRedirect* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_url()) {
    _this->_internal_set_url(from._internal_url());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReferrerChainEntry_ServerRedirect::CopyFrom(const ReferrerChainEntry_ServerRedirect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferrerChainEntry_ServerRedirect::IsInitialized() const {
  return true;
}

void ReferrerChainEntry_ServerRedirect::InternalSwap(ReferrerChainEntry_ServerRedirect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

std::string ReferrerChainEntry_ServerRedirect::GetTypeName() const {
  return "safe_browsing.ReferrerChainEntry.ServerRedirect";
}


// ===================================================================

class ReferrerChainEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferrerChainEntry>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_main_frame_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_referrer_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer_main_frame_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_retargeting(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_navigation_time_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ReferrerChainEntry::ReferrerChainEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ReferrerChainEntry)
}
ReferrerChainEntry::ReferrerChainEntry(const ReferrerChainEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ReferrerChainEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_addresses_){from._impl_.ip_addresses_}
    , decltype(_impl_.server_redirect_chain_){from._impl_.server_redirect_chain_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.referrer_main_frame_url_){}
    , decltype(_impl_.main_frame_url_){}
    , decltype(_impl_.navigation_time_msec_){}
    , decltype(_impl_.is_retargeting_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer_url()) {
    _this->_impl_.referrer_url_.Set(from._internal_referrer_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_main_frame_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_main_frame_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer_main_frame_url()) {
    _this->_impl_.referrer_main_frame_url_.Set(from._internal_referrer_main_frame_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.main_frame_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_frame_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_main_frame_url()) {
    _this->_impl_.main_frame_url_.Set(from._internal_main_frame_url(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.navigation_time_msec_, &from._impl_.navigation_time_msec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.navigation_time_msec_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ReferrerChainEntry)
}

inline void ReferrerChainEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_addresses_){arena}
    , decltype(_impl_.server_redirect_chain_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.referrer_main_frame_url_){}
    , decltype(_impl_.main_frame_url_){}
    , decltype(_impl_.navigation_time_msec_){0}
    , decltype(_impl_.is_retargeting_){false}
    , decltype(_impl_.type_){4}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_main_frame_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_main_frame_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.main_frame_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_frame_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReferrerChainEntry::~ReferrerChainEntry() {
  // @@protoc_insertion_point(destructor:safe_browsing.ReferrerChainEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferrerChainEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_addresses_.~RepeatedPtrField();
  _impl_.server_redirect_chain_.~RepeatedPtrField();
  _impl_.url_.Destroy();
  _impl_.referrer_url_.Destroy();
  _impl_.referrer_main_frame_url_.Destroy();
  _impl_.main_frame_url_.Destroy();
}

void ReferrerChainEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferrerChainEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ReferrerChainEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_addresses_.Clear();
  _impl_.server_redirect_chain_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.referrer_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.referrer_main_frame_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.main_frame_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.navigation_time_msec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_retargeting_) -
        reinterpret_cast<char*>(&_impl_.navigation_time_msec_)) + sizeof(_impl_.is_retargeting_));
    _impl_.type_ = 4;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReferrerChainEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ReferrerChainEntry_URLType_IsValid(val))) {
            _internal_set_type(static_cast<::safe_browsing::ReferrerChainEntry_URLType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string ip_addresses = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_ip_addresses();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string referrer_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer_main_frame_url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_referrer_main_frame_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_retargeting = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_retargeting(&has_bits);
          _impl_.is_retargeting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double navigation_time_msec = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_navigation_time_msec(&has_bits);
          _impl_.navigation_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_server_redirect_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string main_frame_url = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_main_frame_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferrerChainEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ReferrerChainEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // repeated string ip_addresses = 3;
  for (int i = 0, n = this->_internal_ip_addresses_size(); i < n; i++) {
    const auto& s = this->_internal_ip_addresses(i);
    target = stream->WriteString(3, s, target);
  }

  // optional string referrer_url = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer_url(), target);
  }

  // optional string referrer_main_frame_url = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_referrer_main_frame_url(), target);
  }

  // optional bool is_retargeting = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_retargeting(), target);
  }

  // optional double navigation_time_msec = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_navigation_time_msec(), target);
  }

  // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_server_redirect_chain_size()); i < n; i++) {
    const auto& repfield = this->_internal_server_redirect_chain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string main_frame_url = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_main_frame_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ReferrerChainEntry)
  return target;
}

size_t ReferrerChainEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ReferrerChainEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string ip_addresses = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.ip_addresses_.size());
  for (int i = 0, n = _impl_.ip_addresses_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.ip_addresses_.Get(i));
  }

  // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
  total_size += 1UL * this->_internal_server_redirect_chain_size();
  for (const auto& msg : this->_impl_.server_redirect_chain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string referrer_url = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer_url());
    }

    // optional string referrer_main_frame_url = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer_main_frame_url());
    }

    // optional string main_frame_url = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_main_frame_url());
    }

    // optional double navigation_time_msec = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional bool is_retargeting = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReferrerChainEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReferrerChainEntry*>(
      &from));
}

void ReferrerChainEntry::MergeFrom(const ReferrerChainEntry& from) {
  ReferrerChainEntry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ReferrerChainEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ip_addresses_.MergeFrom(from._impl_.ip_addresses_);
  _this->_impl_.server_redirect_chain_.MergeFrom(from._impl_.server_redirect_chain_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_referrer_url(from._internal_referrer_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_referrer_main_frame_url(from._internal_referrer_main_frame_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_main_frame_url(from._internal_main_frame_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.navigation_time_msec_ = from._impl_.navigation_time_msec_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_retargeting_ = from._impl_.is_retargeting_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReferrerChainEntry::CopyFrom(const ReferrerChainEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ReferrerChainEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferrerChainEntry::IsInitialized() const {
  return true;
}

void ReferrerChainEntry::InternalSwap(ReferrerChainEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ip_addresses_.InternalSwap(&other->_impl_.ip_addresses_);
  _impl_.server_redirect_chain_.InternalSwap(&other->_impl_.server_redirect_chain_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_url_, lhs_arena,
      &other->_impl_.referrer_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_main_frame_url_, lhs_arena,
      &other->_impl_.referrer_main_frame_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.main_frame_url_, lhs_arena,
      &other->_impl_.main_frame_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReferrerChainEntry, _impl_.is_retargeting_)
      + sizeof(ReferrerChainEntry::_impl_.is_retargeting_)
      - PROTOBUF_FIELD_OFFSET(ReferrerChainEntry, _impl_.navigation_time_msec_)>(
          reinterpret_cast<char*>(&_impl_.navigation_time_msec_),
          reinterpret_cast<char*>(&other->_impl_.navigation_time_msec_));
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ReferrerChainEntry::GetTypeName() const {
  return "safe_browsing.ReferrerChainEntry";
}


// ===================================================================

class ClientDownloadResponse_MoreInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadResponse_MoreInfo>()._impl_._has_bits_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadResponse.MoreInfo)
}
ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(const ClientDownloadResponse_MoreInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadResponse_MoreInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_){}
    , decltype(_impl_.url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(),
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadResponse.MoreInfo)
}

inline void ClientDownloadResponse_MoreInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_){}
    , decltype(_impl_.url_){}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadResponse_MoreInfo::~ClientDownloadResponse_MoreInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadResponse.MoreInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadResponse_MoreInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.description_.Destroy();
  _impl_.url_.Destroy();
}

void ClientDownloadResponse_MoreInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadResponse_MoreInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadResponse.MoreInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadResponse_MoreInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadResponse_MoreInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadResponse.MoreInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string description = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadResponse.MoreInfo)
  return target;
}

size_t ClientDownloadResponse_MoreInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadResponse.MoreInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string description = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadResponse_MoreInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadResponse_MoreInfo*>(
      &from));
}

void ClientDownloadResponse_MoreInfo::MergeFrom(const ClientDownloadResponse_MoreInfo& from) {
  ClientDownloadResponse_MoreInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadResponse.MoreInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadResponse_MoreInfo::CopyFrom(const ClientDownloadResponse_MoreInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadResponse.MoreInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadResponse_MoreInfo::IsInitialized() const {
  return true;
}

void ClientDownloadResponse_MoreInfo::InternalSwap(ClientDownloadResponse_MoreInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

std::string ClientDownloadResponse_MoreInfo::GetTypeName() const {
  return "safe_browsing.ClientDownloadResponse.MoreInfo";
}


// ===================================================================

class ClientDownloadResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadResponse>()._impl_._has_bits_);
  static void set_has_verdict(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientDownloadResponse_MoreInfo& more_info(const ClientDownloadResponse* msg);
  static void set_has_more_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upload(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientDownloadResponse_MoreInfo&
ClientDownloadResponse::_Internal::more_info(const ClientDownloadResponse* msg) {
  return *msg->_impl_.more_info_;
}
ClientDownloadResponse::ClientDownloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadResponse)
}
ClientDownloadResponse::ClientDownloadResponse(const ClientDownloadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.more_info_){nullptr}
    , decltype(_impl_.verdict_){}
    , decltype(_impl_.upload_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_more_info()) {
    _this->_impl_.more_info_ = new ::safe_browsing::ClientDownloadResponse_MoreInfo(*from._impl_.more_info_);
  }
  ::memcpy(&_impl_.verdict_, &from._impl_.verdict_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_) -
    reinterpret_cast<char*>(&_impl_.verdict_)) + sizeof(_impl_.upload_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadResponse)
}

inline void ClientDownloadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.more_info_){nullptr}
    , decltype(_impl_.verdict_){0}
    , decltype(_impl_.upload_){false}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadResponse::~ClientDownloadResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.more_info_;
}

void ClientDownloadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.more_info_ != nullptr);
      _impl_.more_info_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.verdict_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upload_) -
        reinterpret_cast<char*>(&_impl_.verdict_)) + sizeof(_impl_.upload_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(val))) {
            _internal_set_verdict(static_cast<::safe_browsing::ClientDownloadResponse_Verdict>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_more_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool upload = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_upload(&has_bits);
          _impl_.upload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_verdict(), target);
  }

  // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::more_info(this),
        _Internal::more_info(this).GetCachedSize(), target, stream);
  }

  // optional bytes token = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_token(), target);
  }

  // optional bool upload = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_upload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadResponse)
  return target;
}

size_t ClientDownloadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes token = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.more_info_);
    }

    // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict());
    }

    // optional bool upload = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadResponse*>(
      &from));
}

void ClientDownloadResponse::MergeFrom(const ClientDownloadResponse& from) {
  ClientDownloadResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_more_info()->::safe_browsing::ClientDownloadResponse_MoreInfo::MergeFrom(
          from._internal_more_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.verdict_ = from._impl_.verdict_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.upload_ = from._impl_.upload_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadResponse::CopyFrom(const ClientDownloadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadResponse::IsInitialized() const {
  return true;
}

void ClientDownloadResponse::InternalSwap(ClientDownloadResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientDownloadResponse, _impl_.upload_)
      + sizeof(ClientDownloadResponse::_impl_.upload_)
      - PROTOBUF_FIELD_OFFSET(ClientDownloadResponse, _impl_.more_info_)>(
          reinterpret_cast<char*>(&_impl_.more_info_),
          reinterpret_cast<char*>(&other->_impl_.more_info_));
}

std::string ClientDownloadResponse::GetTypeName() const {
  return "safe_browsing.ClientDownloadResponse";
}


// ===================================================================

class ClientDownloadReport_UserInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadReport_UserInformation>()._impl_._has_bits_);
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadReport.UserInformation)
}
ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(const ClientDownloadReport_UserInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadReport_UserInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    _this->_impl_.email_.Set(from._internal_email(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadReport.UserInformation)
}

inline void ClientDownloadReport_UserInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.email_){}
  };
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadReport_UserInformation::~ClientDownloadReport_UserInformation() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadReport.UserInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadReport_UserInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_.Destroy();
}

void ClientDownloadReport_UserInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadReport_UserInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadReport.UserInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.email_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadReport_UserInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string email = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadReport_UserInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadReport.UserInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string email = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_email(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadReport.UserInformation)
  return target;
}

size_t ClientDownloadReport_UserInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadReport.UserInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string email = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadReport_UserInformation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadReport_UserInformation*>(
      &from));
}

void ClientDownloadReport_UserInformation::MergeFrom(const ClientDownloadReport_UserInformation& from) {
  ClientDownloadReport_UserInformation* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadReport.UserInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_email()) {
    _this->_internal_set_email(from._internal_email());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadReport_UserInformation::CopyFrom(const ClientDownloadReport_UserInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadReport.UserInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadReport_UserInformation::IsInitialized() const {
  return true;
}

void ClientDownloadReport_UserInformation::InternalSwap(ClientDownloadReport_UserInformation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
}

std::string ClientDownloadReport_UserInformation::GetTypeName() const {
  return "safe_browsing.ClientDownloadReport.UserInformation";
}


// ===================================================================

class ClientDownloadReport::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientDownloadReport>()._impl_._has_bits_);
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::ClientDownloadRequest& download_request(const ClientDownloadReport* msg);
  static void set_has_download_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientDownloadReport_UserInformation& user_information(const ClientDownloadReport* msg);
  static void set_has_user_information(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientDownloadResponse& download_response(const ClientDownloadReport* msg);
  static void set_has_download_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientDownloadRequest&
ClientDownloadReport::_Internal::download_request(const ClientDownloadReport* msg) {
  return *msg->_impl_.download_request_;
}
const ::safe_browsing::ClientDownloadReport_UserInformation&
ClientDownloadReport::_Internal::user_information(const ClientDownloadReport* msg) {
  return *msg->_impl_.user_information_;
}
const ::safe_browsing::ClientDownloadResponse&
ClientDownloadReport::_Internal::download_response(const ClientDownloadReport* msg) {
  return *msg->_impl_.download_response_;
}
ClientDownloadReport::ClientDownloadReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadReport)
}
ClientDownloadReport::ClientDownloadReport(const ClientDownloadReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientDownloadReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.download_request_){nullptr}
    , decltype(_impl_.user_information_){nullptr}
    , decltype(_impl_.download_response_){nullptr}
    , decltype(_impl_.reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment()) {
    _this->_impl_.comment_.Set(from._internal_comment(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_download_request()) {
    _this->_impl_.download_request_ = new ::safe_browsing::ClientDownloadRequest(*from._impl_.download_request_);
  }
  if (from._internal_has_user_information()) {
    _this->_impl_.user_information_ = new ::safe_browsing::ClientDownloadReport_UserInformation(*from._impl_.user_information_);
  }
  if (from._internal_has_download_response()) {
    _this->_impl_.download_response_ = new ::safe_browsing::ClientDownloadResponse(*from._impl_.download_response_);
  }
  _this->_impl_.reason_ = from._impl_.reason_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadReport)
}

inline void ClientDownloadReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.download_request_){nullptr}
    , decltype(_impl_.user_information_){nullptr}
    , decltype(_impl_.download_response_){nullptr}
    , decltype(_impl_.reason_){0}
  };
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadReport::~ClientDownloadReport() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDownloadReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comment_.Destroy();
  if (this != internal_default_instance()) delete _impl_.download_request_;
  if (this != internal_default_instance()) delete _impl_.user_information_;
  if (this != internal_default_instance()) delete _impl_.download_response_;
}

void ClientDownloadReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientDownloadReport::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.comment_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.download_request_ != nullptr);
      _impl_.download_request_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.user_information_ != nullptr);
      _impl_.user_information_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.download_response_ != nullptr);
      _impl_.download_response_->Clear();
    }
  }
  _impl_.reason_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadReport_Reason_IsValid(val))) {
            _internal_set_reason(static_cast<::safe_browsing::ClientDownloadReport_Reason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest download_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_download_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_information(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes comment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadResponse download_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_download_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reason(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest download_request = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::download_request(this),
        _Internal::download_request(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::user_information(this),
        _Internal::user_information(this).GetCachedSize(), target, stream);
  }

  // optional bytes comment = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_comment(), target);
  }

  // optional .safe_browsing.ClientDownloadResponse download_response = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::download_response(this),
        _Internal::download_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadReport)
  return target;
}

size_t ClientDownloadReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes comment = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_comment());
    }

    // optional .safe_browsing.ClientDownloadRequest download_request = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.download_request_);
    }

    // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_information_);
    }

    // optional .safe_browsing.ClientDownloadResponse download_response = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.download_response_);
    }

    // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDownloadReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDownloadReport*>(
      &from));
}

void ClientDownloadReport::MergeFrom(const ClientDownloadReport& from) {
  ClientDownloadReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_download_request()->::safe_browsing::ClientDownloadRequest::MergeFrom(
          from._internal_download_request());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_user_information()->::safe_browsing::ClientDownloadReport_UserInformation::MergeFrom(
          from._internal_user_information());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_download_response()->::safe_browsing::ClientDownloadResponse::MergeFrom(
          from._internal_download_response());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadReport::CopyFrom(const ClientDownloadReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDownloadReport::IsInitialized() const {
  if (_internal_has_download_request()) {
    if (!_impl_.download_request_->IsInitialized()) return false;
  }
  return true;
}

void ClientDownloadReport::InternalSwap(ClientDownloadReport* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientDownloadReport, _impl_.reason_)
      + sizeof(ClientDownloadReport::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(ClientDownloadReport, _impl_.download_request_)>(
          reinterpret_cast<char*>(&_impl_.download_request_),
          reinterpret_cast<char*>(&other->_impl_.download_request_));
}

std::string ClientDownloadReport::GetTypeName() const {
  return "safe_browsing.ClientDownloadReport";
}


// ===================================================================

class ClientUploadResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientUploadResponse>()._impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_permalink(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientUploadResponse::ClientUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientUploadResponse)
}
ClientUploadResponse::ClientUploadResponse(const ClientUploadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientUploadResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permalink_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.permalink_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.permalink_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_permalink()) {
    _this->_impl_.permalink_.Set(from._internal_permalink(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientUploadResponse)
}

inline void ClientUploadResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.permalink_){}
    , decltype(_impl_.status_){0}
  };
  _impl_.permalink_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.permalink_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientUploadResponse::~ClientUploadResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientUploadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientUploadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.permalink_.Destroy();
}

void ClientUploadResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientUploadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientUploadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.permalink_.ClearNonDefaultToEmpty();
  }
  _impl_.status_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientUploadResponse_UploadStatus_IsValid(val))) {
            _internal_set_status(static_cast<::safe_browsing::ClientUploadResponse_UploadStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string permalink = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_permalink();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientUploadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientUploadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // optional string permalink = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_permalink(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientUploadResponse)
  return target;
}

size_t ClientUploadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientUploadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string permalink = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_permalink());
    }

    // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientUploadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientUploadResponse*>(
      &from));
}

void ClientUploadResponse::MergeFrom(const ClientUploadResponse& from) {
  ClientUploadResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientUploadResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_permalink(from._internal_permalink());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientUploadResponse::CopyFrom(const ClientUploadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientUploadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientUploadResponse::IsInitialized() const {
  return true;
}

void ClientUploadResponse::InternalSwap(ClientUploadResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.permalink_, lhs_arena,
      &other->_impl_.permalink_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

std::string ClientUploadResponse::GetTypeName() const {
  return "safe_browsing.ClientUploadResponse";
}


// ===================================================================

class ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_TrackedPreferenceIncident>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_atomic_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
}
ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_IncidentData_TrackedPreferenceIncident* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.split_key_){from._impl_.split_key_}
    , decltype(_impl_.path_){}
    , decltype(_impl_.atomic_value_){}
    , decltype(_impl_.value_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(),
      _this->GetArenaForAllocation());
  }
  _impl_.atomic_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.atomic_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_atomic_value()) {
    _this->_impl_.atomic_value_.Set(from._internal_atomic_value(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_state_ = from._impl_.value_state_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
}

inline void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.split_key_){arena}
    , decltype(_impl_.path_){}
    , decltype(_impl_.atomic_value_){}
    , decltype(_impl_.value_state_){0}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.atomic_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.atomic_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_TrackedPreferenceIncident::~ClientIncidentReport_IncidentData_TrackedPreferenceIncident() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.split_key_.~RepeatedPtrField();
  _impl_.path_.Destroy();
  _impl_.atomic_value_.Destroy();
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.split_key_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.atomic_value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.value_state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string atomic_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_atomic_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string split_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_split_key();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_IsValid(val))) {
            _internal_set_value_state(static_cast<::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional string atomic_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_atomic_value(), target);
  }

  // repeated string split_key = 3;
  for (int i = 0, n = this->_internal_split_key_size(); i < n; i++) {
    const auto& s = this->_internal_split_key(i);
    target = stream->WriteString(3, s, target);
  }

  // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_value_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  return target;
}

size_t ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string split_key = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.split_key_.size());
  for (int i = 0, n = _impl_.split_key_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.split_key_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional string atomic_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_atomic_value());
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_value_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_TrackedPreferenceIncident*>(
      &from));
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::MergeFrom(const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from) {
  ClientIncidentReport_IncidentData_TrackedPreferenceIncident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.split_key_.MergeFrom(from._impl_.split_key_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_atomic_value(from._internal_atomic_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.value_state_ = from._impl_.value_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CopyFrom(const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident::IsInitialized() const {
  return true;
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::InternalSwap(ClientIncidentReport_IncidentData_TrackedPreferenceIncident* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.split_key_.InternalSwap(&other->_impl_.split_key_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.atomic_value_, lhs_arena,
      &other->_impl_.atomic_value_, rhs_arena
  );
  swap(_impl_.value_state_, other->_impl_.value_state_);
}

std::string ClientIncidentReport_IncidentData_TrackedPreferenceIncident::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident";
}


// ===================================================================

class ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile>()._impl_._has_bits_);
  static void set_has_relative_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg);
  static void set_has_image_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::ClientDownloadRequest_SignatureInfo&
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal::signature(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg) {
  return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders&
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal::image_headers(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg) {
  return *msg->_impl_.image_headers_;
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relative_path()) {
    _this->_impl_.relative_path_.Set(from._internal_relative_path(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_signature()) {
    _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
  }
  if (from._internal_has_image_headers()) {
    _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
  };
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::~ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.relative_path_.Destroy();
  if (this != internal_default_instance()) delete _impl_.signature_;
  if (this != internal_default_instance()) delete _impl_.image_headers_;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.relative_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.signature_ != nullptr);
      _impl_.signature_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
      _impl_.image_headers_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string relative_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_relative_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string relative_path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_relative_path(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signature(this),
        _Internal::signature(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image_headers(this),
        _Internal::image_headers(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  return target;
}

size_t ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string relative_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_relative_path());
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_headers_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile*>(
      &from));
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::MergeFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from) {
  ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_relative_path(from._internal_relative_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(
          from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(
          from._internal_image_headers());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::CopyFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::IsInitialized() const {
  if (_internal_has_signature()) {
    if (!_impl_.signature_->IsInitialized()) return false;
  }
  if (_internal_has_image_headers()) {
    if (!_impl_.image_headers_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::InternalSwap(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relative_path_, lhs_arena,
      &other->_impl_.relative_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile, _impl_.image_headers_)
      + sizeof(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_impl_.image_headers_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile, _impl_.signature_)>(
          reinterpret_cast<char*>(&_impl_.signature_),
          reinterpret_cast<char*>(&other->_impl_.signature_));
}

std::string ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile";
}


// ===================================================================

class ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_BinaryIntegrityIncident>()._impl_._has_bits_);
  static void set_has_file_basename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg);
  static void set_has_image_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientDownloadRequest_SignatureInfo&
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal::signature(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg) {
  return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders&
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal::image_headers(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg) {
  return *msg->_impl_.image_headers_;
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_IncidentData_BinaryIntegrityIncident* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contained_file_){from._impl_.contained_file_}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.sec_error_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_basename()) {
    _this->_impl_.file_basename_.Set(from._internal_file_basename(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_signature()) {
    _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
  }
  if (from._internal_has_image_headers()) {
    _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
  }
  _this->_impl_.sec_error_ = from._impl_.sec_error_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.contained_file_){arena}
    , decltype(_impl_.file_basename_){}
    , decltype(_impl_.signature_){nullptr}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.sec_error_){0}
  };
  _impl_.file_basename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_BinaryIntegrityIncident::~ClientIncidentReport_IncidentData_BinaryIntegrityIncident() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.contained_file_.~RepeatedPtrField();
  _impl_.file_basename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.signature_;
  if (this != internal_default_instance()) delete _impl_.image_headers_;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.contained_file_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.file_basename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.signature_ != nullptr);
      _impl_.signature_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
      _impl_.image_headers_->Clear();
    }
  }
  _impl_.sec_error_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string file_basename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_file_basename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sec_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_error(&has_bits);
          _impl_.sec_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_contained_file(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string file_basename = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file_basename(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signature(this),
        _Internal::signature(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image_headers(this),
        _Internal::image_headers(this).GetCachedSize(), target, stream);
  }

  // optional int32 sec_error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sec_error(), target);
  }

  // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_contained_file_size()); i < n; i++) {
    const auto& repfield = this->_internal_contained_file(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  return target;
}

size_t ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
  total_size += 1UL * this->_internal_contained_file_size();
  for (const auto& msg : this->_impl_.contained_file_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string file_basename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_basename());
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.signature_);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_headers_);
    }

    // optional int32 sec_error = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_BinaryIntegrityIncident*>(
      &from));
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::MergeFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from) {
  ClientIncidentReport_IncidentData_BinaryIntegrityIncident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.contained_file_.MergeFrom(from._impl_.contained_file_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_file_basename(from._internal_file_basename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(
          from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(
          from._internal_image_headers());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sec_error_ = from._impl_.sec_error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::CopyFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_BinaryIntegrityIncident::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.contained_file_))
    return false;
  if (_internal_has_signature()) {
    if (!_impl_.signature_->IsInitialized()) return false;
  }
  if (_internal_has_image_headers()) {
    if (!_impl_.image_headers_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::InternalSwap(ClientIncidentReport_IncidentData_BinaryIntegrityIncident* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.contained_file_.InternalSwap(&other->_impl_.contained_file_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_basename_, lhs_arena,
      &other->_impl_.file_basename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident, _impl_.sec_error_)
      + sizeof(ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_impl_.sec_error_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident, _impl_.signature_)>(
          reinterpret_cast<char*>(&_impl_.signature_),
          reinterpret_cast<char*>(&other->_impl_.signature_));
}

std::string ClientIncidentReport_IncidentData_BinaryIntegrityIncident::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident";
}


// ===================================================================

class ClientIncidentReport_IncidentData_ResourceRequestIncident::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_ResourceRequestIncident>()._impl_._has_bits_);
  static void set_has_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
}
ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(const ClientIncidentReport_IncidentData_ResourceRequestIncident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_IncidentData_ResourceRequestIncident* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.digest_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_digest()) {
    _this->_impl_.digest_.Set(from._internal_digest(),
      _this->GetArenaForAllocation());
  }
  _impl_.origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_origin()) {
    _this->_impl_.origin_.Set(from._internal_origin(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
}

inline void ClientIncidentReport_IncidentData_ResourceRequestIncident::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.digest_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_ResourceRequestIncident::~ClientIncidentReport_IncidentData_ResourceRequestIncident() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_IncidentData_ResourceRequestIncident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.digest_.Destroy();
  _impl_.origin_.Destroy();
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.digest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.origin_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_ResourceRequestIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes digest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string origin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_origin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_IsValid(val))) {
            _internal_set_type(static_cast<::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_ResourceRequestIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes digest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_digest(), target);
  }

  // optional string origin = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_origin(), target);
  }

  // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  return target;
}

size_t ClientIncidentReport_IncidentData_ResourceRequestIncident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes digest = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_digest());
    }

    // optional string origin = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_origin());
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_ResourceRequestIncident*>(
      &from));
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::MergeFrom(const ClientIncidentReport_IncidentData_ResourceRequestIncident& from) {
  ClientIncidentReport_IncidentData_ResourceRequestIncident* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_digest(from._internal_digest());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_origin(from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::CopyFrom(const ClientIncidentReport_IncidentData_ResourceRequestIncident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_ResourceRequestIncident::IsInitialized() const {
  return true;
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::InternalSwap(ClientIncidentReport_IncidentData_ResourceRequestIncident* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.digest_, lhs_arena,
      &other->_impl_.digest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.origin_, lhs_arena,
      &other->_impl_.origin_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientIncidentReport_IncidentData_ResourceRequestIncident::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident";
}


// ===================================================================

class ClientIncidentReport_IncidentData::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData>()._impl_._has_bits_);
  static void set_has_incident_time_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident& tracked_preference(const ClientIncidentReport_IncidentData* msg);
  static void set_has_tracked_preference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident& binary_integrity(const ClientIncidentReport_IncidentData* msg);
  static void set_has_binary_integrity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident& resource_request(const ClientIncidentReport_IncidentData* msg);
  static void set_has_resource_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident&
ClientIncidentReport_IncidentData::_Internal::tracked_preference(const ClientIncidentReport_IncidentData* msg) {
  return *msg->_impl_.tracked_preference_;
}
const ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident&
ClientIncidentReport_IncidentData::_Internal::binary_integrity(const ClientIncidentReport_IncidentData* msg) {
  return *msg->_impl_.binary_integrity_;
}
const ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident&
ClientIncidentReport_IncidentData::_Internal::resource_request(const ClientIncidentReport_IncidentData* msg) {
  return *msg->_impl_.resource_request_;
}
ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData)
}
ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(const ClientIncidentReport_IncidentData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_IncidentData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tracked_preference_){nullptr}
    , decltype(_impl_.binary_integrity_){nullptr}
    , decltype(_impl_.resource_request_){nullptr}
    , decltype(_impl_.incident_time_msec_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tracked_preference()) {
    _this->_impl_.tracked_preference_ = new ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(*from._impl_.tracked_preference_);
  }
  if (from._internal_has_binary_integrity()) {
    _this->_impl_.binary_integrity_ = new ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(*from._impl_.binary_integrity_);
  }
  if (from._internal_has_resource_request()) {
    _this->_impl_.resource_request_ = new ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident(*from._impl_.resource_request_);
  }
  _this->_impl_.incident_time_msec_ = from._impl_.incident_time_msec_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData)
}

inline void ClientIncidentReport_IncidentData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tracked_preference_){nullptr}
    , decltype(_impl_.binary_integrity_){nullptr}
    , decltype(_impl_.resource_request_){nullptr}
    , decltype(_impl_.incident_time_msec_){int64_t{0}}
  };
}

ClientIncidentReport_IncidentData::~ClientIncidentReport_IncidentData() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_IncidentData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tracked_preference_;
  if (this != internal_default_instance()) delete _impl_.binary_integrity_;
  if (this != internal_default_instance()) delete _impl_.resource_request_;
}

void ClientIncidentReport_IncidentData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.tracked_preference_ != nullptr);
      _impl_.tracked_preference_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.binary_integrity_ != nullptr);
      _impl_.binary_integrity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.resource_request_ != nullptr);
      _impl_.resource_request_->Clear();
    }
  }
  _impl_.incident_time_msec_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 incident_time_msec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_incident_time_msec(&has_bits);
          _impl_.incident_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tracked_preference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_binary_integrity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_resource_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 incident_time_msec = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_incident_time_msec(), target);
  }

  // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tracked_preference(this),
        _Internal::tracked_preference(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::binary_integrity(this),
        _Internal::binary_integrity(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::resource_request(this),
        _Internal::resource_request(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData)
  return target;
}

size_t ClientIncidentReport_IncidentData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tracked_preference_);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.binary_integrity_);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.resource_request_);
    }

    // optional int64 incident_time_msec = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_incident_time_msec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_IncidentData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData*>(
      &from));
}

void ClientIncidentReport_IncidentData::MergeFrom(const ClientIncidentReport_IncidentData& from) {
  ClientIncidentReport_IncidentData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tracked_preference()->::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident::MergeFrom(
          from._internal_tracked_preference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_binary_integrity()->::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident::MergeFrom(
          from._internal_binary_integrity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_resource_request()->::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident::MergeFrom(
          from._internal_resource_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.incident_time_msec_ = from._impl_.incident_time_msec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData::CopyFrom(const ClientIncidentReport_IncidentData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_IncidentData::IsInitialized() const {
  if (_internal_has_binary_integrity()) {
    if (!_impl_.binary_integrity_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_IncidentData::InternalSwap(ClientIncidentReport_IncidentData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData, _impl_.incident_time_msec_)
      + sizeof(ClientIncidentReport_IncidentData::_impl_.incident_time_msec_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData, _impl_.tracked_preference_)>(
          reinterpret_cast<char*>(&_impl_.tracked_preference_),
          reinterpret_cast<char*>(&other->_impl_.tracked_preference_));
}

std::string ClientIncidentReport_IncidentData::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.IncidentData";
}


// ===================================================================

class ClientIncidentReport_DownloadDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_DownloadDetails>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientDownloadRequest& download(const ClientIncidentReport_DownloadDetails* msg);
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_download_time_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_open_time_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientDownloadRequest&
ClientIncidentReport_DownloadDetails::_Internal::download(const ClientIncidentReport_DownloadDetails* msg) {
  return *msg->_impl_.download_;
}
ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.DownloadDetails)
}
ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(const ClientIncidentReport_DownloadDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_DownloadDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.download_time_msec_){}
    , decltype(_impl_.open_time_msec_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_download()) {
    _this->_impl_.download_ = new ::safe_browsing::ClientDownloadRequest(*from._impl_.download_);
  }
  ::memcpy(&_impl_.download_time_msec_, &from._impl_.download_time_msec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.open_time_msec_) -
    reinterpret_cast<char*>(&_impl_.download_time_msec_)) + sizeof(_impl_.open_time_msec_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.DownloadDetails)
}

inline void ClientIncidentReport_DownloadDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.download_time_msec_){int64_t{0}}
    , decltype(_impl_.open_time_msec_){int64_t{0}}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_DownloadDetails::~ClientIncidentReport_DownloadDetails() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.DownloadDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_DownloadDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.download_;
}

void ClientIncidentReport_DownloadDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_DownloadDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.DownloadDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.download_ != nullptr);
      _impl_.download_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.download_time_msec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.open_time_msec_) -
        reinterpret_cast<char*>(&_impl_.download_time_msec_)) + sizeof(_impl_.open_time_msec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_DownloadDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest download = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 download_time_msec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_download_time_msec(&has_bits);
          _impl_.download_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 open_time_msec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_open_time_msec(&has_bits);
          _impl_.open_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_DownloadDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.DownloadDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest download = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::download(this),
        _Internal::download(this).GetCachedSize(), target, stream);
  }

  // optional int64 download_time_msec = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_download_time_msec(), target);
  }

  // optional int64 open_time_msec = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_open_time_msec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.DownloadDetails)
  return target;
}

size_t ClientIncidentReport_DownloadDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.DownloadDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional .safe_browsing.ClientDownloadRequest download = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.download_);
    }

    // optional int64 download_time_msec = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_download_time_msec());
    }

    // optional int64 open_time_msec = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_open_time_msec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_DownloadDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_DownloadDetails*>(
      &from));
}

void ClientIncidentReport_DownloadDetails::MergeFrom(const ClientIncidentReport_DownloadDetails& from) {
  ClientIncidentReport_DownloadDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.DownloadDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_download()->::safe_browsing::ClientDownloadRequest::MergeFrom(
          from._internal_download());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.download_time_msec_ = from._impl_.download_time_msec_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.open_time_msec_ = from._impl_.open_time_msec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_DownloadDetails::CopyFrom(const ClientIncidentReport_DownloadDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.DownloadDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_DownloadDetails::IsInitialized() const {
  if (_internal_has_download()) {
    if (!_impl_.download_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_DownloadDetails::InternalSwap(ClientIncidentReport_DownloadDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_DownloadDetails, _impl_.open_time_msec_)
      + sizeof(ClientIncidentReport_DownloadDetails::_impl_.open_time_msec_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_DownloadDetails, _impl_.download_)>(
          reinterpret_cast<char*>(&_impl_.download_),
          reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string ClientIncidentReport_DownloadDetails::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.DownloadDetails";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_OS_RegistryValue::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS_RegistryValue>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
}
ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_OS_RegistryValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.type_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS_RegistryValue::~ClientIncidentReport_EnvironmentData_OS_RegistryValue() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.data_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS_RegistryValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS_RegistryValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_OS_RegistryValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS_RegistryValue*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::MergeFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from) {
  ClientIncidentReport_EnvironmentData_OS_RegistryValue* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::CopyFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS_RegistryValue::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::InternalSwap(ClientIncidentReport_EnvironmentData_OS_RegistryValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientIncidentReport_EnvironmentData_OS_RegistryValue::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_OS_RegistryKey::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS_RegistryKey>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
}
ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_OS_RegistryKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){from._impl_.value_}
    , decltype(_impl_.key_){from._impl_.key_}
    , decltype(_impl_.name_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){arena}
    , decltype(_impl_.key_){arena}
    , decltype(_impl_.name_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS_RegistryKey::~ClientIncidentReport_EnvironmentData_OS_RegistryKey() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.~RepeatedPtrField();
  _impl_.key_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.Clear();
  _impl_.key_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS_RegistryKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_key(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS_RegistryKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_key_size()); i < n; i++) {
    const auto& repfield = this->_internal_key(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_OS_RegistryKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
  total_size += 1UL * this->_internal_value_size();
  for (const auto& msg : this->_impl_.value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
  total_size += 1UL * this->_internal_key_size();
  for (const auto& msg : this->_impl_.key_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS_RegistryKey*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::MergeFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from) {
  ClientIncidentReport_EnvironmentData_OS_RegistryKey* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.value_.MergeFrom(from._impl_.value_);
  _this->_impl_.key_.MergeFrom(from._impl_.key_);
  if (from._internal_has_name()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::CopyFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS_RegistryKey::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::InternalSwap(ClientIncidentReport_EnvironmentData_OS_RegistryKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.value_.InternalSwap(&other->_impl_.value_);
  _impl_.key_.InternalSwap(&other->_impl_.key_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

std::string ClientIncidentReport_EnvironmentData_OS_RegistryKey::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_OS::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS>()._impl_._has_bits_);
  static void set_has_os_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_enrolled_to_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
}
ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(const ClientIncidentReport_EnvironmentData_OS& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_OS* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.registry_key_){from._impl_.registry_key_}
    , decltype(_impl_.os_name_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.is_enrolled_to_domain_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.os_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_name()) {
    _this->_impl_.os_name_.Set(from._internal_os_name(),
      _this->GetArenaForAllocation());
  }
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    _this->_impl_.os_version_.Set(from._internal_os_version(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.is_enrolled_to_domain_ = from._impl_.is_enrolled_to_domain_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
}

inline void ClientIncidentReport_EnvironmentData_OS::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.registry_key_){arena}
    , decltype(_impl_.os_name_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.is_enrolled_to_domain_){false}
  };
  _impl_.os_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS::~ClientIncidentReport_EnvironmentData_OS() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.registry_key_.~RepeatedPtrField();
  _impl_.os_name_.Destroy();
  _impl_.os_version_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.registry_key_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.os_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.is_enrolled_to_domain_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string os_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_os_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_registry_key(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enrolled_to_domain = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_enrolled_to_domain(&has_bits);
          _impl_.is_enrolled_to_domain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string os_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_os_name(), target);
  }

  // optional string os_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_os_version(), target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_registry_key_size()); i < n; i++) {
    const auto& repfield = this->_internal_registry_key(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool is_enrolled_to_domain = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_enrolled_to_domain(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_OS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
  total_size += 1UL * this->_internal_registry_key_size();
  for (const auto& msg : this->_impl_.registry_key_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string os_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_name());
    }

    // optional string os_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional bool is_enrolled_to_domain = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_OS::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_OS::MergeFrom(const ClientIncidentReport_EnvironmentData_OS& from) {
  ClientIncidentReport_EnvironmentData_OS* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.registry_key_.MergeFrom(from._impl_.registry_key_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_os_name(from._internal_os_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_enrolled_to_domain_ = from._impl_.is_enrolled_to_domain_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS::CopyFrom(const ClientIncidentReport_EnvironmentData_OS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_OS::InternalSwap(ClientIncidentReport_EnvironmentData_OS* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.registry_key_.InternalSwap(&other->_impl_.registry_key_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_name_, lhs_arena,
      &other->_impl_.os_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_version_, lhs_arena,
      &other->_impl_.os_version_, rhs_arena
  );
  swap(_impl_.is_enrolled_to_domain_, other->_impl_.is_enrolled_to_domain_);
}

std::string ClientIncidentReport_EnvironmentData_OS::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.OS";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Machine::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Machine>()._impl_._has_bits_);
  static void set_has_cpu_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cpuid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
}
ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(const ClientIncidentReport_EnvironmentData_Machine& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Machine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_architecture_){}
    , decltype(_impl_.cpu_vendor_){}
    , decltype(_impl_.cpuid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.cpu_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_architecture()) {
    _this->_impl_.cpu_architecture_.Set(from._internal_cpu_architecture(),
      _this->GetArenaForAllocation());
  }
  _impl_.cpu_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_vendor()) {
    _this->_impl_.cpu_vendor_.Set(from._internal_cpu_vendor(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.cpuid_ = from._impl_.cpuid_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
}

inline void ClientIncidentReport_EnvironmentData_Machine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpu_architecture_){}
    , decltype(_impl_.cpu_vendor_){}
    , decltype(_impl_.cpuid_){0u}
  };
  _impl_.cpu_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cpu_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Machine::~ClientIncidentReport_EnvironmentData_Machine() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Machine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cpu_architecture_.Destroy();
  _impl_.cpu_vendor_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Machine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Machine::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cpu_architecture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cpu_vendor_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.cpuid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Machine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cpu_architecture = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cpu_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cpu_vendor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cpu_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cpuid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cpuid(&has_bits);
          _impl_.cpuid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Machine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string cpu_architecture = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cpu_architecture(), target);
  }

  // optional string cpu_vendor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cpu_vendor(), target);
  }

  // optional uint32 cpuid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_cpuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Machine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string cpu_architecture = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_architecture());
    }

    // optional string cpu_vendor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_vendor());
    }

    // optional uint32 cpuid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpuid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Machine::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Machine*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Machine::MergeFrom(const ClientIncidentReport_EnvironmentData_Machine& from) {
  ClientIncidentReport_EnvironmentData_Machine* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cpu_architecture(from._internal_cpu_architecture());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cpu_vendor(from._internal_cpu_vendor());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cpuid_ = from._impl_.cpuid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Machine::CopyFrom(const ClientIncidentReport_EnvironmentData_Machine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Machine::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_Machine::InternalSwap(ClientIncidentReport_EnvironmentData_Machine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_architecture_, lhs_arena,
      &other->_impl_.cpu_architecture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cpu_vendor_, lhs_arena,
      &other->_impl_.cpu_vendor_, rhs_arena
  );
  swap(_impl_.cpuid_, other->_impl_.cpuid_);
}

std::string ClientIncidentReport_EnvironmentData_Machine::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Machine";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_Patch::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_Patch>()._impl_._has_bits_);
  static void set_has_function(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_dll(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
}
ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(const ClientIncidentReport_EnvironmentData_Process_Patch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process_Patch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.function_){}
    , decltype(_impl_.target_dll_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function()) {
    _this->_impl_.function_.Set(from._internal_function(),
      _this->GetArenaForAllocation());
  }
  _impl_.target_dll_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_dll_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_dll()) {
    _this->_impl_.target_dll_.Set(from._internal_target_dll(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
}

inline void ClientIncidentReport_EnvironmentData_Process_Patch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.function_){}
    , decltype(_impl_.target_dll_){}
  };
  _impl_.function_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_dll_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_dll_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_Patch::~ClientIncidentReport_EnvironmentData_Process_Patch() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_Patch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.function_.Destroy();
  _impl_.target_dll_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_Patch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_Patch::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.function_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.target_dll_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_Patch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string function = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_function();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string target_dll = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_target_dll();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_Patch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string function = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_function(), target);
  }

  // optional string target_dll = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_target_dll(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_Patch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string function = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_function());
    }

    // optional string target_dll = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_dll());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_Patch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_Patch*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process_Patch::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_Patch& from) {
  ClientIncidentReport_EnvironmentData_Process_Patch* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_function(from._internal_function());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_target_dll(from._internal_target_dll());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_Patch::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_Patch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_Patch::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_Process_Patch::InternalSwap(ClientIncidentReport_EnvironmentData_Process_Patch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_, lhs_arena,
      &other->_impl_.function_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_dll_, lhs_arena,
      &other->_impl_.target_dll_, rhs_arena
  );
}

std::string ClientIncidentReport_EnvironmentData_Process_Patch::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_Internal {
 public:
};

ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
}
ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process_NetworkProvider* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
}

inline void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ClientIncidentReport_EnvironmentData_Process_NetworkProvider::~ClientIncidentReport_EnvironmentData_Process_NetworkProvider() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_NetworkProvider*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from) {
  ClientIncidentReport_EnvironmentData_Process_NetworkProvider* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_NetworkProvider::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::InternalSwap(ClientIncidentReport_EnvironmentData_Process_NetworkProvider* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClientIncidentReport_EnvironmentData_Process_NetworkProvider::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_Dll::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_Dll>()._impl_._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientIncidentReport_EnvironmentData_Process_Dll* msg);
  static void set_has_image_headers(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::ClientDownloadRequest_ImageHeaders&
ClientIncidentReport_EnvironmentData_Process_Dll::_Internal::image_headers(const ClientIncidentReport_EnvironmentData_Process_Dll* msg) {
  return *msg->_impl_.image_headers_;
}
ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
}
ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(const ClientIncidentReport_EnvironmentData_Process_Dll& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process_Dll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feature_){from._impl_.feature_}
    , decltype(_impl_.path_){}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.base_address_){}
    , decltype(_impl_.length_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_image_headers()) {
    _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
  }
  ::memcpy(&_impl_.base_address_, &from._impl_.base_address_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.length_) -
    reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.length_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
}

inline void ClientIncidentReport_EnvironmentData_Process_Dll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feature_){arena}
    , decltype(_impl_.path_){}
    , decltype(_impl_.image_headers_){nullptr}
    , decltype(_impl_.base_address_){uint64_t{0u}}
    , decltype(_impl_.length_){0u}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_Dll::~ClientIncidentReport_EnvironmentData_Process_Dll() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_Dll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feature_.~RepeatedField();
  _impl_.path_.Destroy();
  if (this != internal_default_instance()) delete _impl_.image_headers_;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_Dll::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feature_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
      _impl_.image_headers_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.base_address_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_Dll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 base_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_base_address(&has_bits);
          _impl_.base_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid(val))) {
              _internal_add_feature(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_feature(), ptr, ctx, ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_Dll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional uint64 base_address = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_base_address(), target);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
  for (int i = 0, n = this->_internal_feature_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_feature(i), target);
  }

  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::image_headers(this),
        _Internal::image_headers(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_Dll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_feature_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_feature(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_headers_);
    }

    // optional uint64 base_address = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_base_address());
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_Dll*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process_Dll::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_Dll& from) {
  ClientIncidentReport_EnvironmentData_Process_Dll* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.feature_.MergeFrom(from._impl_.feature_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(
          from._internal_image_headers());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.base_address_ = from._impl_.base_address_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_Dll::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_Dll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_Dll::IsInitialized() const {
  if (_internal_has_image_headers()) {
    if (!_impl_.image_headers_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::InternalSwap(ClientIncidentReport_EnvironmentData_Process_Dll* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.feature_.InternalSwap(&other->_impl_.feature_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_Dll, _impl_.length_)
      + sizeof(ClientIncidentReport_EnvironmentData_Process_Dll::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_Dll, _impl_.image_headers_)>(
          reinterpret_cast<char*>(&_impl_.image_headers_),
          reinterpret_cast<char*>(&other->_impl_.image_headers_));
}

std::string ClientIncidentReport_EnvironmentData_Process_Dll::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification>()._impl_._has_bits_);
  static void set_has_file_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_byte_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_modified_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_export_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
}
ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modified_bytes_){}
    , decltype(_impl_.export_name_){}
    , decltype(_impl_.file_offset_){}
    , decltype(_impl_.byte_count_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.modified_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.modified_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_modified_bytes()) {
    _this->_impl_.modified_bytes_.Set(from._internal_modified_bytes(),
      _this->GetArenaForAllocation());
  }
  _impl_.export_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_export_name()) {
    _this->_impl_.export_name_.Set(from._internal_export_name(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.file_offset_, &from._impl_.file_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.byte_count_) -
    reinterpret_cast<char*>(&_impl_.file_offset_)) + sizeof(_impl_.byte_count_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modified_bytes_){}
    , decltype(_impl_.export_name_){}
    , decltype(_impl_.file_offset_){0u}
    , decltype(_impl_.byte_count_){0}
  };
  _impl_.modified_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.modified_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.export_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::~ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.modified_bytes_.Destroy();
  _impl_.export_name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.modified_bytes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.export_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.file_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.byte_count_) -
        reinterpret_cast<char*>(&_impl_.file_offset_)) + sizeof(_impl_.byte_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 file_offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_file_offset(&has_bits);
          _impl_.file_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 byte_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_byte_count(&has_bits);
          _impl_.byte_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes modified_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_modified_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string export_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_export_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 file_offset = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_file_offset(), target);
  }

  // optional int32 byte_count = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_byte_count(), target);
  }

  // optional bytes modified_bytes = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_modified_bytes(), target);
  }

  // optional string export_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_export_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes modified_bytes = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_modified_bytes());
    }

    // optional string export_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_export_name());
    }

    // optional uint32 file_offset = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_offset());
    }

    // optional int32 byte_count = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_byte_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from) {
  ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_modified_bytes(from._internal_modified_bytes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_export_name(from._internal_export_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.file_offset_ = from._impl_.file_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.byte_count_ = from._impl_.byte_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::InternalSwap(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.modified_bytes_, lhs_arena,
      &other->_impl_.modified_bytes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.export_name_, lhs_arena,
      &other->_impl_.export_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification, _impl_.byte_count_)
      + sizeof(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_impl_.byte_count_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification, _impl_.file_offset_)>(
          reinterpret_cast<char*>(&_impl_.file_offset_),
          reinterpret_cast<char*>(&other->_impl_.file_offset_));
}

std::string ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_ModuleState::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_ModuleState>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_modified_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
}
ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(const ClientIncidentReport_EnvironmentData_Process_ModuleState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process_ModuleState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_modified_export_){from._impl_.obsolete_modified_export_}
    , decltype(_impl_.modification_){from._impl_.modification_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.modified_state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.modified_state_ = from._impl_.modified_state_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_modified_export_){arena}
    , decltype(_impl_.modification_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.modified_state_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_ModuleState::~ClientIncidentReport_EnvironmentData_Process_ModuleState() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_modified_export_.~RepeatedPtrField();
  _impl_.modification_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_modified_export_.Clear();
  _impl_.modification_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.modified_state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_ModuleState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_IsValid(val))) {
            _internal_set_modified_state(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string OBSOLETE_modified_export = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_obsolete_modified_export();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modification(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_ModuleState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_modified_state(), target);
  }

  // repeated string OBSOLETE_modified_export = 3;
  for (int i = 0, n = this->_internal_obsolete_modified_export_size(); i < n; i++) {
    const auto& s = this->_internal_obsolete_modified_export(i);
    target = stream->WriteString(3, s, target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modification_size()); i < n; i++) {
    const auto& repfield = this->_internal_modification(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_ModuleState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string OBSOLETE_modified_export = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_modified_export_.size());
  for (int i = 0, n = _impl_.obsolete_modified_export_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.obsolete_modified_export_.Get(i));
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
  total_size += 1UL * this->_internal_modification_size();
  for (const auto& msg : this->_impl_.modification_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_modified_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_ModuleState*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState& from) {
  ClientIncidentReport_EnvironmentData_Process_ModuleState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.obsolete_modified_export_.MergeFrom(from._impl_.obsolete_modified_export_);
  _this->_impl_.modification_.MergeFrom(from._impl_.modification_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.modified_state_ = from._impl_.modified_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_ModuleState::IsInitialized() const {
  return true;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::InternalSwap(ClientIncidentReport_EnvironmentData_Process_ModuleState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.obsolete_modified_export_.InternalSwap(&other->_impl_.obsolete_modified_export_);
  _impl_.modification_.InternalSwap(&other->_impl_.modification_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.modified_state_, other->_impl_.modified_state_);
}

std::string ClientIncidentReport_EnvironmentData_Process_ModuleState::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData_Process::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chrome_update_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uptime_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_metrics_consent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_obsolete_extended_consent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_obsolete_field_trial_participant(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
}
ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(const ClientIncidentReport_EnvironmentData_Process& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData_Process* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_dlls_){from._impl_.obsolete_dlls_}
    , decltype(_impl_.patches_){from._impl_.patches_}
    , decltype(_impl_.network_providers_){from._impl_.network_providers_}
    , decltype(_impl_.dll_){from._impl_.dll_}
    , decltype(_impl_.blacklisted_dll_){from._impl_.blacklisted_dll_}
    , decltype(_impl_.module_state_){from._impl_.module_state_}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_msec_){}
    , decltype(_impl_.chrome_update_channel_){}
    , decltype(_impl_.metrics_consent_){}
    , decltype(_impl_.obsolete_extended_consent_){}
    , decltype(_impl_.obsolete_field_trial_participant_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.uptime_msec_, &from._impl_.uptime_msec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.obsolete_field_trial_participant_) -
    reinterpret_cast<char*>(&_impl_.uptime_msec_)) + sizeof(_impl_.obsolete_field_trial_participant_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
}

inline void ClientIncidentReport_EnvironmentData_Process::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obsolete_dlls_){arena}
    , decltype(_impl_.patches_){arena}
    , decltype(_impl_.network_providers_){arena}
    , decltype(_impl_.dll_){arena}
    , decltype(_impl_.blacklisted_dll_){arena}
    , decltype(_impl_.module_state_){arena}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_msec_){int64_t{0}}
    , decltype(_impl_.chrome_update_channel_){0}
    , decltype(_impl_.metrics_consent_){false}
    , decltype(_impl_.obsolete_extended_consent_){false}
    , decltype(_impl_.obsolete_field_trial_participant_){false}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process::~ClientIncidentReport_EnvironmentData_Process() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.obsolete_dlls_.~RepeatedPtrField();
  _impl_.patches_.~RepeatedPtrField();
  _impl_.network_providers_.~RepeatedPtrField();
  _impl_.dll_.~RepeatedPtrField();
  _impl_.blacklisted_dll_.~RepeatedPtrField();
  _impl_.module_state_.~RepeatedPtrField();
  _impl_.version_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.obsolete_dlls_.Clear();
  _impl_.patches_.Clear();
  _impl_.network_providers_.Clear();
  _impl_.dll_.Clear();
  _impl_.blacklisted_dll_.Clear();
  _impl_.module_state_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.uptime_msec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.obsolete_field_trial_participant_) -
        reinterpret_cast<char*>(&_impl_.uptime_msec_)) + sizeof(_impl_.obsolete_field_trial_participant_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string OBSOLETE_dlls = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_obsolete_dlls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_patches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_network_providers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Channel_IsValid(val))) {
            _internal_set_chrome_update_channel(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Channel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 uptime_msec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_uptime_msec(&has_bits);
          _impl_.uptime_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool metrics_consent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_metrics_consent(&has_bits);
          _impl_.metrics_consent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool OBSOLETE_extended_consent = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_obsolete_extended_consent(&has_bits);
          _impl_.obsolete_extended_consent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dll(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string blacklisted_dll = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_blacklisted_dll();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_module_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool OBSOLETE_field_trial_participant = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_obsolete_field_trial_participant(&has_bits);
          _impl_.obsolete_field_trial_participant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // repeated string OBSOLETE_dlls = 2;
  for (int i = 0, n = this->_internal_obsolete_dlls_size(); i < n; i++) {
    const auto& s = this->_internal_obsolete_dlls(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_patches_size()); i < n; i++) {
    const auto& repfield = this->_internal_patches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_network_providers_size()); i < n; i++) {
    const auto& repfield = this->_internal_network_providers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_chrome_update_channel(), target);
  }

  // optional int64 uptime_msec = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_uptime_msec(), target);
  }

  // optional bool metrics_consent = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_metrics_consent(), target);
  }

  // optional bool OBSOLETE_extended_consent = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_obsolete_extended_consent(), target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dll_size()); i < n; i++) {
    const auto& repfield = this->_internal_dll(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string blacklisted_dll = 10;
  for (int i = 0, n = this->_internal_blacklisted_dll_size(); i < n; i++) {
    const auto& s = this->_internal_blacklisted_dll(i);
    target = stream->WriteString(10, s, target);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_module_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_module_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool OBSOLETE_field_trial_participant = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_obsolete_field_trial_participant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  return target;
}

size_t ClientIncidentReport_EnvironmentData_Process::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string OBSOLETE_dlls = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_dlls_.size());
  for (int i = 0, n = _impl_.obsolete_dlls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.obsolete_dlls_.Get(i));
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
  total_size += 1UL * this->_internal_patches_size();
  for (const auto& msg : this->_impl_.patches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
  total_size += 1UL * this->_internal_network_providers_size();
  for (const auto& msg : this->_impl_.network_providers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
  total_size += 1UL * this->_internal_dll_size();
  for (const auto& msg : this->_impl_.dll_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string blacklisted_dll = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blacklisted_dll_.size());
  for (int i = 0, n = _impl_.blacklisted_dll_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.blacklisted_dll_.Get(i));
  }

  // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
  total_size += 1UL * this->_internal_module_state_size();
  for (const auto& msg : this->_impl_.module_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional int64 uptime_msec = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_msec());
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_chrome_update_channel());
    }

    // optional bool metrics_consent = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool OBSOLETE_extended_consent = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool OBSOLETE_field_trial_participant = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData_Process::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process*>(
      &from));
}

void ClientIncidentReport_EnvironmentData_Process::MergeFrom(const ClientIncidentReport_EnvironmentData_Process& from) {
  ClientIncidentReport_EnvironmentData_Process* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.obsolete_dlls_.MergeFrom(from._impl_.obsolete_dlls_);
  _this->_impl_.patches_.MergeFrom(from._impl_.patches_);
  _this->_impl_.network_providers_.MergeFrom(from._impl_.network_providers_);
  _this->_impl_.dll_.MergeFrom(from._impl_.dll_);
  _this->_impl_.blacklisted_dll_.MergeFrom(from._impl_.blacklisted_dll_);
  _this->_impl_.module_state_.MergeFrom(from._impl_.module_state_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.uptime_msec_ = from._impl_.uptime_msec_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.chrome_update_channel_ = from._impl_.chrome_update_channel_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.metrics_consent_ = from._impl_.metrics_consent_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.obsolete_extended_consent_ = from._impl_.obsolete_extended_consent_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.obsolete_field_trial_participant_ = from._impl_.obsolete_field_trial_participant_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process::CopyFrom(const ClientIncidentReport_EnvironmentData_Process& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.dll_))
    return false;
  return true;
}

void ClientIncidentReport_EnvironmentData_Process::InternalSwap(ClientIncidentReport_EnvironmentData_Process* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.obsolete_dlls_.InternalSwap(&other->_impl_.obsolete_dlls_);
  _impl_.patches_.InternalSwap(&other->_impl_.patches_);
  _impl_.network_providers_.InternalSwap(&other->_impl_.network_providers_);
  _impl_.dll_.InternalSwap(&other->_impl_.dll_);
  _impl_.blacklisted_dll_.InternalSwap(&other->_impl_.blacklisted_dll_);
  _impl_.module_state_.InternalSwap(&other->_impl_.module_state_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process, _impl_.obsolete_field_trial_participant_)
      + sizeof(ClientIncidentReport_EnvironmentData_Process::_impl_.obsolete_field_trial_participant_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process, _impl_.uptime_msec_)>(
          reinterpret_cast<char*>(&_impl_.uptime_msec_),
          reinterpret_cast<char*>(&other->_impl_.uptime_msec_));
}

std::string ClientIncidentReport_EnvironmentData_Process::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData.Process";
}


// ===================================================================

class ClientIncidentReport_EnvironmentData::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData>()._impl_._has_bits_);
  static const ::safe_browsing::ClientIncidentReport_EnvironmentData_OS& os(const ClientIncidentReport_EnvironmentData* msg);
  static void set_has_os(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine& machine(const ClientIncidentReport_EnvironmentData* msg);
  static void set_has_machine(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientIncidentReport_EnvironmentData_Process& process(const ClientIncidentReport_EnvironmentData* msg);
  static void set_has_process(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::ClientIncidentReport_EnvironmentData_OS&
ClientIncidentReport_EnvironmentData::_Internal::os(const ClientIncidentReport_EnvironmentData* msg) {
  return *msg->_impl_.os_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine&
ClientIncidentReport_EnvironmentData::_Internal::machine(const ClientIncidentReport_EnvironmentData* msg) {
  return *msg->_impl_.machine_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData_Process&
ClientIncidentReport_EnvironmentData::_Internal::process(const ClientIncidentReport_EnvironmentData* msg) {
  return *msg->_impl_.process_;
}
ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData)
}
ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(const ClientIncidentReport_EnvironmentData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_EnvironmentData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.os_){nullptr}
    , decltype(_impl_.machine_){nullptr}
    , decltype(_impl_.process_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_os()) {
    _this->_impl_.os_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_OS(*from._impl_.os_);
  }
  if (from._internal_has_machine()) {
    _this->_impl_.machine_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine(*from._impl_.machine_);
  }
  if (from._internal_has_process()) {
    _this->_impl_.process_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_Process(*from._impl_.process_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData)
}

inline void ClientIncidentReport_EnvironmentData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.os_){nullptr}
    , decltype(_impl_.machine_){nullptr}
    , decltype(_impl_.process_){nullptr}
  };
}

ClientIncidentReport_EnvironmentData::~ClientIncidentReport_EnvironmentData() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.os_;
  if (this != internal_default_instance()) delete _impl_.machine_;
  if (this != internal_default_instance()) delete _impl_.process_;
}

void ClientIncidentReport_EnvironmentData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.os_ != nullptr);
      _impl_.os_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.machine_ != nullptr);
      _impl_.machine_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.process_ != nullptr);
      _impl_.process_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_os(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_machine(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_process(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::os(this),
        _Internal::os(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::machine(this),
        _Internal::machine(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::process(this),
        _Internal::process(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData)
  return target;
}

size_t ClientIncidentReport_EnvironmentData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.os_);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.machine_);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.process_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_EnvironmentData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData*>(
      &from));
}

void ClientIncidentReport_EnvironmentData::MergeFrom(const ClientIncidentReport_EnvironmentData& from) {
  ClientIncidentReport_EnvironmentData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_os()->::safe_browsing::ClientIncidentReport_EnvironmentData_OS::MergeFrom(
          from._internal_os());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_machine()->::safe_browsing::ClientIncidentReport_EnvironmentData_Machine::MergeFrom(
          from._internal_machine());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_process()->::safe_browsing::ClientIncidentReport_EnvironmentData_Process::MergeFrom(
          from._internal_process());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData::CopyFrom(const ClientIncidentReport_EnvironmentData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData::IsInitialized() const {
  if (_internal_has_process()) {
    if (!_impl_.process_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport_EnvironmentData::InternalSwap(ClientIncidentReport_EnvironmentData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData, _impl_.process_)
      + sizeof(ClientIncidentReport_EnvironmentData::_impl_.process_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData, _impl_.os_)>(
          reinterpret_cast<char*>(&_impl_.os_),
          reinterpret_cast<char*>(&other->_impl_.os_));
}

std::string ClientIncidentReport_EnvironmentData::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.EnvironmentData";
}


// ===================================================================

class ClientIncidentReport_ExtensionData_ExtensionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_ExtensionData_ExtensionInfo>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_update_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_has_signature_validation(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_signature_is_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_installed_by_custodian(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_installed_by_default(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_installed_by_oem(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_from_bookmark(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_from_webstore(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_converted_from_user_script(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_may_be_untrusted(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_install_time_msec(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_manifest_location_type(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
}
ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(const ClientIncidentReport_ExtensionData_ExtensionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_ExtensionData_ExtensionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.update_url_){}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.has_signature_validation_){}
    , decltype(_impl_.signature_is_valid_){}
    , decltype(_impl_.installed_by_custodian_){}
    , decltype(_impl_.installed_by_default_){}
    , decltype(_impl_.installed_by_oem_){}
    , decltype(_impl_.from_bookmark_){}
    , decltype(_impl_.from_webstore_){}
    , decltype(_impl_.converted_from_user_script_){}
    , decltype(_impl_.install_time_msec_){}
    , decltype(_impl_.may_be_untrusted_){}
    , decltype(_impl_.manifest_location_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(),
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(),
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _this->_impl_.description_.Set(from._internal_description(),
      _this->GetArenaForAllocation());
  }
  _impl_.update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_update_url()) {
    _this->_impl_.update_url_.Set(from._internal_update_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manifest()) {
    _this->_impl_.manifest_.Set(from._internal_manifest(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manifest_location_type_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.manifest_location_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
}

inline void ClientIncidentReport_ExtensionData_ExtensionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.update_url_){}
    , decltype(_impl_.manifest_){}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.has_signature_validation_){false}
    , decltype(_impl_.signature_is_valid_){false}
    , decltype(_impl_.installed_by_custodian_){false}
    , decltype(_impl_.installed_by_default_){false}
    , decltype(_impl_.installed_by_oem_){false}
    , decltype(_impl_.from_bookmark_){false}
    , decltype(_impl_.from_webstore_){false}
    , decltype(_impl_.converted_from_user_script_){false}
    , decltype(_impl_.install_time_msec_){int64_t{0}}
    , decltype(_impl_.may_be_untrusted_){false}
    , decltype(_impl_.manifest_location_type_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.update_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_ExtensionData_ExtensionInfo::~ClientIncidentReport_ExtensionData_ExtensionInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_ExtensionData_ExtensionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.version_.Destroy();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.update_url_.Destroy();
  _impl_.manifest_.Destroy();
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.update_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.manifest_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.type_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.has_signature_validation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.converted_from_user_script_) -
        reinterpret_cast<char*>(&_impl_.has_signature_validation_)) + sizeof(_impl_.converted_from_user_script_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.install_time_msec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.manifest_location_type_) -
        reinterpret_cast<char*>(&_impl_.install_time_msec_)) + sizeof(_impl_.manifest_location_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_ExtensionData_ExtensionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_IsValid(val))) {
            _internal_set_state(static_cast<::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string update_url = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_update_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_signature_validation = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_has_signature_validation(&has_bits);
          _impl_.has_signature_validation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool signature_is_valid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_signature_is_valid(&has_bits);
          _impl_.signature_is_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool installed_by_custodian = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_installed_by_custodian(&has_bits);
          _impl_.installed_by_custodian_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool installed_by_default = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_installed_by_default(&has_bits);
          _impl_.installed_by_default_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool installed_by_oem = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_installed_by_oem(&has_bits);
          _impl_.installed_by_oem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool from_bookmark = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_from_bookmark(&has_bits);
          _impl_.from_bookmark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool from_webstore = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_from_webstore(&has_bits);
          _impl_.from_webstore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool converted_from_user_script = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_converted_from_user_script(&has_bits);
          _impl_.converted_from_user_script_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool may_be_untrusted = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_may_be_untrusted(&has_bits);
          _impl_.may_be_untrusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 install_time_msec = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_install_time_msec(&has_bits);
          _impl_.install_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 manifest_location_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_manifest_location_type(&has_bits);
          _impl_.manifest_location_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manifest = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_ExtensionData_ExtensionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_state(), target);
  }

  // optional int32 type = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_type(), target);
  }

  // optional string update_url = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_update_url(), target);
  }

  // optional bool has_signature_validation = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_has_signature_validation(), target);
  }

  // optional bool signature_is_valid = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_signature_is_valid(), target);
  }

  // optional bool installed_by_custodian = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_installed_by_custodian(), target);
  }

  // optional bool installed_by_default = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_installed_by_default(), target);
  }

  // optional bool installed_by_oem = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_installed_by_oem(), target);
  }

  // optional bool from_bookmark = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_from_bookmark(), target);
  }

  // optional bool from_webstore = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_from_webstore(), target);
  }

  // optional bool converted_from_user_script = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_converted_from_user_script(), target);
  }

  // optional bool may_be_untrusted = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_may_be_untrusted(), target);
  }

  // optional int64 install_time_msec = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_install_time_msec(), target);
  }

  // optional int32 manifest_location_type = 18;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_manifest_location_type(), target);
  }

  // optional string manifest = 19;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_manifest(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  return target;
}

size_t ClientIncidentReport_ExtensionData_ExtensionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string update_url = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_update_url());
    }

    // optional string manifest = 19;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manifest());
    }

    // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional int32 type = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool has_signature_validation = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool signature_is_valid = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool installed_by_custodian = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool installed_by_default = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool installed_by_oem = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool from_bookmark = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool from_webstore = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool converted_from_user_script = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional int64 install_time_msec = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_install_time_msec());
    }

    // optional bool may_be_untrusted = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional int32 manifest_location_type = 18;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_manifest_location_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_ExtensionData_ExtensionInfo*>(
      &from));
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::MergeFrom(const ClientIncidentReport_ExtensionData_ExtensionInfo& from) {
  ClientIncidentReport_ExtensionData_ExtensionInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_update_url(from._internal_update_url());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.has_signature_validation_ = from._impl_.has_signature_validation_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.signature_is_valid_ = from._impl_.signature_is_valid_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.installed_by_custodian_ = from._impl_.installed_by_custodian_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.installed_by_default_ = from._impl_.installed_by_default_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.installed_by_oem_ = from._impl_.installed_by_oem_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.from_bookmark_ = from._impl_.from_bookmark_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.from_webstore_ = from._impl_.from_webstore_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.converted_from_user_script_ = from._impl_.converted_from_user_script_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.install_time_msec_ = from._impl_.install_time_msec_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.may_be_untrusted_ = from._impl_.may_be_untrusted_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.manifest_location_type_ = from._impl_.manifest_location_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::CopyFrom(const ClientIncidentReport_ExtensionData_ExtensionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_ExtensionData_ExtensionInfo::IsInitialized() const {
  return true;
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::InternalSwap(ClientIncidentReport_ExtensionData_ExtensionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.update_url_, lhs_arena,
      &other->_impl_.update_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.manifest_, lhs_arena,
      &other->_impl_.manifest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport_ExtensionData_ExtensionInfo, _impl_.manifest_location_type_)
      + sizeof(ClientIncidentReport_ExtensionData_ExtensionInfo::_impl_.manifest_location_type_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_ExtensionData_ExtensionInfo, _impl_.state_)>(
          reinterpret_cast<char*>(&_impl_.state_),
          reinterpret_cast<char*>(&other->_impl_.state_));
}

std::string ClientIncidentReport_ExtensionData_ExtensionInfo::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo";
}


// ===================================================================

class ClientIncidentReport_ExtensionData::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_ExtensionData>()._impl_._has_bits_);
  static const ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo& last_installed_extension(const ClientIncidentReport_ExtensionData* msg);
  static void set_has_last_installed_extension(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo&
ClientIncidentReport_ExtensionData::_Internal::last_installed_extension(const ClientIncidentReport_ExtensionData* msg) {
  return *msg->_impl_.last_installed_extension_;
}
ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.ExtensionData)
}
ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(const ClientIncidentReport_ExtensionData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_ExtensionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.last_installed_extension_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_last_installed_extension()) {
    _this->_impl_.last_installed_extension_ = new ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo(*from._impl_.last_installed_extension_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.ExtensionData)
}

inline void ClientIncidentReport_ExtensionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.last_installed_extension_){nullptr}
  };
}

ClientIncidentReport_ExtensionData::~ClientIncidentReport_ExtensionData() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.ExtensionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_ExtensionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.last_installed_extension_;
}

void ClientIncidentReport_ExtensionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_ExtensionData::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.ExtensionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.last_installed_extension_ != nullptr);
    _impl_.last_installed_extension_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_ExtensionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_installed_extension(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_ExtensionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.ExtensionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::last_installed_extension(this),
        _Internal::last_installed_extension(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.ExtensionData)
  return target;
}

size_t ClientIncidentReport_ExtensionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.ExtensionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.last_installed_extension_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_ExtensionData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_ExtensionData*>(
      &from));
}

void ClientIncidentReport_ExtensionData::MergeFrom(const ClientIncidentReport_ExtensionData& from) {
  ClientIncidentReport_ExtensionData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.ExtensionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_last_installed_extension()) {
    _this->_internal_mutable_last_installed_extension()->::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo::MergeFrom(
        from._internal_last_installed_extension());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_ExtensionData::CopyFrom(const ClientIncidentReport_ExtensionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.ExtensionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_ExtensionData::IsInitialized() const {
  return true;
}

void ClientIncidentReport_ExtensionData::InternalSwap(ClientIncidentReport_ExtensionData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.last_installed_extension_, other->_impl_.last_installed_extension_);
}

std::string ClientIncidentReport_ExtensionData::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.ExtensionData";
}


// ===================================================================

class ClientIncidentReport_NonBinaryDownloadDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport_NonBinaryDownloadDetails>()._impl_._has_bits_);
  static void set_has_file_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url_spec_sha256(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
}
ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(const ClientIncidentReport_NonBinaryDownloadDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport_NonBinaryDownloadDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_type_){}
    , decltype(_impl_.url_spec_sha256_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.length_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.file_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_type()) {
    _this->_impl_.file_type_.Set(from._internal_file_type(),
      _this->GetArenaForAllocation());
  }
  _impl_.url_spec_sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_spec_sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_spec_sha256()) {
    _this->_impl_.url_spec_sha256_.Set(from._internal_url_spec_sha256(),
      _this->GetArenaForAllocation());
  }
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    _this->_impl_.host_.Set(from._internal_host(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.length_ = from._impl_.length_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
}

inline void ClientIncidentReport_NonBinaryDownloadDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_type_){}
    , decltype(_impl_.url_spec_sha256_){}
    , decltype(_impl_.host_){}
    , decltype(_impl_.length_){int64_t{0}}
  };
  _impl_.file_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_spec_sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_spec_sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_NonBinaryDownloadDetails::~ClientIncidentReport_NonBinaryDownloadDetails() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport_NonBinaryDownloadDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.file_type_.Destroy();
  _impl_.url_spec_sha256_.Destroy();
  _impl_.host_.Destroy();
}

void ClientIncidentReport_NonBinaryDownloadDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_NonBinaryDownloadDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.file_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_spec_sha256_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.length_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_NonBinaryDownloadDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string file_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_file_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes url_spec_sha256 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url_spec_sha256();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string host = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_NonBinaryDownloadDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string file_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file_type(), target);
  }

  // optional bytes url_spec_sha256 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_url_spec_sha256(), target);
  }

  // optional string host = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_host(), target);
  }

  // optional int64 length = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  return target;
}

size_t ClientIncidentReport_NonBinaryDownloadDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string file_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_type());
    }

    // optional bytes url_spec_sha256 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_url_spec_sha256());
    }

    // optional string host = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host());
    }

    // optional int64 length = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport_NonBinaryDownloadDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_NonBinaryDownloadDetails*>(
      &from));
}

void ClientIncidentReport_NonBinaryDownloadDetails::MergeFrom(const ClientIncidentReport_NonBinaryDownloadDetails& from) {
  ClientIncidentReport_NonBinaryDownloadDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_file_type(from._internal_file_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url_spec_sha256(from._internal_url_spec_sha256());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_host(from._internal_host());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_NonBinaryDownloadDetails::CopyFrom(const ClientIncidentReport_NonBinaryDownloadDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport_NonBinaryDownloadDetails::IsInitialized() const {
  return true;
}

void ClientIncidentReport_NonBinaryDownloadDetails::InternalSwap(ClientIncidentReport_NonBinaryDownloadDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_type_, lhs_arena,
      &other->_impl_.file_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_spec_sha256_, lhs_arena,
      &other->_impl_.url_spec_sha256_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_, lhs_arena,
      &other->_impl_.host_, rhs_arena
  );
  swap(_impl_.length_, other->_impl_.length_);
}

std::string ClientIncidentReport_NonBinaryDownloadDetails::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails";
}


// ===================================================================

class ClientIncidentReport::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentReport>()._impl_._has_bits_);
  static const ::safe_browsing::ClientIncidentReport_DownloadDetails& download(const ClientIncidentReport* msg);
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientIncidentReport_EnvironmentData& environment(const ClientIncidentReport* msg);
  static void set_has_environment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ChromeUserPopulation& population(const ClientIncidentReport* msg);
  static void set_has_population(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientIncidentReport_ExtensionData& extension_data(const ClientIncidentReport* msg);
  static void set_has_extension_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails& non_binary_download(const ClientIncidentReport* msg);
  static void set_has_non_binary_download(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::safe_browsing::ClientIncidentReport_DownloadDetails&
ClientIncidentReport::_Internal::download(const ClientIncidentReport* msg) {
  return *msg->_impl_.download_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData&
ClientIncidentReport::_Internal::environment(const ClientIncidentReport* msg) {
  return *msg->_impl_.environment_;
}
const ::safe_browsing::ChromeUserPopulation&
ClientIncidentReport::_Internal::population(const ClientIncidentReport* msg) {
  return *msg->_impl_.population_;
}
const ::safe_browsing::ClientIncidentReport_ExtensionData&
ClientIncidentReport::_Internal::extension_data(const ClientIncidentReport* msg) {
  return *msg->_impl_.extension_data_;
}
const ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails&
ClientIncidentReport::_Internal::non_binary_download(const ClientIncidentReport* msg) {
  return *msg->_impl_.non_binary_download_;
}
ClientIncidentReport::ClientIncidentReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport)
}
ClientIncidentReport::ClientIncidentReport(const ClientIncidentReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentReport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incident_){from._impl_.incident_}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.environment_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.extension_data_){nullptr}
    , decltype(_impl_.non_binary_download_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_download()) {
    _this->_impl_.download_ = new ::safe_browsing::ClientIncidentReport_DownloadDetails(*from._impl_.download_);
  }
  if (from._internal_has_environment()) {
    _this->_impl_.environment_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData(*from._impl_.environment_);
  }
  if (from._internal_has_population()) {
    _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
  }
  if (from._internal_has_extension_data()) {
    _this->_impl_.extension_data_ = new ::safe_browsing::ClientIncidentReport_ExtensionData(*from._impl_.extension_data_);
  }
  if (from._internal_has_non_binary_download()) {
    _this->_impl_.non_binary_download_ = new ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails(*from._impl_.non_binary_download_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport)
}

inline void ClientIncidentReport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incident_){arena}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.environment_){nullptr}
    , decltype(_impl_.population_){nullptr}
    , decltype(_impl_.extension_data_){nullptr}
    , decltype(_impl_.non_binary_download_){nullptr}
  };
}

ClientIncidentReport::~ClientIncidentReport() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.incident_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.download_;
  if (this != internal_default_instance()) delete _impl_.environment_;
  if (this != internal_default_instance()) delete _impl_.population_;
  if (this != internal_default_instance()) delete _impl_.extension_data_;
  if (this != internal_default_instance()) delete _impl_.non_binary_download_;
}

void ClientIncidentReport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentReport::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.incident_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.download_ != nullptr);
      _impl_.download_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.environment_ != nullptr);
      _impl_.environment_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.population_ != nullptr);
      _impl_.population_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.extension_data_ != nullptr);
      _impl_.extension_data_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.non_binary_download_ != nullptr);
      _impl_.non_binary_download_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incident(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_environment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeUserPopulation population = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_extension_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_non_binary_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incident_size()); i < n; i++) {
    const auto& repfield = this->_internal_incident(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::download(this),
        _Internal::download(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::environment(this),
        _Internal::environment(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ChromeUserPopulation population = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::population(this),
        _Internal::population(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::extension_data(this),
        _Internal::extension_data(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::non_binary_download(this),
        _Internal::non_binary_download(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport)
  return target;
}

size_t ClientIncidentReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
  total_size += 1UL * this->_internal_incident_size();
  for (const auto& msg : this->_impl_.incident_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.download_);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.environment_);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.population_);
    }

    // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.extension_data_);
    }

    // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.non_binary_download_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentReport*>(
      &from));
}

void ClientIncidentReport::MergeFrom(const ClientIncidentReport& from) {
  ClientIncidentReport* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.incident_.MergeFrom(from._impl_.incident_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_download()->::safe_browsing::ClientIncidentReport_DownloadDetails::MergeFrom(
          from._internal_download());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_environment()->::safe_browsing::ClientIncidentReport_EnvironmentData::MergeFrom(
          from._internal_environment());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(
          from._internal_population());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_extension_data()->::safe_browsing::ClientIncidentReport_ExtensionData::MergeFrom(
          from._internal_extension_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_non_binary_download()->::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails::MergeFrom(
          from._internal_non_binary_download());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport::CopyFrom(const ClientIncidentReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentReport::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.incident_))
    return false;
  if (_internal_has_download()) {
    if (!_impl_.download_->IsInitialized()) return false;
  }
  if (_internal_has_environment()) {
    if (!_impl_.environment_->IsInitialized()) return false;
  }
  return true;
}

void ClientIncidentReport::InternalSwap(ClientIncidentReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.incident_.InternalSwap(&other->_impl_.incident_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientIncidentReport, _impl_.non_binary_download_)
      + sizeof(ClientIncidentReport::_impl_.non_binary_download_)
      - PROTOBUF_FIELD_OFFSET(ClientIncidentReport, _impl_.download_)>(
          reinterpret_cast<char*>(&_impl_.download_),
          reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string ClientIncidentReport::GetTypeName() const {
  return "safe_browsing.ClientIncidentReport";
}


// ===================================================================

class ClientIncidentResponse_EnvironmentRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentResponse_EnvironmentRequest>()._impl_._has_bits_);
  static void set_has_dll_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
}
ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(const ClientIncidentResponse_EnvironmentRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentResponse_EnvironmentRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dll_index_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.dll_index_ = from._impl_.dll_index_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
}

inline void ClientIncidentResponse_EnvironmentRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dll_index_){0}
  };
}

ClientIncidentResponse_EnvironmentRequest::~ClientIncidentResponse_EnvironmentRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentResponse_EnvironmentRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientIncidentResponse_EnvironmentRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentResponse_EnvironmentRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dll_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentResponse_EnvironmentRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dll_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dll_index(&has_bits);
          _impl_.dll_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentResponse_EnvironmentRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dll_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dll_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  return target;
}

size_t ClientIncidentResponse_EnvironmentRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 dll_index = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dll_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentResponse_EnvironmentRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentResponse_EnvironmentRequest*>(
      &from));
}

void ClientIncidentResponse_EnvironmentRequest::MergeFrom(const ClientIncidentResponse_EnvironmentRequest& from) {
  ClientIncidentResponse_EnvironmentRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_dll_index()) {
    _this->_internal_set_dll_index(from._internal_dll_index());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentResponse_EnvironmentRequest::CopyFrom(const ClientIncidentResponse_EnvironmentRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentResponse_EnvironmentRequest::IsInitialized() const {
  return true;
}

void ClientIncidentResponse_EnvironmentRequest::InternalSwap(ClientIncidentResponse_EnvironmentRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.dll_index_, other->_impl_.dll_index_);
}

std::string ClientIncidentResponse_EnvironmentRequest::GetTypeName() const {
  return "safe_browsing.ClientIncidentResponse.EnvironmentRequest";
}


// ===================================================================

class ClientIncidentResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientIncidentResponse>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_download_requested(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientIncidentResponse::ClientIncidentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentResponse)
}
ClientIncidentResponse::ClientIncidentResponse(const ClientIncidentResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientIncidentResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.environment_requests_){from._impl_.environment_requests_}
    , decltype(_impl_.token_){}
    , decltype(_impl_.download_requested_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.download_requested_ = from._impl_.download_requested_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentResponse)
}

inline void ClientIncidentResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.environment_requests_){arena}
    , decltype(_impl_.token_){}
    , decltype(_impl_.download_requested_){false}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentResponse::~ClientIncidentResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientIncidentResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.environment_requests_.~RepeatedPtrField();
  _impl_.token_.Destroy();
}

void ClientIncidentResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientIncidentResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.environment_requests_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.token_.ClearNonDefaultToEmpty();
  }
  _impl_.download_requested_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool download_requested = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_download_requested(&has_bits);
          _impl_.download_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_environment_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional bool download_requested = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_download_requested(), target);
  }

  // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_environment_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_environment_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentResponse)
  return target;
}

size_t ClientIncidentResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
  total_size += 1UL * this->_internal_environment_requests_size();
  for (const auto& msg : this->_impl_.environment_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional bool download_requested = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientIncidentResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientIncidentResponse*>(
      &from));
}

void ClientIncidentResponse::MergeFrom(const ClientIncidentResponse& from) {
  ClientIncidentResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.environment_requests_.MergeFrom(from._impl_.environment_requests_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.download_requested_ = from._impl_.download_requested_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentResponse::CopyFrom(const ClientIncidentResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientIncidentResponse::IsInitialized() const {
  return true;
}

void ClientIncidentResponse::InternalSwap(ClientIncidentResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.environment_requests_.InternalSwap(&other->_impl_.environment_requests_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  swap(_impl_.download_requested_, other->_impl_.download_requested_);
}

std::string ClientIncidentResponse::GetTypeName() const {
  return "safe_browsing.ClientIncidentResponse";
}


// ===================================================================

class DownloadMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<DownloadMetadata>()._impl_._has_bits_);
  static void set_has_download_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ClientIncidentReport_DownloadDetails& download(const DownloadMetadata* msg);
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::ClientIncidentReport_DownloadDetails&
DownloadMetadata::_Internal::download(const DownloadMetadata* msg) {
  return *msg->_impl_.download_;
}
DownloadMetadata::DownloadMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.DownloadMetadata)
}
DownloadMetadata::DownloadMetadata(const DownloadMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DownloadMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.download_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_download()) {
    _this->_impl_.download_ = new ::safe_browsing::ClientIncidentReport_DownloadDetails(*from._impl_.download_);
  }
  _this->_impl_.download_id_ = from._impl_.download_id_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.DownloadMetadata)
}

inline void DownloadMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.download_){nullptr}
    , decltype(_impl_.download_id_){0u}
  };
}

DownloadMetadata::~DownloadMetadata() {
  // @@protoc_insertion_point(destructor:safe_browsing.DownloadMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.download_;
}

void DownloadMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownloadMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.DownloadMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.download_ != nullptr);
    _impl_.download_->Clear();
  }
  _impl_.download_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 download_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_download_id(&has_bits);
          _impl_.download_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DownloadMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 download_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_download_id(), target);
  }

  // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::download(this),
        _Internal::download(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DownloadMetadata)
  return target;
}

size_t DownloadMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.DownloadMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.download_);
    }

    // optional uint32 download_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_download_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadMetadata*>(
      &from));
}

void DownloadMetadata::MergeFrom(const DownloadMetadata& from) {
  DownloadMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DownloadMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_download()->::safe_browsing::ClientIncidentReport_DownloadDetails::MergeFrom(
          from._internal_download());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.download_id_ = from._impl_.download_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadMetadata::CopyFrom(const DownloadMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DownloadMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadMetadata::IsInitialized() const {
  if (_internal_has_download()) {
    if (!_impl_.download_->IsInitialized()) return false;
  }
  return true;
}

void DownloadMetadata::InternalSwap(DownloadMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DownloadMetadata, _impl_.download_id_)
      + sizeof(DownloadMetadata::_impl_.download_id_)
      - PROTOBUF_FIELD_OFFSET(DownloadMetadata, _impl_.download_)>(
          reinterpret_cast<char*>(&_impl_.download_),
          reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string DownloadMetadata::GetTypeName() const {
  return "safe_browsing.DownloadMetadata";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPHeader>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
}
ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(const ClientSafeBrowsingReportRequest_HTTPHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_HTTPHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
}

inline void ClientSafeBrowsingReportRequest_HTTPHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPHeader::~ClientSafeBrowsingReportRequest_HTTPHeader() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  size_t total_size = 0;

  // required bytes name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes value = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPHeader*>(
      &from));
}

void ClientSafeBrowsingReportRequest_HTTPHeader::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPHeader& from) {
  ClientSafeBrowsingReportRequest_HTTPHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPHeader::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPHeader::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClientSafeBrowsingReportRequest_HTTPHeader::InternalSwap(ClientSafeBrowsingReportRequest_HTTPHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string ClientSafeBrowsingReportRequest_HTTPHeader::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine>()._impl_._has_bits_);
  static void set_has_verb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
}
ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.verb_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.verb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_verb()) {
    _this->_impl_.verb_.Set(from._internal_verb(),
      _this->GetArenaForAllocation());
  }
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uri()) {
    _this->_impl_.uri_.Set(from._internal_uri(),
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.verb_){}
    , decltype(_impl_.uri_){}
    , decltype(_impl_.version_){}
  };
  _impl_.verb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uri_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::~ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.verb_.Destroy();
  _impl_.uri_.Destroy();
  _impl_.version_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.verb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.uri_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes verb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_verb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes uri = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uri();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes verb = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_verb(), target);
  }

  // optional bytes uri = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_uri(), target);
  }

  // optional bytes version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes verb = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_verb());
    }

    // optional bytes uri = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uri());
    }

    // optional bytes version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine*>(
      &from));
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from) {
  ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_verb(from._internal_verb());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_uri(from._internal_uri());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_version(from._internal_version());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::IsInitialized() const {
  return true;
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::InternalSwap(ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verb_, lhs_arena,
      &other->_impl_.verb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uri_, lhs_arena,
      &other->_impl_.uri_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
}

std::string ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPRequest>()._impl_._has_bits_);
  static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& firstline(const ClientSafeBrowsingReportRequest_HTTPRequest* msg);
  static void set_has_firstline(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bodydigest(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bodylength(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine&
ClientSafeBrowsingReportRequest_HTTPRequest::_Internal::firstline(const ClientSafeBrowsingReportRequest_HTTPRequest* msg) {
  return *msg->_impl_.firstline_;
}
ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
}
ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(const ClientSafeBrowsingReportRequest_HTTPRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_HTTPRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){from._impl_.headers_}
    , decltype(_impl_.body_){}
    , decltype(_impl_.bodydigest_){}
    , decltype(_impl_.firstline_){nullptr}
    , decltype(_impl_.bodylength_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(),
      _this->GetArenaForAllocation());
  }
  _impl_.bodydigest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bodydigest()) {
    _this->_impl_.bodydigest_.Set(from._internal_bodydigest(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_firstline()) {
    _this->_impl_.firstline_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(*from._impl_.firstline_);
  }
  _this->_impl_.bodylength_ = from._impl_.bodylength_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){arena}
    , decltype(_impl_.body_){}
    , decltype(_impl_.bodydigest_){}
    , decltype(_impl_.firstline_){nullptr}
    , decltype(_impl_.bodylength_){0}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bodydigest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPRequest::~ClientSafeBrowsingReportRequest_HTTPRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
  _impl_.body_.Destroy();
  _impl_.bodydigest_.Destroy();
  if (this != internal_default_instance()) delete _impl_.firstline_;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bodydigest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.firstline_ != nullptr);
      _impl_.firstline_->Clear();
    }
  }
  _impl_.bodylength_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_firstline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bodydigest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bodydigest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bodylength = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bodylength(&has_bits);
          _impl_.bodylength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::firstline(this),
        _Internal::firstline(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_body(), target);
  }

  // optional bytes bodydigest = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_bodydigest(), target);
  }

  // optional int32 bodylength = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bodylength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional bytes bodydigest = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bodydigest());
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.firstline_);
    }

    // optional int32 bodylength = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bodylength());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPRequest*>(
      &from));
}

void ClientSafeBrowsingReportRequest_HTTPRequest::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPRequest& from) {
  ClientSafeBrowsingReportRequest_HTTPRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bodydigest(from._internal_bodydigest());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_firstline()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::MergeFrom(
          from._internal_firstline());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bodylength_ = from._impl_.bodylength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPRequest::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.headers_))
    return false;
  return true;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::InternalSwap(ClientSafeBrowsingReportRequest_HTTPRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bodydigest_, lhs_arena,
      &other->_impl_.bodydigest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPRequest, _impl_.bodylength_)
      + sizeof(ClientSafeBrowsingReportRequest_HTTPRequest::_impl_.bodylength_)
      - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPRequest, _impl_.firstline_)>(
          reinterpret_cast<char*>(&_impl_.firstline_),
          reinterpret_cast<char*>(&other->_impl_.firstline_));
}

std::string ClientSafeBrowsingReportRequest_HTTPRequest::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine>()._impl_._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
}
ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(),
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(),
      _this->GetArenaForAllocation());
  }
  _this->_impl_.code_ = from._impl_.code_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.code_){0}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::~ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.version_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.code_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_code(&has_bits);
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 code = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional bytes version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional bytes version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_version());
    }

    // optional int32 code = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine*>(
      &from));
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from) {
  ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.code_ = from._impl_.code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::IsInitialized() const {
  return true;
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::InternalSwap(ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  swap(_impl_.code_, other->_impl_.code_);
}

std::string ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPResponse>()._impl_._has_bits_);
  static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& firstline(const ClientSafeBrowsingReportRequest_HTTPResponse* msg);
  static void set_has_firstline(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bodydigest(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bodylength(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_remote_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine&
ClientSafeBrowsingReportRequest_HTTPResponse::_Internal::firstline(const ClientSafeBrowsingReportRequest_HTTPResponse* msg) {
  return *msg->_impl_.firstline_;
}
ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
}
ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(const ClientSafeBrowsingReportRequest_HTTPResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_HTTPResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){from._impl_.headers_}
    , decltype(_impl_.body_){}
    , decltype(_impl_.bodydigest_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.firstline_){nullptr}
    , decltype(_impl_.bodylength_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(),
      _this->GetArenaForAllocation());
  }
  _impl_.bodydigest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bodydigest()) {
    _this->_impl_.bodydigest_.Set(from._internal_bodydigest(),
      _this->GetArenaForAllocation());
  }
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_ip()) {
    _this->_impl_.remote_ip_.Set(from._internal_remote_ip(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_firstline()) {
    _this->_impl_.firstline_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(*from._impl_.firstline_);
  }
  _this->_impl_.bodylength_ = from._impl_.bodylength_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){arena}
    , decltype(_impl_.body_){}
    , decltype(_impl_.bodydigest_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.firstline_){nullptr}
    , decltype(_impl_.bodylength_){0}
  };
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bodydigest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPResponse::~ClientSafeBrowsingReportRequest_HTTPResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
  _impl_.body_.Destroy();
  _impl_.bodydigest_.Destroy();
  _impl_.remote_ip_.Destroy();
  if (this != internal_default_instance()) delete _impl_.firstline_;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bodydigest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.remote_ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.firstline_ != nullptr);
      _impl_.firstline_->Clear();
    }
  }
  _impl_.bodylength_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_firstline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bodydigest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bodydigest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bodylength = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bodylength(&has_bits);
          _impl_.bodylength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes remote_ip = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_remote_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::firstline(this),
        _Internal::firstline(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes body = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_body(), target);
  }

  // optional bytes bodydigest = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_bodydigest(), target);
  }

  // optional int32 bodylength = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bodylength(), target);
  }

  // optional bytes remote_ip = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_remote_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_body());
    }

    // optional bytes bodydigest = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bodydigest());
    }

    // optional bytes remote_ip = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_remote_ip());
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.firstline_);
    }

    // optional int32 bodylength = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bodylength());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPResponse*>(
      &from));
}

void ClientSafeBrowsingReportRequest_HTTPResponse::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPResponse& from) {
  ClientSafeBrowsingReportRequest_HTTPResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bodydigest(from._internal_bodydigest());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_remote_ip(from._internal_remote_ip());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_firstline()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::MergeFrom(
          from._internal_firstline());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bodylength_ = from._impl_.bodylength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPResponse::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPResponse::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.headers_))
    return false;
  return true;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::InternalSwap(ClientSafeBrowsingReportRequest_HTTPResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bodydigest_, lhs_arena,
      &other->_impl_.bodydigest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_ip_, lhs_arena,
      &other->_impl_.remote_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPResponse, _impl_.bodylength_)
      + sizeof(ClientSafeBrowsingReportRequest_HTTPResponse::_impl_.bodylength_)
      - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPResponse, _impl_.firstline_)>(
          reinterpret_cast<char*>(&_impl_.firstline_),
          reinterpret_cast<char*>(&other->_impl_.firstline_));
}

std::string ClientSafeBrowsingReportRequest_HTTPResponse::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_Resource::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_Resource>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest& request(const ClientSafeBrowsingReportRequest_Resource* msg);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse& response(const ClientSafeBrowsingReportRequest_Resource* msg);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_parent_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tag_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest&
ClientSafeBrowsingReportRequest_Resource::_Internal::request(const ClientSafeBrowsingReportRequest_Resource* msg) {
  return *msg->_impl_.request_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse&
ClientSafeBrowsingReportRequest_Resource::_Internal::response(const ClientSafeBrowsingReportRequest_Resource* msg) {
  return *msg->_impl_.response_;
}
ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
}
ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(const ClientSafeBrowsingReportRequest_Resource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_Resource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_ids_){from._impl_.child_ids_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.tag_name_){}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.parent_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.tag_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag_name()) {
    _this->_impl_.tag_name_.Set(from._internal_tag_name(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_request()) {
    _this->_impl_.request_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest(*from._impl_.request_);
  }
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse(*from._impl_.response_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.parent_id_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.parent_id_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
}

inline void ClientSafeBrowsingReportRequest_Resource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_ids_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.tag_name_){}
    , decltype(_impl_.request_){nullptr}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.parent_id_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tag_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_Resource::~ClientSafeBrowsingReportRequest_Resource() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_Resource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.child_ids_.~RepeatedField();
  _impl_.url_.Destroy();
  _impl_.tag_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.request_;
  if (this != internal_default_instance()) delete _impl_.response_;
}

void ClientSafeBrowsingReportRequest_Resource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_Resource::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.child_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tag_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.request_ != nullptr);
      _impl_.request_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.response_ != nullptr);
      _impl_.response_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.parent_id_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.parent_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_Resource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 parent_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_parent_id(&has_bits);
          _impl_.parent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 child_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_tag_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_Resource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::request(this),
        _Internal::request(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // optional int32 parent_id = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_parent_id(), target);
  }

  // repeated int32 child_ids = 6;
  for (int i = 0, n = this->_internal_child_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_child_ids(i), target);
  }

  // optional string tag_name = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_tag_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  return target;
}

size_t ClientSafeBrowsingReportRequest_Resource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  size_t total_size = 0;

  // required int32 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 child_ids = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.child_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_child_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string url = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string tag_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag_name());
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_);
    }

  }
  // optional int32 parent_id = 5;
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_Resource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_Resource*>(
      &from));
}

void ClientSafeBrowsingReportRequest_Resource::MergeFrom(const ClientSafeBrowsingReportRequest_Resource& from) {
  ClientSafeBrowsingReportRequest_Resource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tag_name(from._internal_tag_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_request()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest::MergeFrom(
          from._internal_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_response()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse::MergeFrom(
          from._internal_response());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.parent_id_ = from._impl_.parent_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_Resource::CopyFrom(const ClientSafeBrowsingReportRequest_Resource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_Resource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_request()) {
    if (!_impl_.request_->IsInitialized()) return false;
  }
  if (_internal_has_response()) {
    if (!_impl_.response_->IsInitialized()) return false;
  }
  return true;
}

void ClientSafeBrowsingReportRequest_Resource::InternalSwap(ClientSafeBrowsingReportRequest_Resource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_name_, lhs_arena,
      &other->_impl_.tag_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_Resource, _impl_.parent_id_)
      + sizeof(ClientSafeBrowsingReportRequest_Resource::_impl_.parent_id_)
      - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_Resource, _impl_.request_)>(
          reinterpret_cast<char*>(&_impl_.request_),
          reinterpret_cast<char*>(&other->_impl_.request_));
}

std::string ClientSafeBrowsingReportRequest_Resource::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.Resource";
}


// ===================================================================

class ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties>()._impl_._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_google_play_services_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_instant_apps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_url_api_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
}
ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.google_play_services_version_){}
    , decltype(_impl_.is_instant_apps_){}
    , decltype(_impl_.url_api_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_version()) {
    _this->_impl_.client_version_.Set(from._internal_client_version(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.google_play_services_version_, &from._impl_.google_play_services_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.url_api_type_) -
    reinterpret_cast<char*>(&_impl_.google_play_services_version_)) + sizeof(_impl_.url_api_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
}

inline void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.google_play_services_version_){int64_t{0}}
    , decltype(_impl_.is_instant_apps_){false}
    , decltype(_impl_.url_api_type_){0}
  };
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::~ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_version_.Destroy();
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.client_version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.google_play_services_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.url_api_type_) -
        reinterpret_cast<char*>(&_impl_.google_play_services_version_)) + sizeof(_impl_.url_api_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 google_play_services_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_google_play_services_version(&has_bits);
          _impl_.google_play_services_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_instant_apps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_instant_apps(&has_bits);
          _impl_.is_instant_apps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_IsValid(val))) {
            _internal_set_url_api_type(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_version(), target);
  }

  // optional int64 google_play_services_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_google_play_services_version(), target);
  }

  // optional bool is_instant_apps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_instant_apps(), target);
  }

  // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_url_api_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  return target;
}

size_t ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string client_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_version());
    }

    // optional int64 google_play_services_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_google_play_services_version());
    }

    // optional bool is_instant_apps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_url_api_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties*>(
      &from));
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::MergeFrom(const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from) {
  ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.google_play_services_version_ = from._impl_.google_play_services_version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_instant_apps_ = from._impl_.is_instant_apps_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.url_api_type_ = from._impl_.url_api_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::CopyFrom(const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::IsInitialized() const {
  return true;
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::InternalSwap(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_version_, lhs_arena,
      &other->_impl_.client_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties, _impl_.url_api_type_)
      + sizeof(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_impl_.url_api_type_)
      - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties, _impl_.google_play_services_version_)>(
          reinterpret_cast<char*>(&_impl_.google_play_services_version_),
          reinterpret_cast<char*>(&other->_impl_.google_play_services_version_));
}

std::string ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties";
}


// ===================================================================

class ClientSafeBrowsingReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_download_verdict(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_page_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_complete(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_client_country(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_did_proceed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_repeat_visit(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& client_properties(const ClientSafeBrowsingReportRequest* msg);
  static void set_has_client_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_show_download_in_folder(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties&
ClientSafeBrowsingReportRequest::_Internal::client_properties(const ClientSafeBrowsingReportRequest* msg) {
  return *msg->_impl_.client_properties_;
}
ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest)
}
ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(const ClientSafeBrowsingReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientSafeBrowsingReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){from._impl_.resources_}
    , decltype(_impl_.client_asn_){from._impl_.client_asn_}
    , decltype(_impl_.dom_){from._impl_.dom_}
    , decltype(_impl_.url_){}
    , decltype(_impl_.page_url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.client_country_){}
    , decltype(_impl_.token_){}
    , decltype(_impl_.client_properties_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.complete_){}
    , decltype(_impl_.did_proceed_){}
    , decltype(_impl_.repeat_visit_){}
    , decltype(_impl_.show_download_in_folder_){}
    , decltype(_impl_.download_verdict_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.page_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_page_url()) {
    _this->_impl_.page_url_.Set(from._internal_page_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer_url()) {
    _this->_impl_.referrer_url_.Set(from._internal_referrer_url(),
      _this->GetArenaForAllocation());
  }
  _impl_.client_country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_country()) {
    _this->_impl_.client_country_.Set(from._internal_client_country(),
      _this->GetArenaForAllocation());
  }
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_client_properties()) {
    _this->_impl_.client_properties_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(*from._impl_.client_properties_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.download_verdict_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.download_verdict_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest)
}

inline void ClientSafeBrowsingReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){arena}
    , decltype(_impl_.client_asn_){arena}
    , decltype(_impl_.dom_){arena}
    , decltype(_impl_.url_){}
    , decltype(_impl_.page_url_){}
    , decltype(_impl_.referrer_url_){}
    , decltype(_impl_.client_country_){}
    , decltype(_impl_.token_){}
    , decltype(_impl_.client_properties_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.complete_){false}
    , decltype(_impl_.did_proceed_){false}
    , decltype(_impl_.repeat_visit_){false}
    , decltype(_impl_.show_download_in_folder_){false}
    , decltype(_impl_.download_verdict_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest::~ClientSafeBrowsingReportRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSafeBrowsingReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resources_.~RepeatedPtrField();
  _impl_.client_asn_.~RepeatedPtrField();
  _impl_.dom_.~RepeatedPtrField();
  _impl_.url_.Destroy();
  _impl_.page_url_.Destroy();
  _impl_.referrer_url_.Destroy();
  _impl_.client_country_.Destroy();
  _impl_.token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.client_properties_;
}

void ClientSafeBrowsingReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resources_.Clear();
  _impl_.client_asn_.Clear();
  _impl_.dom_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.page_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.referrer_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.client_country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.client_properties_ != nullptr);
      _impl_.client_properties_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.complete_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.complete_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.did_proceed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.download_verdict_) -
        reinterpret_cast<char*>(&_impl_.did_proceed_)) + sizeof(_impl_.download_verdict_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string page_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_page_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_referrer_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool complete = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_complete(&has_bits);
          _impl_.complete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string client_asn = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_client_asn();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string client_country = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_client_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool did_proceed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_did_proceed(&has_bits);
          _impl_.did_proceed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool repeat_visit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_repeat_visit(&has_bits);
          _impl_.repeat_visit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_ReportType_IsValid(val))) {
            _internal_set_type(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_ReportType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(val))) {
            _internal_set_download_verdict(static_cast<::safe_browsing::ClientDownloadResponse_Verdict>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes token = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.HTMLElement dom = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_dom(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_download_in_folder = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_show_download_in_folder(&has_bits);
          _impl_.show_download_in_folder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string page_url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_page_url(), target);
  }

  // optional string referrer_url = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_referrer_url(), target);
  }

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
    const auto& repfield = this->_internal_resources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool complete = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_complete(), target);
  }

  // repeated string client_asn = 6;
  for (int i = 0, n = this->_internal_client_asn_size(); i < n; i++) {
    const auto& s = this->_internal_client_asn(i);
    target = stream->WriteString(6, s, target);
  }

  // optional string client_country = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_client_country(), target);
  }

  // optional bool did_proceed = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_did_proceed(), target);
  }

  // optional bool repeat_visit = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_repeat_visit(), target);
  }

  // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_type(), target);
  }

  // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      11, this->_internal_download_verdict(), target);
  }

  // optional bytes token = 15;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_token(), target);
  }

  // repeated .safe_browsing.HTMLElement dom = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dom_size()); i < n; i++) {
    const auto& repfield = this->_internal_dom(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::client_properties(this),
        _Internal::client_properties(this).GetCachedSize(), target, stream);
  }

  // optional bool show_download_in_folder = 18;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_show_download_in_folder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest)
  return target;
}

size_t ClientSafeBrowsingReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->_impl_.resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string client_asn = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.client_asn_.size());
  for (int i = 0, n = _impl_.client_asn_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.client_asn_.Get(i));
  }

  // repeated .safe_browsing.HTMLElement dom = 16;
  total_size += 2UL * this->_internal_dom_size();
  for (const auto& msg : this->_impl_.dom_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string page_url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_page_url());
    }

    // optional string referrer_url = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer_url());
    }

    // optional string client_country = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_country());
    }

    // optional bytes token = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_properties_);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool complete = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool did_proceed = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool repeat_visit = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool show_download_in_folder = 18;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_download_verdict());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSafeBrowsingReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest*>(
      &from));
}

void ClientSafeBrowsingReportRequest::MergeFrom(const ClientSafeBrowsingReportRequest& from) {
  ClientSafeBrowsingReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
  _this->_impl_.client_asn_.MergeFrom(from._impl_.client_asn_);
  _this->_impl_.dom_.MergeFrom(from._impl_.dom_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_page_url(from._internal_page_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_referrer_url(from._internal_referrer_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_client_country(from._internal_client_country());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_client_properties()->::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::MergeFrom(
          from._internal_client_properties());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.complete_ = from._impl_.complete_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.did_proceed_ = from._impl_.did_proceed_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.repeat_visit_ = from._impl_.repeat_visit_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.show_download_in_folder_ = from._impl_.show_download_in_folder_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.download_verdict_ = from._impl_.download_verdict_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest::CopyFrom(const ClientSafeBrowsingReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.resources_))
    return false;
  return true;
}

void ClientSafeBrowsingReportRequest::InternalSwap(ClientSafeBrowsingReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.resources_.InternalSwap(&other->_impl_.resources_);
  _impl_.client_asn_.InternalSwap(&other->_impl_.client_asn_);
  _impl_.dom_.InternalSwap(&other->_impl_.dom_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_url_, lhs_arena,
      &other->_impl_.page_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_url_, lhs_arena,
      &other->_impl_.referrer_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_country_, lhs_arena,
      &other->_impl_.client_country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest, _impl_.download_verdict_)
      + sizeof(ClientSafeBrowsingReportRequest::_impl_.download_verdict_)
      - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest, _impl_.client_properties_)>(
          reinterpret_cast<char*>(&_impl_.client_properties_),
          reinterpret_cast<char*>(&other->_impl_.client_properties_));
}

std::string ClientSafeBrowsingReportRequest::GetTypeName() const {
  return "safe_browsing.ClientSafeBrowsingReportRequest";
}


// ===================================================================

class HTMLElement_Attribute::_Internal {
 public:
  using HasBits = decltype(std::declval<HTMLElement_Attribute>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HTMLElement_Attribute::HTMLElement_Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.HTMLElement.Attribute)
}
HTMLElement_Attribute::HTMLElement_Attribute(const HTMLElement_Attribute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HTMLElement_Attribute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(),
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(),
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.HTMLElement.Attribute)
}

inline void HTMLElement_Attribute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTMLElement_Attribute::~HTMLElement_Attribute() {
  // @@protoc_insertion_point(destructor:safe_browsing.HTMLElement.Attribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HTMLElement_Attribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void HTMLElement_Attribute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HTMLElement_Attribute::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.HTMLElement.Attribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HTMLElement_Attribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HTMLElement_Attribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.HTMLElement.Attribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.HTMLElement.Attribute)
  return target;
}

size_t HTMLElement_Attribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.HTMLElement.Attribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HTMLElement_Attribute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HTMLElement_Attribute*>(
      &from));
}

void HTMLElement_Attribute::MergeFrom(const HTMLElement_Attribute& from) {
  HTMLElement_Attribute* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.HTMLElement.Attribute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HTMLElement_Attribute::CopyFrom(const HTMLElement_Attribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.HTMLElement.Attribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HTMLElement_Attribute::IsInitialized() const {
  return true;
}

void HTMLElement_Attribute::InternalSwap(HTMLElement_Attribute* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string HTMLElement_Attribute::GetTypeName() const {
  return "safe_browsing.HTMLElement.Attribute";
}


// ===================================================================

class HTMLElement::_Internal {
 public:
  using HasBits = decltype(std::declval<HTMLElement>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

HTMLElement::HTMLElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.HTMLElement)
}
HTMLElement::HTMLElement(const HTMLElement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HTMLElement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_ids_){from._impl_.child_ids_}
    , decltype(_impl_.attribute_){from._impl_.attribute_}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.resource_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    _this->_impl_.tag_.Set(from._internal_tag(),
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resource_id_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.resource_id_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.HTMLElement)
}

inline void HTMLElement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_ids_){arena}
    , decltype(_impl_.attribute_){arena}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.resource_id_){0}
  };
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTMLElement::~HTMLElement() {
  // @@protoc_insertion_point(destructor:safe_browsing.HTMLElement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HTMLElement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.child_ids_.~RepeatedField();
  _impl_.attribute_.~RepeatedPtrField();
  _impl_.tag_.Destroy();
}

void HTMLElement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HTMLElement::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.HTMLElement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.child_ids_.Clear();
  _impl_.attribute_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.tag_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.resource_id_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.resource_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HTMLElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 child_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 resource_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_resource_id(&has_bits);
          _impl_.resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attribute(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HTMLElement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.HTMLElement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string tag = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_tag(), target);
  }

  // repeated int32 child_ids = 3;
  for (int i = 0, n = this->_internal_child_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_child_ids(i), target);
  }

  // optional int32 resource_id = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_resource_id(), target);
  }

  // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attribute_size()); i < n; i++) {
    const auto& repfield = this->_internal_attribute(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.HTMLElement)
  return target;
}

size_t HTMLElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.HTMLElement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 child_ids = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.child_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_child_ids_size());
    total_size += data_size;
  }

  // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
  total_size += 1UL * this->_internal_attribute_size();
  for (const auto& msg : this->_impl_.attribute_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string tag = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional int32 resource_id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resource_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HTMLElement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HTMLElement*>(
      &from));
}

void HTMLElement::MergeFrom(const HTMLElement& from) {
  HTMLElement* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.HTMLElement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
  _this->_impl_.attribute_.MergeFrom(from._impl_.attribute_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.resource_id_ = from._impl_.resource_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HTMLElement::CopyFrom(const HTMLElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.HTMLElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HTMLElement::IsInitialized() const {
  return true;
}

void HTMLElement::InternalSwap(HTMLElement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
  _impl_.attribute_.InternalSwap(&other->_impl_.attribute_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HTMLElement, _impl_.resource_id_)
      + sizeof(HTMLElement::_impl_.resource_id_)
      - PROTOBUF_FIELD_OFFSET(HTMLElement, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string HTMLElement::GetTypeName() const {
  return "safe_browsing.HTMLElement";
}


// ===================================================================

class ImageData_Dimensions::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageData_Dimensions>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ImageData_Dimensions::ImageData_Dimensions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ImageData.Dimensions)
}
ImageData_Dimensions::ImageData_Dimensions(const ImageData_Dimensions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ImageData_Dimensions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ImageData.Dimensions)
}

inline void ImageData_Dimensions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
  };
}

ImageData_Dimensions::~ImageData_Dimensions() {
  // @@protoc_insertion_point(destructor:safe_browsing.ImageData.Dimensions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageData_Dimensions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImageData_Dimensions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageData_Dimensions::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ImageData.Dimensions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImageData_Dimensions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageData_Dimensions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ImageData.Dimensions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ImageData.Dimensions)
  return target;
}

size_t ImageData_Dimensions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ImageData.Dimensions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageData_Dimensions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ImageData_Dimensions*>(
      &from));
}

void ImageData_Dimensions::MergeFrom(const ImageData_Dimensions& from) {
  ImageData_Dimensions* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ImageData.Dimensions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageData_Dimensions::CopyFrom(const ImageData_Dimensions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ImageData.Dimensions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageData_Dimensions::IsInitialized() const {
  return true;
}

void ImageData_Dimensions::InternalSwap(ImageData_Dimensions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageData_Dimensions, _impl_.height_)
      + sizeof(ImageData_Dimensions::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(ImageData_Dimensions, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string ImageData_Dimensions::GetTypeName() const {
  return "safe_browsing.ImageData.Dimensions";
}


// ===================================================================

class ImageData::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageData>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mime_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::ImageData_Dimensions& dimensions(const ImageData* msg);
  static void set_has_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ImageData_Dimensions& original_dimensions(const ImageData* msg);
  static void set_has_original_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::ImageData_Dimensions&
ImageData::_Internal::dimensions(const ImageData* msg) {
  return *msg->_impl_.dimensions_;
}
const ::safe_browsing::ImageData_Dimensions&
ImageData::_Internal::original_dimensions(const ImageData* msg) {
  return *msg->_impl_.original_dimensions_;
}
ImageData::ImageData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ImageData)
}
ImageData::ImageData(const ImageData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ImageData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.mime_type_){}
    , decltype(_impl_.dimensions_){nullptr}
    , decltype(_impl_.original_dimensions_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(),
      _this->GetArenaForAllocation());
  }
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mime_type()) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dimensions()) {
    _this->_impl_.dimensions_ = new ::safe_browsing::ImageData_Dimensions(*from._impl_.dimensions_);
  }
  if (from._internal_has_original_dimensions()) {
    _this->_impl_.original_dimensions_ = new ::safe_browsing::ImageData_Dimensions(*from._impl_.original_dimensions_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ImageData)
}

inline void ImageData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.mime_type_){}
    , decltype(_impl_.dimensions_){nullptr}
    , decltype(_impl_.original_dimensions_){nullptr}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ImageData::~ImageData() {
  // @@protoc_insertion_point(destructor:safe_browsing.ImageData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.mime_type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dimensions_;
  if (this != internal_default_instance()) delete _impl_.original_dimensions_;
}

void ImageData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageData::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ImageData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mime_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.dimensions_ != nullptr);
      _impl_.dimensions_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.original_dimensions_ != nullptr);
      _impl_.original_dimensions_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImageData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mime_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ImageData.Dimensions dimensions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_dimensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ImageData.Dimensions original_dimensions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_original_dimensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ImageData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // optional string mime_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mime_type(), target);
  }

  // optional .safe_browsing.ImageData.Dimensions dimensions = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::dimensions(this),
        _Internal::dimensions(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ImageData.Dimensions original_dimensions = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::original_dimensions(this),
        _Internal::original_dimensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ImageData)
  return target;
}

size_t ImageData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ImageData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional string mime_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mime_type());
    }

    // optional .safe_browsing.ImageData.Dimensions dimensions = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dimensions_);
    }

    // optional .safe_browsing.ImageData.Dimensions original_dimensions = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.original_dimensions_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ImageData*>(
      &from));
}

void ImageData::MergeFrom(const ImageData& from) {
  ImageData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ImageData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mime_type(from._internal_mime_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_dimensions()->::safe_browsing::ImageData_Dimensions::MergeFrom(
          from._internal_dimensions());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_original_dimensions()->::safe_browsing::ImageData_Dimensions::MergeFrom(
          from._internal_original_dimensions());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageData::CopyFrom(const ImageData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ImageData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageData::IsInitialized() const {
  return true;
}

void ImageData::InternalSwap(ImageData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_type_, lhs_arena,
      &other->_impl_.mime_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageData, _impl_.original_dimensions_)
      + sizeof(ImageData::_impl_.original_dimensions_)
      - PROTOBUF_FIELD_OFFSET(ImageData, _impl_.dimensions_)>(
          reinterpret_cast<char*>(&_impl_.dimensions_),
          reinterpret_cast<char*>(&other->_impl_.dimensions_));
}

std::string ImageData::GetTypeName() const {
  return "safe_browsing.ImageData";
}


// ===================================================================

class NotificationImageReportRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NotificationImageReportRequest>()._impl_._has_bits_);
  static void set_has_notification_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ImageData& image(const NotificationImageReportRequest* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::ImageData&
NotificationImageReportRequest::_Internal::image(const NotificationImageReportRequest* msg) {
  return *msg->_impl_.image_;
}
NotificationImageReportRequest::NotificationImageReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:safe_browsing.NotificationImageReportRequest)
}
NotificationImageReportRequest::NotificationImageReportRequest(const NotificationImageReportRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  NotificationImageReportRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notification_origin_){}
    , decltype(_impl_.image_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.notification_origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_notification_origin()) {
    _this->_impl_.notification_origin_.Set(from._internal_notification_origin(),
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_image()) {
    _this->_impl_.image_ = new ::safe_browsing::ImageData(*from._impl_.image_);
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.NotificationImageReportRequest)
}

inline void NotificationImageReportRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notification_origin_){}
    , decltype(_impl_.image_){nullptr}
  };
  _impl_.notification_origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.notification_origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NotificationImageReportRequest::~NotificationImageReportRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.NotificationImageReportRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NotificationImageReportRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.notification_origin_.Destroy();
  if (this != internal_default_instance()) delete _impl_.image_;
}

void NotificationImageReportRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NotificationImageReportRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.NotificationImageReportRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.notification_origin_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NotificationImageReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string notification_origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_notification_origin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ImageData image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NotificationImageReportRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.NotificationImageReportRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string notification_origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_notification_origin(), target);
  }

  // optional .safe_browsing.ImageData image = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.NotificationImageReportRequest)
  return target;
}

size_t NotificationImageReportRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.NotificationImageReportRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string notification_origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_notification_origin());
    }

    // optional .safe_browsing.ImageData image = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NotificationImageReportRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NotificationImageReportRequest*>(
      &from));
}

void NotificationImageReportRequest::MergeFrom(const NotificationImageReportRequest& from) {
  NotificationImageReportRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.NotificationImageReportRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_notification_origin(from._internal_notification_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_image()->::safe_browsing::ImageData::MergeFrom(
          from._internal_image());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NotificationImageReportRequest::CopyFrom(const NotificationImageReportRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.NotificationImageReportRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotificationImageReportRequest::IsInitialized() const {
  return true;
}

void NotificationImageReportRequest::InternalSwap(NotificationImageReportRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.notification_origin_, lhs_arena,
      &other->_impl_.notification_origin_, rhs_arena
  );
  swap(_impl_.image_, other->_impl_.image_);
}

std::string NotificationImageReportRequest::GetTypeName() const {
  return "safe_browsing.NotificationImageReportRequest";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::safe_browsing::ChromeUserPopulation*
Arena::CreateMaybeMessage< ::safe_browsing::ChromeUserPopulation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ChromeUserPopulation >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingRequest_Feature*
Arena::CreateMaybeMessage< ::safe_browsing::ClientPhishingRequest_Feature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientPhishingRequest_Feature >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientPhishingRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientPhishingRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientPhishingResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientPhishingResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientMalwareRequest_UrlInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ClientMalwareRequest_UrlInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientMalwareRequest_UrlInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientMalwareRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientMalwareRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientMalwareRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_Frame_Form*
Arena::CreateMaybeMessage< ::safe_browsing::LoginReputationClientRequest_Frame_Form >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::LoginReputationClientRequest_Frame_Form >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_Frame*
Arena::CreateMaybeMessage< ::safe_browsing::LoginReputationClientRequest_Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::LoginReputationClientRequest_Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent*
Arena::CreateMaybeMessage< ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest*
Arena::CreateMaybeMessage< ::safe_browsing::LoginReputationClientRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::LoginReputationClientRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientResponse*
Arena::CreateMaybeMessage< ::safe_browsing::LoginReputationClientResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::LoginReputationClientResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientMalwareResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientMalwareResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientMalwareResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_Digests*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_Digests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_Digests >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_Resource*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_Resource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_Resource >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_CertificateChain_Element*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_CertificateChain*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_CertificateChain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_CertificateChain >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ExtendedAttr*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_ExtendedAttr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_ExtendedAttr >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_SignatureInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_SignatureInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_SignatureInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_PEImageHeaders*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_PEImageHeaders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_PEImageHeaders >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_MachOHeaders*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_MachOHeaders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_MachOHeaders >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ImageHeaders*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_ImageHeaders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_ImageHeaders >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ArchivedBinary*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest_ArchivedBinary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest_ArchivedBinary >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ReferrerChainEntry_ServerRedirect*
Arena::CreateMaybeMessage< ::safe_browsing::ReferrerChainEntry_ServerRedirect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ReferrerChainEntry_ServerRedirect >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ReferrerChainEntry*
Arena::CreateMaybeMessage< ::safe_browsing::ReferrerChainEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ReferrerChainEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadResponse_MoreInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadResponse_MoreInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadResponse_MoreInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadReport_UserInformation*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadReport_UserInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadReport_UserInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadReport*
Arena::CreateMaybeMessage< ::safe_browsing::ClientDownloadReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientDownloadReport >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientUploadResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientUploadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientUploadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_IncidentData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_IncidentData >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_DownloadDetails*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_DownloadDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_DownloadDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_OS >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData_Process >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_EnvironmentData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_EnvironmentData >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_ExtensionData*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_ExtensionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_ExtensionData >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentReport >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentResponse_EnvironmentRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentResponse_EnvironmentRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentResponse_EnvironmentRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientIncidentResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientIncidentResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::DownloadMetadata*
Arena::CreateMaybeMessage< ::safe_browsing::DownloadMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::DownloadMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_Resource*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_Resource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_Resource >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest*
Arena::CreateMaybeMessage< ::safe_browsing::ClientSafeBrowsingReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientSafeBrowsingReportRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::HTMLElement_Attribute*
Arena::CreateMaybeMessage< ::safe_browsing::HTMLElement_Attribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::HTMLElement_Attribute >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::HTMLElement*
Arena::CreateMaybeMessage< ::safe_browsing::HTMLElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::HTMLElement >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ImageData_Dimensions*
Arena::CreateMaybeMessage< ::safe_browsing::ImageData_Dimensions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ImageData_Dimensions >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ImageData*
Arena::CreateMaybeMessage< ::safe_browsing::ImageData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ImageData >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::NotificationImageReportRequest*
Arena::CreateMaybeMessage< ::safe_browsing::NotificationImageReportRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::NotificationImageReportRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
