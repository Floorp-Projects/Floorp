<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Test for Bug 1442496</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
</head>

<body>
<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1442496">Mozilla Bug 1442496</a>
<p id="display"></p>
<div id="content" style="display: none">
</div>
<pre id="test">

<script type="text/javascript" src="classifierHelper.js"></script>
<script class="testbody" type="text/javascript">

// To add a request to test, add the request in trackerFrame.html
// and the id of query string "?id=xxx" here.
const trackersAll = [
  "img-src",
  "object-data",
  "script-src",
  "iframe-src",
  "link-rel-stylesheet",
  "video-src",
  "track-src",
  "ping",
  "fetch",
  "xmlhttprequest",
  "send-beacon",
  "fetch-in-sw",
];

const TRACKER_DOMAIN = "itisatracker.org";
const TEST_TOP_DOMAIN = "example.com";

const TEST_TOP_PAGE = "trackerFrame.html";
const TRACKER_SERVER = "trackerFrame.sjs";
const SET_COOKIE_PAGE = "cookieSetterPage.html";

const TEST_PATH = "/tests/toolkit/components/url-classifier/tests/mochitest/";

const TEST_TOP_SITE = "https:///" + TEST_TOP_DOMAIN + TEST_PATH;
const TRACKER_SITE = "https://" + TRACKER_DOMAIN  + TEST_PATH;
const TRACKER_SITE2 = "http://" + TRACKER_DOMAIN  + TEST_PATH;
const TRACKER_SJS = "https://" + TRACKER_DOMAIN + TEST_PATH + TRACKER_SERVER;

// This function ask the server to set the cookie
async function setupAndRun(hasCookie, topLevelSite = TEST_TOP_SITE) {
  await fetch(TRACKER_SJS + "?init=" + trackersAll.length, {
    credentials: "include",
  });

  window.open(TRACKER_SITE2 + SET_COOKIE_PAGE);

  let p1 = new Promise(resolve => {
    window.onmessage = function(e) {
      if (e.data.result == "websocket-unexpected-error") {
        ok(false, "websocket error when " + e.data.url);
      } else {
        let description = "Tracker request " + e.data.id + "received " +
          (hasCookie ? "with" : "without") + " cookie when " + e.data.url;
        if (hasCookie) {
          ok(e.data.result == "foo=bar", description);
        } else {
          ok(e.data.result == "(none)", description);
        }
        resolve();
      }
    };
  });

  let p2 = new Promise(resolve => {
    let win;
    let query = hasCookie ? "with-cookie" : "without-cookie";
    fetch(TRACKER_SJS + "?callback=" + query).then(r => {
      r.text().then((body) => {
        let trackers_found = body.split(",");
        for (let tracker of trackersAll) {
          let description = "Tracker request " + tracker + "received " +
            (hasCookie ? "with" : "without") + " cookie";
          ok(trackers_found.includes(tracker), description);
        }
        win.close();
        resolve();
      });
    });

    win = window.open(topLevelSite + TEST_TOP_PAGE);
  });

  return Promise.all([p1, p2]);
}

async function cleanup(topLevelSite = TEST_TOP_SITE) {
  function clearServiceWorker() {
    return new Promise(resolve => {
      let w;
      window.onmessage = function(e) {
        if (e.data.status == "unregistrationdone") {
          w.close();
          resolve();
        }
      }
      w = window.open(TEST_TOP_SITE + "sw_unregister.html");
    });
  }

  // Ensure we clear the stylesheet cache so that we re-classify.
  SpecialPowers.DOMWindowUtils.clearSharedStyleSheetCache();

  await clearServiceWorker();
}


async function testAnnotationOff() {
  info("Test all requests should be sent with cookies when ETP is off");

  let expectCookie = true;
  await setupAndRun(expectCookie);
  await cleanup();
}

async function testAnnotationOn() {
  info("Test all requests should be sent without cookies when ETP is on");

  await SpecialPowers.pushPrefEnv({set: [
    [ "privacy.trackingprotection.annotate_channels", true],
  ]});

  let expectCookie = false;
  await setupAndRun(expectCookie);
  await cleanup();
}

async function testInWhitelist() {
  info("Test all requests should be sent with cookies when top-level is in the whitelist");

  await classifierHelper.addUrlToDB([{
    url: TEST_TOP_DOMAIN + "/?resource=" + TRACKER_DOMAIN,
    db: "test-trackwhite-simple",
  }]);

  let expectCookie = true;
  await setupAndRun(expectCookie);
  await cleanup();
}

async function testFirstParty() {
  info("Test all requests should be sent with cookies when the tracker is a first-party");

  let expectCookie = true;
  await setupAndRun(expectCookie, TRACKER_SITE);
  await cleanup(TRACKER_SITE);
}

function runTests() {
  classifierHelper.waitForInit()
    .then(testAnnotationOff)
    .then(testAnnotationOn)
    .then(testInWhitelist)
    .then(testFirstParty)
    .then(function() {
      SimpleTest.finish();
    }).catch(function(e) {
      ok(false, "Some test failed with error " + e);
      SimpleTest.finish();
    });
}

SimpleTest.waitForExplicitFinish();
SpecialPowers.pushPrefEnv({set: [
  ["urlclassifier.trackingAnnotationTable.testEntries", TRACKER_DOMAIN],
  ["urlclassifier.trackingAnnotationWhitelistTable", "test-trackwhite-simple"],
  ["network.cookie.cookieBehavior", 4],
  ["privacy.trackingprotection.enabled", false ],
  ["privacy.trackingprotection.annotate_channels", false],
  ["browser.send_pings", true],
  ["dom.serviceWorkers.exemptFromPerDomainMax", true],
  ["dom.serviceWorkers.enabled", true],
  ["dom.serviceWorkers.testing.enabled", true],
  ["network.websocket.allowInsecureFromHTTPS", true],
]}, runTests);

</script>

</pre>
</body>
</html>
