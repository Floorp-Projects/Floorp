// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#include "safebrowsing.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Checksum_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ChromeClientInfo_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientInfo_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Duration_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RawHashes_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RawIndices_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RiceDeltaEncoding_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatEntry_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThreatEntryMetadata_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThreatEntrySet_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatHit_ThreatSource_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatHit_UserInfo_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThreatInfo_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatListDescriptor_safebrowsing_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThreatMatch_safebrowsing_2eproto;
namespace mozilla {
namespace safebrowsing {
class ThreatInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatInfo> _instance;
} _ThreatInfo_default_instance_;
class ThreatMatchDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatMatch> _instance;
} _ThreatMatch_default_instance_;
class FindThreatMatchesRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FindThreatMatchesRequest> _instance;
} _FindThreatMatchesRequest_default_instance_;
class FindThreatMatchesResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FindThreatMatchesResponse> _instance;
} _FindThreatMatchesResponse_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints> _instance;
} _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest_ListUpdateRequest> _instance;
} _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
class FetchThreatListUpdatesRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FetchThreatListUpdatesRequest> _instance;
} _FetchThreatListUpdatesRequest_default_instance_;
class FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FetchThreatListUpdatesResponse_ListUpdateResponse> _instance;
} _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
class FetchThreatListUpdatesResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FetchThreatListUpdatesResponse> _instance;
} _FetchThreatListUpdatesResponse_default_instance_;
class FindFullHashesRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FindFullHashesRequest> _instance;
} _FindFullHashesRequest_default_instance_;
class FindFullHashesResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FindFullHashesResponse> _instance;
} _FindFullHashesResponse_default_instance_;
class ThreatHit_ThreatSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatHit_ThreatSource> _instance;
} _ThreatHit_ThreatSource_default_instance_;
class ThreatHit_UserInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatHit_UserInfo> _instance;
} _ThreatHit_UserInfo_default_instance_;
class ThreatHitDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatHit> _instance;
} _ThreatHit_default_instance_;
class ClientInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ClientInfo> _instance;
} _ClientInfo_default_instance_;
class ChromeClientInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ChromeClientInfo> _instance;
} _ChromeClientInfo_default_instance_;
class ChecksumDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Checksum> _instance;
} _Checksum_default_instance_;
class ThreatEntryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatEntry> _instance;
} _ThreatEntry_default_instance_;
class ThreatEntrySetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatEntrySet> _instance;
} _ThreatEntrySet_default_instance_;
class RawIndicesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RawIndices> _instance;
} _RawIndices_default_instance_;
class RawHashesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RawHashes> _instance;
} _RawHashes_default_instance_;
class RiceDeltaEncodingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RiceDeltaEncoding> _instance;
} _RiceDeltaEncoding_default_instance_;
class ThreatEntryMetadata_MetadataEntryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatEntryMetadata_MetadataEntry> _instance;
} _ThreatEntryMetadata_MetadataEntry_default_instance_;
class ThreatEntryMetadataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatEntryMetadata> _instance;
} _ThreatEntryMetadata_default_instance_;
class ThreatListDescriptorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThreatListDescriptor> _instance;
} _ThreatListDescriptor_default_instance_;
class ListThreatListsResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ListThreatListsResponse> _instance;
} _ListThreatListsResponse_default_instance_;
class DurationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Duration> _instance;
} _Duration_default_instance_;
}  // namespace safebrowsing
}  // namespace mozilla
static void InitDefaultsscc_info_Checksum_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_Checksum_default_instance_;
    new (ptr) ::mozilla::safebrowsing::Checksum();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::Checksum::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Checksum_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Checksum_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ChromeClientInfo_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ChromeClientInfo_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ChromeClientInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ChromeClientInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ChromeClientInfo_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ChromeClientInfo_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ClientInfo_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ClientInfo_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ClientInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ClientInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ClientInfo_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ClientInfo_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_Duration_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_Duration_default_instance_;
    new (ptr) ::mozilla::safebrowsing::Duration();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::Duration::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Duration_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Duration_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_FetchThreatListUpdatesRequest_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FetchThreatListUpdatesRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_FetchThreatListUpdatesRequest_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_FetchThreatListUpdatesRequest_safebrowsing_2eproto}, {
      &scc_info_ClientInfo_safebrowsing_2eproto.base,
      &scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto.base,
      &scc_info_ChromeClientInfo_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto}, {
      &scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_FetchThreatListUpdatesResponse_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FetchThreatListUpdatesResponse_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FetchThreatListUpdatesResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FetchThreatListUpdatesResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FetchThreatListUpdatesResponse_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FetchThreatListUpdatesResponse_safebrowsing_2eproto}, {
      &scc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto.base,
      &scc_info_Duration_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto}, {
      &scc_info_ThreatEntrySet_safebrowsing_2eproto.base,
      &scc_info_Checksum_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FindFullHashesRequest_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FindFullHashesRequest_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FindFullHashesRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FindFullHashesRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FindFullHashesRequest_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FindFullHashesRequest_safebrowsing_2eproto}, {
      &scc_info_ClientInfo_safebrowsing_2eproto.base,
      &scc_info_ThreatInfo_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FindFullHashesResponse_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FindFullHashesResponse_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FindFullHashesResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FindFullHashesResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FindFullHashesResponse_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FindFullHashesResponse_safebrowsing_2eproto}, {
      &scc_info_ThreatMatch_safebrowsing_2eproto.base,
      &scc_info_Duration_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FindThreatMatchesRequest_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FindThreatMatchesRequest_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FindThreatMatchesRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FindThreatMatchesRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FindThreatMatchesRequest_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FindThreatMatchesRequest_safebrowsing_2eproto}, {
      &scc_info_ClientInfo_safebrowsing_2eproto.base,
      &scc_info_ThreatInfo_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_FindThreatMatchesResponse_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_FindThreatMatchesResponse_default_instance_;
    new (ptr) ::mozilla::safebrowsing::FindThreatMatchesResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::FindThreatMatchesResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FindThreatMatchesResponse_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FindThreatMatchesResponse_safebrowsing_2eproto}, {
      &scc_info_ThreatMatch_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_ListThreatListsResponse_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ListThreatListsResponse_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ListThreatListsResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ListThreatListsResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ListThreatListsResponse_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ListThreatListsResponse_safebrowsing_2eproto}, {
      &scc_info_ThreatListDescriptor_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_RawHashes_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_RawHashes_default_instance_;
    new (ptr) ::mozilla::safebrowsing::RawHashes();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::RawHashes::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RawHashes_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RawHashes_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_RawIndices_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_RawIndices_default_instance_;
    new (ptr) ::mozilla::safebrowsing::RawIndices();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::RawIndices::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RawIndices_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RawIndices_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_RiceDeltaEncoding_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_RiceDeltaEncoding_default_instance_;
    new (ptr) ::mozilla::safebrowsing::RiceDeltaEncoding();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::RiceDeltaEncoding::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RiceDeltaEncoding_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_RiceDeltaEncoding_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatEntry_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatEntry_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatEntry();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatEntry::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatEntry_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ThreatEntry_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatEntryMetadata_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatEntryMetadata_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatEntryMetadata();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatEntryMetadata::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThreatEntryMetadata_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ThreatEntryMetadata_safebrowsing_2eproto}, {
      &scc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatEntryMetadata_MetadataEntry_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatEntrySet_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatEntrySet_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatEntrySet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatEntrySet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThreatEntrySet_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ThreatEntrySet_safebrowsing_2eproto}, {
      &scc_info_RawHashes_safebrowsing_2eproto.base,
      &scc_info_RawIndices_safebrowsing_2eproto.base,
      &scc_info_RiceDeltaEncoding_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_ThreatHit_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatHit_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatHit();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatHit::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_ThreatHit_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_ThreatHit_safebrowsing_2eproto}, {
      &scc_info_ThreatEntry_safebrowsing_2eproto.base,
      &scc_info_ThreatHit_ThreatSource_safebrowsing_2eproto.base,
      &scc_info_ClientInfo_safebrowsing_2eproto.base,
      &scc_info_ThreatHit_UserInfo_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_ThreatHit_ThreatSource_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatHit_ThreatSource_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatHit_ThreatSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatHit_ThreatSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatHit_ThreatSource_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ThreatHit_ThreatSource_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatHit_UserInfo_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatHit_UserInfo_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatHit_UserInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatHit_UserInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatHit_UserInfo_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ThreatHit_UserInfo_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatInfo_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatInfo_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThreatInfo_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ThreatInfo_safebrowsing_2eproto}, {
      &scc_info_ThreatEntry_safebrowsing_2eproto.base,}};

static void InitDefaultsscc_info_ThreatListDescriptor_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatListDescriptor_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatListDescriptor();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatListDescriptor::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ThreatListDescriptor_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ThreatListDescriptor_safebrowsing_2eproto}, {}};

static void InitDefaultsscc_info_ThreatMatch_safebrowsing_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::mozilla::safebrowsing::_ThreatMatch_default_instance_;
    new (ptr) ::mozilla::safebrowsing::ThreatMatch();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::mozilla::safebrowsing::ThreatMatch::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThreatMatch_safebrowsing_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ThreatMatch_safebrowsing_2eproto}, {
      &scc_info_ThreatEntry_safebrowsing_2eproto.base,
      &scc_info_ThreatEntryMetadata_safebrowsing_2eproto.base,
      &scc_info_Duration_safebrowsing_2eproto.base,}};

namespace mozilla {
namespace safebrowsing {
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[3] = {};

static const char FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names[] =
  "FULL_UPDATE"
  "PARTIAL_UPDATE"
  "RESPONSE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries[] = {
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 0, 11}, 2 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 11, 14}, 1 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 25, 25}, 0 },
};

static const int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number[] = {
  2, // 0 -> RESPONSE_TYPE_UNSPECIFIED
  1, // 1 -> PARTIAL_UPDATE
  0, // 2 -> FULL_UPDATE
};

const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
          3, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[idx].get();
}
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(
    const std::string& name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::RESPONSE_TYPE_UNSPECIFIED;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::PARTIAL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::FULL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MIN;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MAX;
constexpr int FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ThreatHit_ThreatSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatHit_ThreatSourceType_strings[5] = {};

static const char ThreatHit_ThreatSourceType_names[] =
  "MATCHING_URL"
  "TAB_REDIRECT"
  "TAB_RESOURCE"
  "TAB_URL"
  "THREAT_SOURCE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatHit_ThreatSourceType_entries[] = {
  { {ThreatHit_ThreatSourceType_names + 0, 12}, 1 },
  { {ThreatHit_ThreatSourceType_names + 12, 12}, 3 },
  { {ThreatHit_ThreatSourceType_names + 24, 12}, 4 },
  { {ThreatHit_ThreatSourceType_names + 36, 7}, 2 },
  { {ThreatHit_ThreatSourceType_names + 43, 30}, 0 },
};

static const int ThreatHit_ThreatSourceType_entries_by_number[] = {
  4, // 0 -> THREAT_SOURCE_TYPE_UNSPECIFIED
  0, // 1 -> MATCHING_URL
  3, // 2 -> TAB_URL
  1, // 3 -> TAB_REDIRECT
  2, // 4 -> TAB_RESOURCE
};

const std::string& ThreatHit_ThreatSourceType_Name(
    ThreatHit_ThreatSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatHit_ThreatSourceType_entries,
          ThreatHit_ThreatSourceType_entries_by_number,
          5, ThreatHit_ThreatSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatHit_ThreatSourceType_entries,
      ThreatHit_ThreatSourceType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatHit_ThreatSourceType_strings[idx].get();
}
bool ThreatHit_ThreatSourceType_Parse(
    const std::string& name, ThreatHit_ThreatSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatHit_ThreatSourceType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ThreatHit_ThreatSourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ThreatHit_ThreatSourceType ThreatHit::THREAT_SOURCE_TYPE_UNSPECIFIED;
constexpr ThreatHit_ThreatSourceType ThreatHit::MATCHING_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_REDIRECT;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_RESOURCE;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MIN;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MAX;
constexpr int ThreatHit::ThreatSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeClientInfo_SafeBrowsingReportingPopulation_strings[4] = {};

static const char ChromeClientInfo_SafeBrowsingReportingPopulation_names[] =
  "EXTENDED"
  "OPT_OUT"
  "SCOUT"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeClientInfo_SafeBrowsingReportingPopulation_entries[] = {
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 0, 8}, 2 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 8, 7}, 1 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 15, 5}, 3 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 20, 11}, 0 },
};

static const int ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number[] = {
  3, // 0 -> UNSPECIFIED
  1, // 1 -> OPT_OUT
  0, // 2 -> EXTENDED
  2, // 3 -> SCOUT
};

const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(
    ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
          4, ChromeClientInfo_SafeBrowsingReportingPopulation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChromeClientInfo_SafeBrowsingReportingPopulation_strings[idx].get();
}
bool ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(
    const std::string& name, ChromeClientInfo_SafeBrowsingReportingPopulation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ChromeClientInfo_SafeBrowsingReportingPopulation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::UNSPECIFIED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::OPT_OUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::EXTENDED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SCOUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MIN;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MAX;
constexpr int ChromeClientInfo::SafeBrowsingReportingPopulation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ThreatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatType_strings[12] = {};

static const char ThreatType_names[] =
  "API_ABUSE"
  "CLIENT_INCIDENT"
  "CSD_DOWNLOAD_WHITELIST"
  "CSD_WHITELIST"
  "MALICIOUS_BINARY"
  "MALWARE_THREAT"
  "POTENTIALLY_HARMFUL_APPLICATION"
  "SOCIAL_ENGINEERING"
  "SOCIAL_ENGINEERING_PUBLIC"
  "SUBRESOURCE_FILTER"
  "THREAT_TYPE_UNSPECIFIED"
  "UNWANTED_SOFTWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatType_entries[] = {
  { {ThreatType_names + 0, 9}, 6 },
  { {ThreatType_names + 9, 15}, 10 },
  { {ThreatType_names + 24, 22}, 9 },
  { {ThreatType_names + 46, 13}, 8 },
  { {ThreatType_names + 59, 16}, 7 },
  { {ThreatType_names + 75, 14}, 1 },
  { {ThreatType_names + 89, 31}, 4 },
  { {ThreatType_names + 120, 18}, 5 },
  { {ThreatType_names + 138, 25}, 2 },
  { {ThreatType_names + 163, 18}, 13 },
  { {ThreatType_names + 181, 23}, 0 },
  { {ThreatType_names + 204, 17}, 3 },
};

static const int ThreatType_entries_by_number[] = {
  10, // 0 -> THREAT_TYPE_UNSPECIFIED
  5, // 1 -> MALWARE_THREAT
  8, // 2 -> SOCIAL_ENGINEERING_PUBLIC
  11, // 3 -> UNWANTED_SOFTWARE
  6, // 4 -> POTENTIALLY_HARMFUL_APPLICATION
  7, // 5 -> SOCIAL_ENGINEERING
  0, // 6 -> API_ABUSE
  4, // 7 -> MALICIOUS_BINARY
  3, // 8 -> CSD_WHITELIST
  2, // 9 -> CSD_DOWNLOAD_WHITELIST
  1, // 10 -> CLIENT_INCIDENT
  9, // 13 -> SUBRESOURCE_FILTER
};

const std::string& ThreatType_Name(
    ThreatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatType_entries,
          ThreatType_entries_by_number,
          12, ThreatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatType_entries,
      ThreatType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatType_strings[idx].get();
}
bool ThreatType_Parse(
    const std::string& name, ThreatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<ThreatType>(int_value);
  }
  return success;
}
bool PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlatformType_strings[9] = {};

static const char PlatformType_names[] =
  "ALL_PLATFORMS"
  "ANDROID_PLATFORM"
  "ANY_PLATFORM"
  "CHROME_PLATFORM"
  "IOS_PLATFORM"
  "LINUX_PLATFORM"
  "OSX_PLATFORM"
  "PLATFORM_TYPE_UNSPECIFIED"
  "WINDOWS_PLATFORM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlatformType_entries[] = {
  { {PlatformType_names + 0, 13}, 7 },
  { {PlatformType_names + 13, 16}, 3 },
  { {PlatformType_names + 29, 12}, 6 },
  { {PlatformType_names + 41, 15}, 8 },
  { {PlatformType_names + 56, 12}, 5 },
  { {PlatformType_names + 68, 14}, 2 },
  { {PlatformType_names + 82, 12}, 4 },
  { {PlatformType_names + 94, 25}, 0 },
  { {PlatformType_names + 119, 16}, 1 },
};

static const int PlatformType_entries_by_number[] = {
  7, // 0 -> PLATFORM_TYPE_UNSPECIFIED
  8, // 1 -> WINDOWS_PLATFORM
  5, // 2 -> LINUX_PLATFORM
  1, // 3 -> ANDROID_PLATFORM
  6, // 4 -> OSX_PLATFORM
  4, // 5 -> IOS_PLATFORM
  2, // 6 -> ANY_PLATFORM
  0, // 7 -> ALL_PLATFORMS
  3, // 8 -> CHROME_PLATFORM
};

const std::string& PlatformType_Name(
    PlatformType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlatformType_entries,
          PlatformType_entries_by_number,
          9, PlatformType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlatformType_entries,
      PlatformType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlatformType_strings[idx].get();
}
bool PlatformType_Parse(
    const std::string& name, PlatformType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlatformType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<PlatformType>(int_value);
  }
  return success;
}
bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CompressionType_strings[3] = {};

static const char CompressionType_names[] =
  "COMPRESSION_TYPE_UNSPECIFIED"
  "RAW"
  "RICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CompressionType_entries[] = {
  { {CompressionType_names + 0, 28}, 0 },
  { {CompressionType_names + 28, 3}, 1 },
  { {CompressionType_names + 31, 4}, 2 },
};

static const int CompressionType_entries_by_number[] = {
  0, // 0 -> COMPRESSION_TYPE_UNSPECIFIED
  1, // 1 -> RAW
  2, // 2 -> RICE
};

const std::string& CompressionType_Name(
    CompressionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CompressionType_entries,
          CompressionType_entries_by_number,
          3, CompressionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CompressionType_entries,
      CompressionType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CompressionType_strings[idx].get();
}
bool CompressionType_Parse(
    const std::string& name, CompressionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CompressionType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CompressionType>(int_value);
  }
  return success;
}
bool ThreatEntryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatEntryType_strings[7] = {};

static const char ThreatEntryType_names[] =
  "CERT"
  "CHROME_EXTENSION"
  "EXECUTABLE"
  "FILENAME"
  "IP_RANGE"
  "THREAT_ENTRY_TYPE_UNSPECIFIED"
  "URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatEntryType_entries[] = {
  { {ThreatEntryType_names + 0, 4}, 6 },
  { {ThreatEntryType_names + 4, 16}, 4 },
  { {ThreatEntryType_names + 20, 10}, 2 },
  { {ThreatEntryType_names + 30, 8}, 5 },
  { {ThreatEntryType_names + 38, 8}, 3 },
  { {ThreatEntryType_names + 46, 29}, 0 },
  { {ThreatEntryType_names + 75, 3}, 1 },
};

static const int ThreatEntryType_entries_by_number[] = {
  5, // 0 -> THREAT_ENTRY_TYPE_UNSPECIFIED
  6, // 1 -> URL
  2, // 2 -> EXECUTABLE
  4, // 3 -> IP_RANGE
  1, // 4 -> CHROME_EXTENSION
  3, // 5 -> FILENAME
  0, // 6 -> CERT
};

const std::string& ThreatEntryType_Name(
    ThreatEntryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatEntryType_entries,
          ThreatEntryType_entries_by_number,
          7, ThreatEntryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatEntryType_entries,
      ThreatEntryType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatEntryType_strings[idx].get();
}
bool ThreatEntryType_Parse(
    const std::string& name, ThreatEntryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatEntryType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ThreatEntryType>(int_value);
  }
  return success;
}

// ===================================================================

void ThreatInfo::InitAsDefaultInstance() {
}
class ThreatInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatInfo>()._has_bits_);
};

ThreatInfo::ThreatInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatInfo)
}
ThreatInfo::ThreatInfo(const ThreatInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      threat_types_(from.threat_types_),
      platform_types_(from.platform_types_),
      threat_entries_(from.threat_entries_),
      threat_entry_types_(from.threat_entry_types_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatInfo)
}

void ThreatInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatInfo_safebrowsing_2eproto.base);
}

ThreatInfo::~ThreatInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatInfo)
  SharedDtor();
}

void ThreatInfo::SharedDtor() {
}

void ThreatInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatInfo& ThreatInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatInfo_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_types_.Clear();
  platform_types_.Clear();
  threat_entries_.Clear();
  threat_entry_types_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
              _internal_add_threat_types(static_cast<::mozilla::safebrowsing::ThreatType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_threat_types(), ptr, ctx, ::mozilla::safebrowsing::ThreatType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
              _internal_add_platform_types(static_cast<::mozilla::safebrowsing::PlatformType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_platform_types(), ptr, ctx, ::mozilla::safebrowsing::PlatformType_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
              _internal_add_threat_entry_types(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_threat_entry_types(), ptr, ctx, ::mozilla::safebrowsing::ThreatEntryType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  for (int i = 0, n = this->_internal_threat_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        1, this->_internal_threat_types(i), target);
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  for (int i = 0, n = this->_internal_platform_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        2, this->_internal_platform_types(i), target);
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_threat_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_threat_entries(i), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  for (int i = 0, n = this->_internal_threat_entry_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        4, this->_internal_threat_entry_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatInfo)
  return target;
}

size_t ThreatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_threat_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_platform_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_platform_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  total_size += 1UL * this->_internal_threat_entries_size();
  for (const auto& msg : this->threat_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_entry_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_threat_entry_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatInfo*>(
      &from));
}

void ThreatInfo::MergeFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  threat_types_.MergeFrom(from.threat_types_);
  platform_types_.MergeFrom(from.platform_types_);
  threat_entries_.MergeFrom(from.threat_entries_);
  threat_entry_types_.MergeFrom(from.threat_entry_types_);
}

void ThreatInfo::CopyFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatInfo::IsInitialized() const {
  return true;
}

void ThreatInfo::InternalSwap(ThreatInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  threat_types_.InternalSwap(&other->threat_types_);
  platform_types_.InternalSwap(&other->platform_types_);
  threat_entries_.InternalSwap(&other->threat_entries_);
  threat_entry_types_.InternalSwap(&other->threat_entry_types_);
}

std::string ThreatInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatInfo";
}


// ===================================================================

void ThreatMatch::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_ThreatMatch_default_instance_._instance.get_mutable()->threat_ = const_cast< ::mozilla::safebrowsing::ThreatEntry*>(
      ::mozilla::safebrowsing::ThreatEntry::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatMatch_default_instance_._instance.get_mutable()->threat_entry_metadata_ = const_cast< ::mozilla::safebrowsing::ThreatEntryMetadata*>(
      ::mozilla::safebrowsing::ThreatEntryMetadata::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatMatch_default_instance_._instance.get_mutable()->cache_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
}
class ThreatMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatMatch>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::mozilla::safebrowsing::ThreatEntry& threat(const ThreatMatch* msg);
  static void set_has_threat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatEntryMetadata& threat_entry_metadata(const ThreatMatch* msg);
  static void set_has_threat_entry_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::Duration& cache_duration(const ThreatMatch* msg);
  static void set_has_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mozilla::safebrowsing::ThreatEntry&
ThreatMatch::_Internal::threat(const ThreatMatch* msg) {
  return *msg->threat_;
}
const ::mozilla::safebrowsing::ThreatEntryMetadata&
ThreatMatch::_Internal::threat_entry_metadata(const ThreatMatch* msg) {
  return *msg->threat_entry_metadata_;
}
const ::mozilla::safebrowsing::Duration&
ThreatMatch::_Internal::cache_duration(const ThreatMatch* msg) {
  return *msg->cache_duration_;
}
ThreatMatch::ThreatMatch()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatMatch)
}
ThreatMatch::ThreatMatch(const ThreatMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_threat()) {
    threat_ = new ::mozilla::safebrowsing::ThreatEntry(*from.threat_);
  } else {
    threat_ = nullptr;
  }
  if (from._internal_has_threat_entry_metadata()) {
    threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata(*from.threat_entry_metadata_);
  } else {
    threat_entry_metadata_ = nullptr;
  }
  if (from._internal_has_cache_duration()) {
    cache_duration_ = new ::mozilla::safebrowsing::Duration(*from.cache_duration_);
  } else {
    cache_duration_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatMatch)
}

void ThreatMatch::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatMatch_safebrowsing_2eproto.base);
  ::memset(&threat_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&threat_)) + sizeof(threat_entry_type_));
}

ThreatMatch::~ThreatMatch() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatMatch)
  SharedDtor();
}

void ThreatMatch::SharedDtor() {
  if (this != internal_default_instance()) delete threat_;
  if (this != internal_default_instance()) delete threat_entry_metadata_;
  if (this != internal_default_instance()) delete cache_duration_;
}

void ThreatMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatMatch& ThreatMatch::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatMatch_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatMatch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(threat_ != nullptr);
      threat_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_entry_metadata_ != nullptr);
      threat_entry_metadata_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cache_duration_ != nullptr);
      cache_duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatMatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_entry_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration cache_duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatMatch::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatMatch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::threat(this), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::threat_entry_metadata(this), target, stream);
  }

  // optional .mozilla.safebrowsing.Duration cache_duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::cache_duration(this), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatMatch)
  return target;
}

size_t ThreatMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatMatch)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_);
    }

    // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_entry_metadata_);
    }

    // optional .mozilla.safebrowsing.Duration cache_duration = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cache_duration_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatMatch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatMatch*>(
      &from));
}

void ThreatMatch::MergeFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatMatch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_threat()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(from._internal_threat());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_entry_metadata()->::mozilla::safebrowsing::ThreatEntryMetadata::MergeFrom(from._internal_threat_entry_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from._internal_cache_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatMatch::CopyFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatMatch::IsInitialized() const {
  return true;
}

void ThreatMatch::InternalSwap(ThreatMatch* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(threat_, other->threat_);
  swap(threat_entry_metadata_, other->threat_entry_metadata_);
  swap(cache_duration_, other->cache_duration_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
}

std::string ThreatMatch::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatMatch";
}


// ===================================================================

void FindThreatMatchesRequest::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FindThreatMatchesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  ::mozilla::safebrowsing::_FindThreatMatchesRequest_default_instance_._instance.get_mutable()->threat_info_ = const_cast< ::mozilla::safebrowsing::ThreatInfo*>(
      ::mozilla::safebrowsing::ThreatInfo::internal_default_instance());
}
class FindThreatMatchesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindThreatMatchesRequest>()._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FindThreatMatchesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatInfo& threat_info(const FindThreatMatchesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FindThreatMatchesRequest::_Internal::client(const FindThreatMatchesRequest* msg) {
  return *msg->client_;
}
const ::mozilla::safebrowsing::ThreatInfo&
FindThreatMatchesRequest::_Internal::threat_info(const FindThreatMatchesRequest* msg) {
  return *msg->threat_info_;
}
FindThreatMatchesRequest::FindThreatMatchesRequest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}
FindThreatMatchesRequest::FindThreatMatchesRequest(const FindThreatMatchesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_threat_info()) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}

void FindThreatMatchesRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FindThreatMatchesRequest_safebrowsing_2eproto.base);
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindThreatMatchesRequest::~FindThreatMatchesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesRequest)
  SharedDtor();
}

void FindThreatMatchesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindThreatMatchesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FindThreatMatchesRequest& FindThreatMatchesRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FindThreatMatchesRequest_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FindThreatMatchesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != nullptr);
      threat_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FindThreatMatchesRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FindThreatMatchesRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::client(this), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::threat_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindThreatMatchesRequest)
  return target;
}

size_t FindThreatMatchesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FindThreatMatchesRequest*>(
      &from));
}

void FindThreatMatchesRequest::MergeFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(from._internal_threat_info());
    }
  }
}

void FindThreatMatchesRequest::CopyFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesRequest::IsInitialized() const {
  return true;
}

void FindThreatMatchesRequest::InternalSwap(FindThreatMatchesRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(client_, other->client_);
  swap(threat_info_, other->threat_info_);
}

std::string FindThreatMatchesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesRequest";
}


// ===================================================================

void FindThreatMatchesResponse::InitAsDefaultInstance() {
}
class FindThreatMatchesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FindThreatMatchesResponse>()._has_bits_);
};

FindThreatMatchesResponse::FindThreatMatchesResponse()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}
FindThreatMatchesResponse::FindThreatMatchesResponse(const FindThreatMatchesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}

void FindThreatMatchesResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FindThreatMatchesResponse_safebrowsing_2eproto.base);
}

FindThreatMatchesResponse::~FindThreatMatchesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesResponse)
  SharedDtor();
}

void FindThreatMatchesResponse::SharedDtor() {
}

void FindThreatMatchesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FindThreatMatchesResponse& FindThreatMatchesResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FindThreatMatchesResponse_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FindThreatMatchesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FindThreatMatchesResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FindThreatMatchesResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_matches_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_matches(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindThreatMatchesResponse)
  return target;
}

size_t FindThreatMatchesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FindThreatMatchesResponse*>(
      &from));
}

void FindThreatMatchesResponse::MergeFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
}

void FindThreatMatchesResponse::CopyFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesResponse::IsInitialized() const {
  return true;
}

void FindThreatMatchesResponse::InternalSwap(FindThreatMatchesResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  matches_.InternalSwap(&other->matches_);
}

std::string FindThreatMatchesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesResponse";
}


// ===================================================================

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InitAsDefaultInstance() {
}
class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>()._has_bits_);
  static void set_has_max_update_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_database_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      supported_compressions_(from.supported_compressions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  region_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_region()) {
    region_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.region_);
  }
  ::memcpy(&max_update_entries_, &from.max_update_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_database_entries_) -
    reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto.base);
  region_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&max_update_entries_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_database_entries_) -
      reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedDtor() {
  region_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_compressions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    region_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&max_update_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_database_entries_) -
        reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 max_update_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_max_update_entries(&has_bits);
          max_update_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_database_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_database_entries(&has_bits);
          max_database_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_region();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::CompressionType_IsValid(val))) {
              _internal_add_supported_compressions(static_cast<::mozilla::safebrowsing::CompressionType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_supported_compressions(), ptr, ctx, ::mozilla::safebrowsing::CompressionType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 max_update_entries = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_update_entries(), target);
  }

  // optional int32 max_database_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_database_entries(), target);
  }

  // optional string region = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_region(), target);
  }

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  for (int i = 0, n = this->_internal_supported_compressions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        4, this->_internal_supported_compressions(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_compressions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_compressions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string region = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region());
    }

    // optional int32 max_update_entries = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_update_entries());
    }

    // optional int32 max_database_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_database_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  supported_compressions_.MergeFrom(from.supported_compressions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      region_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.region_);
    }
    if (cached_has_bits & 0x00000002u) {
      max_update_entries_ = from.max_update_entries_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_database_entries_ = from.max_database_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_compressions_.InternalSwap(&other->supported_compressions_);
  region_.Swap(&other->region_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(max_update_entries_, other->max_update_entries_);
  swap(max_database_entries_, other->max_database_entries_);
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
}


// ===================================================================

void FetchThreatListUpdatesRequest_ListUpdateRequest::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_._instance.get_mutable()->constraints_ = const_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::internal_default_instance());
}
class FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg);
  static void set_has_constraints(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&
FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal::constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg) {
  return *msg->constraints_;
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_state()) {
    state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.state_);
  }
  if (from._internal_has_constraints()) {
    constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(*from.constraints_);
  } else {
    constraints_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto.base);
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&constraints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&constraints_)) + sizeof(threat_entry_type_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest::~FetchThreatListUpdatesRequest_ListUpdateRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  SharedDtor();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedDtor() {
  state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete constraints_;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest_ListUpdateRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FetchThreatListUpdatesRequest_ListUpdateRequest_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FetchThreatListUpdatesRequest_ListUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      state_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(constraints_ != nullptr);
      constraints_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_constraints(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional bytes state = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_state(), target);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::constraints(this), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes state = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_state());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *constraints_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.state_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_constraints()->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(from._internal_constraints());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  state_.Swap(&other->state_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(constraints_, other->constraints_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
}


// ===================================================================

void FetchThreatListUpdatesRequest::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  ::mozilla::safebrowsing::_FetchThreatListUpdatesRequest_default_instance_._instance.get_mutable()->chrome_client_info_ = const_cast< ::mozilla::safebrowsing::ChromeClientInfo*>(
      ::mozilla::safebrowsing::ChromeClientInfo::internal_default_instance());
}
class FetchThreatListUpdatesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest>()._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FetchThreatListUpdatesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ChromeClientInfo& chrome_client_info(const FetchThreatListUpdatesRequest* msg);
  static void set_has_chrome_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FetchThreatListUpdatesRequest::_Internal::client(const FetchThreatListUpdatesRequest* msg) {
  return *msg->client_;
}
const ::mozilla::safebrowsing::ChromeClientInfo&
FetchThreatListUpdatesRequest::_Internal::chrome_client_info(const FetchThreatListUpdatesRequest* msg) {
  return *msg->chrome_client_info_;
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      list_update_requests_(from.list_update_requests_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_chrome_client_info()) {
    chrome_client_info_ = new ::mozilla::safebrowsing::ChromeClientInfo(*from.chrome_client_info_);
  } else {
    chrome_client_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}

void FetchThreatListUpdatesRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FetchThreatListUpdatesRequest_safebrowsing_2eproto.base);
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chrome_client_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(chrome_client_info_));
}

FetchThreatListUpdatesRequest::~FetchThreatListUpdatesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  SharedDtor();
}

void FetchThreatListUpdatesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete chrome_client_info_;
}

void FetchThreatListUpdatesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FetchThreatListUpdatesRequest& FetchThreatListUpdatesRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FetchThreatListUpdatesRequest_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FetchThreatListUpdatesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_requests_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(chrome_client_info_ != nullptr);
      chrome_client_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FetchThreatListUpdatesRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_client_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetchThreatListUpdatesRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::client(this), target, stream);
  }

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_list_update_requests_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_list_update_requests(i), target, stream);
  }

  // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::chrome_client_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  total_size += 1UL * this->_internal_list_update_requests_size();
  for (const auto& msg : this->list_update_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chrome_client_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchThreatListUpdatesRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest::MergeFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_requests_.MergeFrom(from.list_update_requests_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_chrome_client_info()->::mozilla::safebrowsing::ChromeClientInfo::MergeFrom(from._internal_chrome_client_info());
    }
  }
}

void FetchThreatListUpdatesRequest::CopyFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest::InternalSwap(FetchThreatListUpdatesRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_update_requests_.InternalSwap(&other->list_update_requests_);
  swap(client_, other->client_);
  swap(chrome_client_info_, other->chrome_client_info_);
}

std::string FetchThreatListUpdatesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest";
}


// ===================================================================

void FetchThreatListUpdatesResponse_ListUpdateResponse::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_._instance.get_mutable()->checksum_ = const_cast< ::mozilla::safebrowsing::Checksum*>(
      ::mozilla::safebrowsing::Checksum::internal_default_instance());
}
class FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse_ListUpdateResponse>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_response_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_new_client_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::Checksum& checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg);
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::Checksum&
FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal::checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg) {
  return *msg->checksum_;
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      additions_(from.additions_),
      removals_(from.removals_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  new_client_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_new_client_state()) {
    new_client_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.new_client_state_);
  }
  if (from._internal_has_checksum()) {
    checksum_ = new ::mozilla::safebrowsing::Checksum(*from.checksum_);
  } else {
    checksum_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto.base);
  new_client_state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&checksum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&response_type_) -
      reinterpret_cast<char*>(&checksum_)) + sizeof(response_type_));
}

FetchThreatListUpdatesResponse_ListUpdateResponse::~FetchThreatListUpdatesResponse_ListUpdateResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  SharedDtor();
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedDtor() {
  new_client_state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete checksum_;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse_ListUpdateResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FetchThreatListUpdatesResponse_ListUpdateResponse_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FetchThreatListUpdatesResponse_ListUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additions_.Clear();
  removals_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      new_client_state_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(checksum_ != nullptr);
      checksum_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&response_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(val))) {
            _internal_set_response_type(static_cast<::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_removals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bytes new_client_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_new_client_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Checksum checksum = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_checksum(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_threat_entry_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_response_type(), target);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_additions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_additions(i), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_removals_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_removals(i), target, stream);
  }

  // optional bytes new_client_state = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_new_client_state(), target);
  }

  // optional .mozilla.safebrowsing.Checksum checksum = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::checksum(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse_ListUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  total_size += 1UL * this->_internal_additions_size();
  for (const auto& msg : this->additions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  total_size += 1UL * this->_internal_removals_size();
  for (const auto& msg : this->removals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes new_client_state = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_client_state());
    }

    // optional .mozilla.safebrowsing.Checksum checksum = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *checksum_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_response_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  additions_.MergeFrom(from.additions_);
  removals_.MergeFrom(from.removals_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      new_client_state_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.new_client_state_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_checksum()->::mozilla::safebrowsing::Checksum::MergeFrom(from._internal_checksum());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      response_type_ = from.response_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  additions_.InternalSwap(&other->additions_);
  removals_.InternalSwap(&other->removals_);
  new_client_state_.Swap(&other->new_client_state_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(checksum_, other->checksum_);
  swap(threat_type_, other->threat_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
  swap(platform_type_, other->platform_type_);
  swap(response_type_, other->response_type_);
}

std::string FetchThreatListUpdatesResponse_ListUpdateResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
}


// ===================================================================

void FetchThreatListUpdatesResponse::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FetchThreatListUpdatesResponse_default_instance_._instance.get_mutable()->minimum_wait_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
}
class FetchThreatListUpdatesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse>()._has_bits_);
  static const ::mozilla::safebrowsing::Duration& minimum_wait_duration(const FetchThreatListUpdatesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::mozilla::safebrowsing::Duration&
FetchThreatListUpdatesResponse::_Internal::minimum_wait_duration(const FetchThreatListUpdatesResponse* msg) {
  return *msg->minimum_wait_duration_;
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      list_update_responses_(from.list_update_responses_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}

void FetchThreatListUpdatesResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FetchThreatListUpdatesResponse_safebrowsing_2eproto.base);
  minimum_wait_duration_ = nullptr;
}

FetchThreatListUpdatesResponse::~FetchThreatListUpdatesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  SharedDtor();
}

void FetchThreatListUpdatesResponse::SharedDtor() {
  if (this != internal_default_instance()) delete minimum_wait_duration_;
}

void FetchThreatListUpdatesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FetchThreatListUpdatesResponse& FetchThreatListUpdatesResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FetchThreatListUpdatesResponse_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FetchThreatListUpdatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_responses_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(minimum_wait_duration_ != nullptr);
    minimum_wait_duration_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FetchThreatListUpdatesResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetchThreatListUpdatesResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_list_update_responses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_list_update_responses(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::minimum_wait_duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  total_size += 1UL * this->_internal_list_update_responses_size();
  for (const auto& msg : this->list_update_responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *minimum_wait_duration_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FetchThreatListUpdatesResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse::MergeFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_responses_.MergeFrom(from.list_update_responses_);
  if (from._internal_has_minimum_wait_duration()) {
    _internal_mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from._internal_minimum_wait_duration());
  }
}

void FetchThreatListUpdatesResponse::CopyFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse::InternalSwap(FetchThreatListUpdatesResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_update_responses_.InternalSwap(&other->list_update_responses_);
  swap(minimum_wait_duration_, other->minimum_wait_duration_);
}

std::string FetchThreatListUpdatesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse";
}


// ===================================================================

void FindFullHashesRequest::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FindFullHashesRequest_default_instance_._instance.get_mutable()->client_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  ::mozilla::safebrowsing::_FindFullHashesRequest_default_instance_._instance.get_mutable()->threat_info_ = const_cast< ::mozilla::safebrowsing::ThreatInfo*>(
      ::mozilla::safebrowsing::ThreatInfo::internal_default_instance());
}
class FindFullHashesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesRequest>()._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FindFullHashesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatInfo& threat_info(const FindFullHashesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FindFullHashesRequest::_Internal::client(const FindFullHashesRequest* msg) {
  return *msg->client_;
}
const ::mozilla::safebrowsing::ThreatInfo&
FindFullHashesRequest::_Internal::threat_info(const FindFullHashesRequest* msg) {
  return *msg->threat_info_;
}
FindFullHashesRequest::FindFullHashesRequest()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindFullHashesRequest)
}
FindFullHashesRequest::FindFullHashesRequest(const FindFullHashesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      client_states_(from.client_states_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_threat_info()) {
    threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesRequest)
}

void FindFullHashesRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FindFullHashesRequest_safebrowsing_2eproto.base);
  ::memset(&client_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_info_) -
      reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindFullHashesRequest::~FindFullHashesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesRequest)
  SharedDtor();
}

void FindFullHashesRequest::SharedDtor() {
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindFullHashesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FindFullHashesRequest& FindFullHashesRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FindFullHashesRequest_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FindFullHashesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_states_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != nullptr);
      threat_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FindFullHashesRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes client_states = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_client_states();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FindFullHashesRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindFullHashesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::client(this), target, stream);
  }

  // repeated bytes client_states = 2;
  for (int i = 0, n = this->_internal_client_states_size(); i < n; i++) {
    const auto& s = this->_internal_client_states(i);
    target = stream->WriteBytes(2, s, target);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::threat_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindFullHashesRequest)
  return target;
}

size_t FindFullHashesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes client_states = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(client_states_.size());
  for (int i = 0, n = client_states_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      client_states_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FindFullHashesRequest*>(
      &from));
}

void FindFullHashesRequest::MergeFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  client_states_.MergeFrom(from.client_states_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(from._internal_threat_info());
    }
  }
}

void FindFullHashesRequest::CopyFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesRequest::IsInitialized() const {
  return true;
}

void FindFullHashesRequest::InternalSwap(FindFullHashesRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_states_.InternalSwap(&other->client_states_);
  swap(client_, other->client_);
  swap(threat_info_, other->threat_info_);
}

std::string FindFullHashesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesRequest";
}


// ===================================================================

void FindFullHashesResponse::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_FindFullHashesResponse_default_instance_._instance.get_mutable()->minimum_wait_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
  ::mozilla::safebrowsing::_FindFullHashesResponse_default_instance_._instance.get_mutable()->negative_cache_duration_ = const_cast< ::mozilla::safebrowsing::Duration*>(
      ::mozilla::safebrowsing::Duration::internal_default_instance());
}
class FindFullHashesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesResponse>()._has_bits_);
  static const ::mozilla::safebrowsing::Duration& minimum_wait_duration(const FindFullHashesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::Duration& negative_cache_duration(const FindFullHashesResponse* msg);
  static void set_has_negative_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::Duration&
FindFullHashesResponse::_Internal::minimum_wait_duration(const FindFullHashesResponse* msg) {
  return *msg->minimum_wait_duration_;
}
const ::mozilla::safebrowsing::Duration&
FindFullHashesResponse::_Internal::negative_cache_duration(const FindFullHashesResponse* msg) {
  return *msg->negative_cache_duration_;
}
FindFullHashesResponse::FindFullHashesResponse()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.FindFullHashesResponse)
}
FindFullHashesResponse::FindFullHashesResponse(const FindFullHashesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = nullptr;
  }
  if (from._internal_has_negative_cache_duration()) {
    negative_cache_duration_ = new ::mozilla::safebrowsing::Duration(*from.negative_cache_duration_);
  } else {
    negative_cache_duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesResponse)
}

void FindFullHashesResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FindFullHashesResponse_safebrowsing_2eproto.base);
  ::memset(&minimum_wait_duration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&negative_cache_duration_) -
      reinterpret_cast<char*>(&minimum_wait_duration_)) + sizeof(negative_cache_duration_));
}

FindFullHashesResponse::~FindFullHashesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesResponse)
  SharedDtor();
}

void FindFullHashesResponse::SharedDtor() {
  if (this != internal_default_instance()) delete minimum_wait_duration_;
  if (this != internal_default_instance()) delete negative_cache_duration_;
}

void FindFullHashesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FindFullHashesResponse& FindFullHashesResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FindFullHashesResponse_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void FindFullHashesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(minimum_wait_duration_ != nullptr);
      minimum_wait_duration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(negative_cache_duration_ != nullptr);
      negative_cache_duration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FindFullHashesResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_cache_duration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FindFullHashesResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindFullHashesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_matches_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_matches(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::minimum_wait_duration(this), target, stream);
  }

  // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::negative_cache_duration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindFullHashesResponse)
  return target;
}

size_t FindFullHashesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *minimum_wait_duration_);
    }

    // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *negative_cache_duration_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FindFullHashesResponse*>(
      &from));
}

void FindFullHashesResponse::MergeFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from._internal_minimum_wait_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_negative_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(from._internal_negative_cache_duration());
    }
  }
}

void FindFullHashesResponse::CopyFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesResponse::IsInitialized() const {
  return true;
}

void FindFullHashesResponse::InternalSwap(FindFullHashesResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  matches_.InternalSwap(&other->matches_);
  swap(minimum_wait_duration_, other->minimum_wait_duration_);
  swap(negative_cache_duration_, other->negative_cache_duration_);
}

std::string FindFullHashesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesResponse";
}


// ===================================================================

void ThreatHit_ThreatSource::InitAsDefaultInstance() {
}
class ThreatHit_ThreatSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit_ThreatSource>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatHit_ThreatSource::ThreatHit_ThreatSource()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}
ThreatHit_ThreatSource::ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_url()) {
    url_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_);
  }
  remote_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_remote_ip()) {
    remote_ip_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.remote_ip_);
  }
  referrer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_referrer()) {
    referrer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.referrer_);
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}

void ThreatHit_ThreatSource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatHit_ThreatSource_safebrowsing_2eproto.base);
  url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  remote_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  referrer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
}

ThreatHit_ThreatSource::~ThreatHit_ThreatSource() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
  SharedDtor();
}

void ThreatHit_ThreatSource::SharedDtor() {
  url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  remote_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  referrer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ThreatHit_ThreatSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatHit_ThreatSource& ThreatHit_ThreatSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatHit_ThreatSource_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatHit_ThreatSource::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      remote_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      referrer_.ClearNonDefaultToEmptyNoArena();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatHit_ThreatSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::mozilla::safebrowsing::ThreatHit_ThreatSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string remote_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_remote_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string referrer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_referrer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatHit_ThreatSource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string remote_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_remote_ip(), target);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit.ThreatSource)
  return target;
}

size_t ThreatHit_ThreatSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string remote_ip = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_ip());
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer());
    }

    // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit_ThreatSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatHit_ThreatSource*>(
      &from));
}

void ThreatHit_ThreatSource::MergeFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      url_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      remote_ip_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.remote_ip_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      referrer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.referrer_);
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatHit_ThreatSource::CopyFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_ThreatSource::IsInitialized() const {
  return true;
}

void ThreatHit_ThreatSource::InternalSwap(ThreatHit_ThreatSource* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  url_.Swap(&other->url_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  remote_ip_.Swap(&other->remote_ip_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  referrer_.Swap(&other->referrer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
}

std::string ThreatHit_ThreatSource::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.ThreatSource";
}


// ===================================================================

void ThreatHit_UserInfo::InitAsDefaultInstance() {
}
class ThreatHit_UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit_UserInfo>()._has_bits_);
  static void set_has_region_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatHit_UserInfo::ThreatHit_UserInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}
ThreatHit_UserInfo::ThreatHit_UserInfo(const ThreatHit_UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  region_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_region_code()) {
    region_code_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.region_code_);
  }
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_user_id()) {
    user_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_id_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}

void ThreatHit_UserInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatHit_UserInfo_safebrowsing_2eproto.base);
  region_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ThreatHit_UserInfo::~ThreatHit_UserInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.UserInfo)
  SharedDtor();
}

void ThreatHit_UserInfo::SharedDtor() {
  region_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ThreatHit_UserInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatHit_UserInfo& ThreatHit_UserInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatHit_UserInfo_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatHit_UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      region_code_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatHit_UserInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string region_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_region_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatHit_UserInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string region_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_region_code(), target);
  }

  // optional bytes user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit.UserInfo)
  return target;
}

size_t ThreatHit_UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string region_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region_code());
    }

    // optional bytes user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit_UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatHit_UserInfo*>(
      &from));
}

void ThreatHit_UserInfo::MergeFrom(const ThreatHit_UserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      region_code_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.region_code_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      user_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_id_);
    }
  }
}

void ThreatHit_UserInfo::CopyFrom(const ThreatHit_UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_UserInfo::IsInitialized() const {
  return true;
}

void ThreatHit_UserInfo::InternalSwap(ThreatHit_UserInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  region_code_.Swap(&other->region_code_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  user_id_.Swap(&other->user_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string ThreatHit_UserInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.UserInfo";
}


// ===================================================================

void ThreatHit::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_ThreatHit_default_instance_._instance.get_mutable()->entry_ = const_cast< ::mozilla::safebrowsing::ThreatEntry*>(
      ::mozilla::safebrowsing::ThreatEntry::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatHit_default_instance_._instance.get_mutable()->client_info_ = const_cast< ::mozilla::safebrowsing::ClientInfo*>(
      ::mozilla::safebrowsing::ClientInfo::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatHit_default_instance_._instance.get_mutable()->user_info_ = const_cast< ::mozilla::safebrowsing::ThreatHit_UserInfo*>(
      ::mozilla::safebrowsing::ThreatHit_UserInfo::internal_default_instance());
}
class ThreatHit::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mozilla::safebrowsing::ThreatEntry& entry(const ThreatHit* msg);
  static void set_has_entry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ClientInfo& client_info(const ThreatHit* msg);
  static void set_has_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::ThreatHit_UserInfo& user_info(const ThreatHit* msg);
  static void set_has_user_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mozilla::safebrowsing::ThreatEntry&
ThreatHit::_Internal::entry(const ThreatHit* msg) {
  return *msg->entry_;
}
const ::mozilla::safebrowsing::ClientInfo&
ThreatHit::_Internal::client_info(const ThreatHit* msg) {
  return *msg->client_info_;
}
const ::mozilla::safebrowsing::ThreatHit_UserInfo&
ThreatHit::_Internal::user_info(const ThreatHit* msg) {
  return *msg->user_info_;
}
ThreatHit::ThreatHit()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatHit)
}
ThreatHit::ThreatHit(const ThreatHit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      resources_(from.resources_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_entry()) {
    entry_ = new ::mozilla::safebrowsing::ThreatEntry(*from.entry_);
  } else {
    entry_ = nullptr;
  }
  if (from._internal_has_client_info()) {
    client_info_ = new ::mozilla::safebrowsing::ClientInfo(*from.client_info_);
  } else {
    client_info_ = nullptr;
  }
  if (from._internal_has_user_info()) {
    user_info_ = new ::mozilla::safebrowsing::ThreatHit_UserInfo(*from.user_info_);
  } else {
    user_info_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit)
}

void ThreatHit::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatHit_safebrowsing_2eproto.base);
  ::memset(&entry_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&platform_type_) -
      reinterpret_cast<char*>(&entry_)) + sizeof(platform_type_));
}

ThreatHit::~ThreatHit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit)
  SharedDtor();
}

void ThreatHit::SharedDtor() {
  if (this != internal_default_instance()) delete entry_;
  if (this != internal_default_instance()) delete client_info_;
  if (this != internal_default_instance()) delete user_info_;
}

void ThreatHit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatHit& ThreatHit::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatHit_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatHit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resources_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(entry_ != nullptr);
      entry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_info_ != nullptr);
      client_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(user_info_ != nullptr);
      user_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&platform_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatHit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatHit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::entry(this), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_resources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_resources(i), target, stream);
  }

  // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::client_info(this), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::user_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit)
  return target;
}

size_t ThreatHit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *entry_);
    }

    // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_info_);
    }

    // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_info_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatHit*>(
      &from));
}

void ThreatHit::MergeFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  resources_.MergeFrom(from.resources_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_entry()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(from._internal_entry());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_info()->::mozilla::safebrowsing::ClientInfo::MergeFrom(from._internal_client_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_user_info()->::mozilla::safebrowsing::ThreatHit_UserInfo::MergeFrom(from._internal_user_info());
    }
    if (cached_has_bits & 0x00000008u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatHit::CopyFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit::IsInitialized() const {
  return true;
}

void ThreatHit::InternalSwap(ThreatHit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  resources_.InternalSwap(&other->resources_);
  swap(entry_, other->entry_);
  swap(client_info_, other->client_info_);
  swap(user_info_, other->user_info_);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
}

std::string ThreatHit::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit";
}


// ===================================================================

void ClientInfo::InitAsDefaultInstance() {
}
class ClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientInfo>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientInfo::ClientInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ClientInfo)
}
ClientInfo::ClientInfo(const ClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_id()) {
    client_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_id_);
  }
  client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_client_version()) {
    client_version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_version_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ClientInfo)
}

void ClientInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ClientInfo_safebrowsing_2eproto.base);
  client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  client_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ClientInfo::~ClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ClientInfo)
  SharedDtor();
}

void ClientInfo::SharedDtor() {
  client_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  client_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ClientInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientInfo& ClientInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ClientInfo_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ClientInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      client_version_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ClientInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_client_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ClientInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ClientInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_id(), target);
  }

  // optional string client_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ClientInfo)
  return target;
}

size_t ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ClientInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string client_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_id());
    }

    // optional string client_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ClientInfo*>(
      &from));
}

void ClientInfo::MergeFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      client_id_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      client_version_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.client_version_);
    }
  }
}

void ClientInfo::CopyFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientInfo::IsInitialized() const {
  return true;
}

void ClientInfo::InternalSwap(ClientInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_id_.Swap(&other->client_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  client_version_.Swap(&other->client_version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string ClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ClientInfo";
}


// ===================================================================

void ChromeClientInfo::InitAsDefaultInstance() {
}
class ChromeClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeClientInfo>()._has_bits_);
  static void set_has_reporting_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChromeClientInfo::ChromeClientInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ChromeClientInfo)
}
ChromeClientInfo::ChromeClientInfo(const ChromeClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  reporting_population_ = from.reporting_population_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ChromeClientInfo)
}

void ChromeClientInfo::SharedCtor() {
  reporting_population_ = 0;
}

ChromeClientInfo::~ChromeClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ChromeClientInfo)
  SharedDtor();
}

void ChromeClientInfo::SharedDtor() {
}

void ChromeClientInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChromeClientInfo& ChromeClientInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ChromeClientInfo_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ChromeClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ChromeClientInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reporting_population_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ChromeClientInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(val))) {
            _internal_set_reporting_population(static_cast<::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ChromeClientInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ChromeClientInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reporting_population(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ChromeClientInfo)
  return target;
}

size_t ChromeClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ChromeClientInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reporting_population());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ChromeClientInfo*>(
      &from));
}

void ChromeClientInfo::MergeFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ChromeClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reporting_population()) {
    _internal_set_reporting_population(from._internal_reporting_population());
  }
}

void ChromeClientInfo::CopyFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ChromeClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeClientInfo::IsInitialized() const {
  return true;
}

void ChromeClientInfo::InternalSwap(ChromeClientInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(reporting_population_, other->reporting_population_);
}

std::string ChromeClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ChromeClientInfo";
}


// ===================================================================

void Checksum::InitAsDefaultInstance() {
}
class Checksum::_Internal {
 public:
  using HasBits = decltype(std::declval<Checksum>()._has_bits_);
  static void set_has_sha256(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Checksum::Checksum()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.Checksum)
}
Checksum::Checksum(const Checksum& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sha256_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sha256()) {
    sha256_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sha256_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Checksum)
}

void Checksum::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Checksum_safebrowsing_2eproto.base);
  sha256_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Checksum::~Checksum() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Checksum)
  SharedDtor();
}

void Checksum::SharedDtor() {
  sha256_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Checksum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Checksum& Checksum::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Checksum_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void Checksum::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Checksum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sha256_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Checksum::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes sha256 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_sha256();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Checksum::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.Checksum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes sha256 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha256(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.Checksum)
  return target;
}

size_t Checksum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Checksum)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes sha256 = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha256());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Checksum::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Checksum*>(
      &from));
}

void Checksum::MergeFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Checksum)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sha256()) {
    _has_bits_[0] |= 0x00000001u;
    sha256_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sha256_);
  }
}

void Checksum::CopyFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Checksum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Checksum::IsInitialized() const {
  return true;
}

void Checksum::InternalSwap(Checksum* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sha256_.Swap(&other->sha256_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string Checksum::GetTypeName() const {
  return "mozilla.safebrowsing.Checksum";
}


// ===================================================================

void ThreatEntry::InitAsDefaultInstance() {
}
class ThreatEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntry>()._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntry::ThreatEntry()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntry)
}
ThreatEntry::ThreatEntry(const ThreatEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_url()) {
    url_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntry)
}

void ThreatEntry::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatEntry_safebrowsing_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ThreatEntry::~ThreatEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntry)
  SharedDtor();
}

void ThreatEntry::SharedDtor() {
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ThreatEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatEntry& ThreatEntry::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatEntry_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      url_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatEntry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntry)
  return target;
}

size_t ThreatEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatEntry*>(
      &from));
}

void ThreatEntry::MergeFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      url_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.url_);
    }
  }
}

void ThreatEntry::CopyFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntry::IsInitialized() const {
  return true;
}

void ThreatEntry::InternalSwap(ThreatEntry* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  url_.Swap(&other->url_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string ThreatEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntry";
}


// ===================================================================

void ThreatEntrySet::InitAsDefaultInstance() {
  ::mozilla::safebrowsing::_ThreatEntrySet_default_instance_._instance.get_mutable()->raw_hashes_ = const_cast< ::mozilla::safebrowsing::RawHashes*>(
      ::mozilla::safebrowsing::RawHashes::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatEntrySet_default_instance_._instance.get_mutable()->raw_indices_ = const_cast< ::mozilla::safebrowsing::RawIndices*>(
      ::mozilla::safebrowsing::RawIndices::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatEntrySet_default_instance_._instance.get_mutable()->rice_hashes_ = const_cast< ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      ::mozilla::safebrowsing::RiceDeltaEncoding::internal_default_instance());
  ::mozilla::safebrowsing::_ThreatEntrySet_default_instance_._instance.get_mutable()->rice_indices_ = const_cast< ::mozilla::safebrowsing::RiceDeltaEncoding*>(
      ::mozilla::safebrowsing::RiceDeltaEncoding::internal_default_instance());
}
class ThreatEntrySet::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntrySet>()._has_bits_);
  static void set_has_compression_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mozilla::safebrowsing::RawHashes& raw_hashes(const ThreatEntrySet* msg);
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::RawIndices& raw_indices(const ThreatEntrySet* msg);
  static void set_has_raw_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_hashes(const ThreatEntrySet* msg);
  static void set_has_rice_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_indices(const ThreatEntrySet* msg);
  static void set_has_rice_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::mozilla::safebrowsing::RawHashes&
ThreatEntrySet::_Internal::raw_hashes(const ThreatEntrySet* msg) {
  return *msg->raw_hashes_;
}
const ::mozilla::safebrowsing::RawIndices&
ThreatEntrySet::_Internal::raw_indices(const ThreatEntrySet* msg) {
  return *msg->raw_indices_;
}
const ::mozilla::safebrowsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_hashes(const ThreatEntrySet* msg) {
  return *msg->rice_hashes_;
}
const ::mozilla::safebrowsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_indices(const ThreatEntrySet* msg) {
  return *msg->rice_indices_;
}
ThreatEntrySet::ThreatEntrySet()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntrySet)
}
ThreatEntrySet::ThreatEntrySet(const ThreatEntrySet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_raw_hashes()) {
    raw_hashes_ = new ::mozilla::safebrowsing::RawHashes(*from.raw_hashes_);
  } else {
    raw_hashes_ = nullptr;
  }
  if (from._internal_has_raw_indices()) {
    raw_indices_ = new ::mozilla::safebrowsing::RawIndices(*from.raw_indices_);
  } else {
    raw_indices_ = nullptr;
  }
  if (from._internal_has_rice_hashes()) {
    rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from.rice_hashes_);
  } else {
    rice_hashes_ = nullptr;
  }
  if (from._internal_has_rice_indices()) {
    rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from.rice_indices_);
  } else {
    rice_indices_ = nullptr;
  }
  compression_type_ = from.compression_type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntrySet)
}

void ThreatEntrySet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatEntrySet_safebrowsing_2eproto.base);
  ::memset(&raw_hashes_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&compression_type_) -
      reinterpret_cast<char*>(&raw_hashes_)) + sizeof(compression_type_));
}

ThreatEntrySet::~ThreatEntrySet() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntrySet)
  SharedDtor();
}

void ThreatEntrySet::SharedDtor() {
  if (this != internal_default_instance()) delete raw_hashes_;
  if (this != internal_default_instance()) delete raw_indices_;
  if (this != internal_default_instance()) delete rice_hashes_;
  if (this != internal_default_instance()) delete rice_indices_;
}

void ThreatEntrySet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatEntrySet& ThreatEntrySet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatEntrySet_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatEntrySet::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntrySet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(raw_hashes_ != nullptr);
      raw_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(raw_indices_ != nullptr);
      raw_indices_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rice_hashes_ != nullptr);
      rice_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rice_indices_ != nullptr);
      rice_indices_->Clear();
    }
  }
  compression_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatEntrySet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::CompressionType_IsValid(val))) {
            _internal_set_compression_type(static_cast<::mozilla::safebrowsing::CompressionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_hashes(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_indices(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_hashes(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_indices(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatEntrySet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntrySet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_compression_type(), target);
  }

  // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::raw_hashes(this), target, stream);
  }

  // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::raw_indices(this), target, stream);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::rice_hashes(this), target, stream);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::rice_indices(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntrySet)
  return target;
}

size_t ThreatEntrySet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntrySet)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_hashes_);
    }

    // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_indices_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rice_hashes_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rice_indices_);
    }

    // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_compression_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntrySet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatEntrySet*>(
      &from));
}

void ThreatEntrySet::MergeFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntrySet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_raw_hashes()->::mozilla::safebrowsing::RawHashes::MergeFrom(from._internal_raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_raw_indices()->::mozilla::safebrowsing::RawIndices::MergeFrom(from._internal_raw_indices());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rice_hashes()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(from._internal_rice_hashes());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rice_indices()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(from._internal_rice_indices());
    }
    if (cached_has_bits & 0x00000010u) {
      compression_type_ = from.compression_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatEntrySet::CopyFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntrySet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntrySet::IsInitialized() const {
  return true;
}

void ThreatEntrySet::InternalSwap(ThreatEntrySet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(raw_hashes_, other->raw_hashes_);
  swap(raw_indices_, other->raw_indices_);
  swap(rice_hashes_, other->rice_hashes_);
  swap(rice_indices_, other->rice_indices_);
  swap(compression_type_, other->compression_type_);
}

std::string ThreatEntrySet::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntrySet";
}


// ===================================================================

void RawIndices::InitAsDefaultInstance() {
}
class RawIndices::_Internal {
 public:
  using HasBits = decltype(std::declval<RawIndices>()._has_bits_);
};

RawIndices::RawIndices()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RawIndices)
}
RawIndices::RawIndices(const RawIndices& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      indices_(from.indices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawIndices)
}

void RawIndices::SharedCtor() {
}

RawIndices::~RawIndices() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawIndices)
  SharedDtor();
}

void RawIndices::SharedDtor() {
}

void RawIndices::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RawIndices& RawIndices::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RawIndices_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void RawIndices::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawIndices)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  indices_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RawIndices::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int32 indices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_indices(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RawIndices::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RawIndices)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  for (int i = 0, n = this->_internal_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_indices(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RawIndices)
  return target;
}

size_t RawIndices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawIndices)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->indices_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_indices_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawIndices::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RawIndices*>(
      &from));
}

void RawIndices::MergeFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawIndices)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  indices_.MergeFrom(from.indices_);
}

void RawIndices::CopyFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawIndices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawIndices::IsInitialized() const {
  return true;
}

void RawIndices::InternalSwap(RawIndices* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  indices_.InternalSwap(&other->indices_);
}

std::string RawIndices::GetTypeName() const {
  return "mozilla.safebrowsing.RawIndices";
}


// ===================================================================

void RawHashes::InitAsDefaultInstance() {
}
class RawHashes::_Internal {
 public:
  using HasBits = decltype(std::declval<RawHashes>()._has_bits_);
  static void set_has_prefix_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RawHashes::RawHashes()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RawHashes)
}
RawHashes::RawHashes(const RawHashes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  raw_hashes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_raw_hashes()) {
    raw_hashes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.raw_hashes_);
  }
  prefix_size_ = from.prefix_size_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawHashes)
}

void RawHashes::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RawHashes_safebrowsing_2eproto.base);
  raw_hashes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  prefix_size_ = 0;
}

RawHashes::~RawHashes() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawHashes)
  SharedDtor();
}

void RawHashes::SharedDtor() {
  raw_hashes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RawHashes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RawHashes& RawHashes::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RawHashes_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void RawHashes::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawHashes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    raw_hashes_.ClearNonDefaultToEmptyNoArena();
  }
  prefix_size_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RawHashes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 prefix_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_prefix_size(&has_bits);
          prefix_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_raw_hashes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RawHashes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RawHashes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 prefix_size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_prefix_size(), target);
  }

  // optional bytes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_hashes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RawHashes)
  return target;
}

size_t RawHashes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawHashes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_hashes());
    }

    // optional int32 prefix_size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_prefix_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawHashes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RawHashes*>(
      &from));
}

void RawHashes::MergeFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawHashes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      raw_hashes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.raw_hashes_);
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_size_ = from.prefix_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RawHashes::CopyFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawHashes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawHashes::IsInitialized() const {
  return true;
}

void RawHashes::InternalSwap(RawHashes* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  raw_hashes_.Swap(&other->raw_hashes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(prefix_size_, other->prefix_size_);
}

std::string RawHashes::GetTypeName() const {
  return "mozilla.safebrowsing.RawHashes";
}


// ===================================================================

void RiceDeltaEncoding::InitAsDefaultInstance() {
}
class RiceDeltaEncoding::_Internal {
 public:
  using HasBits = decltype(std::declval<RiceDeltaEncoding>()._has_bits_);
  static void set_has_first_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rice_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encoded_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RiceDeltaEncoding::RiceDeltaEncoding()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}
RiceDeltaEncoding::RiceDeltaEncoding(const RiceDeltaEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  encoded_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encoded_data()) {
    encoded_data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.encoded_data_);
  }
  ::memcpy(&first_value_, &from.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_entries_) -
    reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}

void RiceDeltaEncoding::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RiceDeltaEncoding_safebrowsing_2eproto.base);
  encoded_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&first_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_entries_) -
      reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
}

RiceDeltaEncoding::~RiceDeltaEncoding() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RiceDeltaEncoding)
  SharedDtor();
}

void RiceDeltaEncoding::SharedDtor() {
  encoded_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RiceDeltaEncoding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RiceDeltaEncoding& RiceDeltaEncoding::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RiceDeltaEncoding_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void RiceDeltaEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RiceDeltaEncoding)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    encoded_data_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&first_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_entries_) -
        reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RiceDeltaEncoding::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 first_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_first_value(&has_bits);
          first_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 rice_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_rice_parameter(&has_bits);
          rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_entries(&has_bits);
          num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes encoded_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RiceDeltaEncoding::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RiceDeltaEncoding)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 first_value = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_first_value(), target);
  }

  // optional int32 rice_parameter = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_rice_parameter(), target);
  }

  // optional int32 num_entries = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_entries(), target);
  }

  // optional bytes encoded_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RiceDeltaEncoding)
  return target;
}

size_t RiceDeltaEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RiceDeltaEncoding)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes encoded_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encoded_data());
    }

    // optional int64 first_value = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_first_value());
    }

    // optional int32 rice_parameter = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_rice_parameter());
    }

    // optional int32 num_entries = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RiceDeltaEncoding*>(
      &from));
}

void RiceDeltaEncoding::MergeFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      encoded_data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.encoded_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      first_value_ = from.first_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      rice_parameter_ = from.rice_parameter_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_entries_ = from.num_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RiceDeltaEncoding::CopyFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoding::IsInitialized() const {
  return true;
}

void RiceDeltaEncoding::InternalSwap(RiceDeltaEncoding* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  encoded_data_.Swap(&other->encoded_data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(first_value_, other->first_value_);
  swap(rice_parameter_, other->rice_parameter_);
  swap(num_entries_, other->num_entries_);
}

std::string RiceDeltaEncoding::GetTypeName() const {
  return "mozilla.safebrowsing.RiceDeltaEncoding";
}


// ===================================================================

void ThreatEntryMetadata_MetadataEntry::InitAsDefaultInstance() {
}
class ThreatEntryMetadata_MetadataEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntryMetadata_MetadataEntry>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}
ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}

void ThreatEntryMetadata_MetadataEntry::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ThreatEntryMetadata_MetadataEntry::~ThreatEntryMetadata_MetadataEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  SharedDtor();
}

void ThreatEntryMetadata_MetadataEntry::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ThreatEntryMetadata_MetadataEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata_MetadataEntry::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatEntryMetadata_MetadataEntry_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatEntryMetadata_MetadataEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatEntryMetadata_MetadataEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatEntryMetadata_MetadataEntry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  return target;
}

size_t ThreatEntryMetadata_MetadataEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata_MetadataEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatEntryMetadata_MetadataEntry*>(
      &from));
}

void ThreatEntryMetadata_MetadataEntry::MergeFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      value_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
}

void ThreatEntryMetadata_MetadataEntry::CopyFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata_MetadataEntry::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata_MetadataEntry::InternalSwap(ThreatEntryMetadata_MetadataEntry* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string ThreatEntryMetadata_MetadataEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry";
}


// ===================================================================

void ThreatEntryMetadata::InitAsDefaultInstance() {
}
class ThreatEntryMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntryMetadata>()._has_bits_);
};

ThreatEntryMetadata::ThreatEntryMetadata()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}
ThreatEntryMetadata::ThreatEntryMetadata(const ThreatEntryMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}

void ThreatEntryMetadata::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThreatEntryMetadata_safebrowsing_2eproto.base);
}

ThreatEntryMetadata::~ThreatEntryMetadata() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata)
  SharedDtor();
}

void ThreatEntryMetadata::SharedDtor() {
}

void ThreatEntryMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatEntryMetadata& ThreatEntryMetadata::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatEntryMetadata_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatEntryMetadata::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatEntryMetadata::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntryMetadata)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntryMetadata)
  return target;
}

size_t ThreatEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatEntryMetadata*>(
      &from));
}

void ThreatEntryMetadata::MergeFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
}

void ThreatEntryMetadata::CopyFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata::InternalSwap(ThreatEntryMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
}

std::string ThreatEntryMetadata::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata";
}


// ===================================================================

void ThreatListDescriptor::InitAsDefaultInstance() {
}
class ThreatListDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatListDescriptor>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatListDescriptor::ThreatListDescriptor()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ThreatListDescriptor)
}
ThreatListDescriptor::ThreatListDescriptor(const ThreatListDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatListDescriptor)
}

void ThreatListDescriptor::SharedCtor() {
  ::memset(&threat_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&threat_entry_type_) -
      reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
}

ThreatListDescriptor::~ThreatListDescriptor() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatListDescriptor)
  SharedDtor();
}

void ThreatListDescriptor::SharedDtor() {
}

void ThreatListDescriptor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThreatListDescriptor& ThreatListDescriptor::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThreatListDescriptor_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ThreatListDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatListDescriptor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ThreatListDescriptor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThreatListDescriptor::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatListDescriptor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatListDescriptor)
  return target;
}

size_t ThreatListDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatListDescriptor)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatListDescriptor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ThreatListDescriptor*>(
      &from));
}

void ThreatListDescriptor::MergeFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThreatListDescriptor::CopyFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatListDescriptor::IsInitialized() const {
  return true;
}

void ThreatListDescriptor::InternalSwap(ThreatListDescriptor* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(threat_type_, other->threat_type_);
  swap(platform_type_, other->platform_type_);
  swap(threat_entry_type_, other->threat_entry_type_);
}

std::string ThreatListDescriptor::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatListDescriptor";
}


// ===================================================================

void ListThreatListsResponse::InitAsDefaultInstance() {
}
class ListThreatListsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ListThreatListsResponse>()._has_bits_);
};

ListThreatListsResponse::ListThreatListsResponse()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.ListThreatListsResponse)
}
ListThreatListsResponse::ListThreatListsResponse(const ListThreatListsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      threat_lists_(from.threat_lists_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ListThreatListsResponse)
}

void ListThreatListsResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ListThreatListsResponse_safebrowsing_2eproto.base);
}

ListThreatListsResponse::~ListThreatListsResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ListThreatListsResponse)
  SharedDtor();
}

void ListThreatListsResponse::SharedDtor() {
}

void ListThreatListsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ListThreatListsResponse& ListThreatListsResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ListThreatListsResponse_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void ListThreatListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ListThreatListsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_lists_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ListThreatListsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ListThreatListsResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ListThreatListsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_threat_lists_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_threat_lists(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ListThreatListsResponse)
  return target;
}

size_t ListThreatListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ListThreatListsResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  total_size += 1UL * this->_internal_threat_lists_size();
  for (const auto& msg : this->threat_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListThreatListsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ListThreatListsResponse*>(
      &from));
}

void ListThreatListsResponse::MergeFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  threat_lists_.MergeFrom(from.threat_lists_);
}

void ListThreatListsResponse::CopyFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListThreatListsResponse::IsInitialized() const {
  return true;
}

void ListThreatListsResponse::InternalSwap(ListThreatListsResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  threat_lists_.InternalSwap(&other->threat_lists_);
}

std::string ListThreatListsResponse::GetTypeName() const {
  return "mozilla.safebrowsing.ListThreatListsResponse";
}


// ===================================================================

void Duration::InitAsDefaultInstance() {
}
class Duration::_Internal {
 public:
  using HasBits = decltype(std::declval<Duration>()._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Duration::Duration()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mozilla.safebrowsing.Duration)
}
Duration::Duration(const Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Duration)
}

void Duration::SharedCtor() {
  ::memset(&seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nanos_) -
      reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Duration::~Duration() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Duration)
  SharedDtor();
}

void Duration::SharedDtor() {
}

void Duration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Duration& Duration::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Duration_safebrowsing_2eproto.base);
  return *internal_default_instance();
}


void Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Duration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Duration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Duration::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.Duration)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.Duration)
  return target;
}

size_t Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Duration)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_seconds());
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_nanos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Duration*>(
      &from));
}

void Duration::MergeFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Duration)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Duration::CopyFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Duration::IsInitialized() const {
  return true;
}

void Duration::InternalSwap(Duration* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(seconds_, other->seconds_);
  swap(nanos_, other->nanos_);
}

std::string Duration::GetTypeName() const {
  return "mozilla.safebrowsing.Duration";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace safebrowsing
}  // namespace mozilla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatInfo* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatInfo >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatMatch* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatMatch >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindThreatMatchesRequest* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindThreatMatchesRequest >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FindThreatMatchesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindThreatMatchesResponse* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindThreatMatchesResponse >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FindThreatMatchesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesResponse* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindFullHashesRequest* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindFullHashesRequest >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FindFullHashesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindFullHashesResponse* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindFullHashesResponse >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::FindFullHashesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit_ThreatSource* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit_ThreatSource >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatHit_ThreatSource >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit_UserInfo* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit_UserInfo >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatHit_UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatHit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ClientInfo* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ClientInfo >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ChromeClientInfo* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ChromeClientInfo >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ChromeClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::Checksum* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::Checksum >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::Checksum >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntry* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntry >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntrySet* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntrySet >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatEntrySet >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RawIndices* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RawIndices >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::RawIndices >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RawHashes* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RawHashes >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::RawHashes >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RiceDeltaEncoding* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RiceDeltaEncoding >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::RiceDeltaEncoding >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntryMetadata* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntryMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatEntryMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatListDescriptor* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatListDescriptor >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ThreatListDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ListThreatListsResponse* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ListThreatListsResponse >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::ListThreatListsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::Duration* Arena::CreateMaybeMessage< ::mozilla::safebrowsing::Duration >(Arena* arena) {
  return Arena::CreateInternal< ::mozilla::safebrowsing::Duration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
