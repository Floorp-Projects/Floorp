// -*- mode: C++ -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.
{# The rendered source is autogenerated, but this
Jinja2 template is not. Please file bugs! #}

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef mozilla_GleanJSPingsLookup_h
#define mozilla_GleanJSPingsLookup_h

#define GLEAN_PING_INDEX_BITS ({{ping_index_bits}})
#define GLEAN_PING_ID(entry) ((entry) >> GLEAN_PING_INDEX_BITS)
#define GLEAN_PING_INDEX(entry) ((entry) & ((1UL << GLEAN_PING_INDEX_BITS) - 1))

namespace mozilla::glean {

// Contains the ping id and the index into the ping string table.
using ping_entry_t = uint32_t;

static Maybe<uint32_t> ping_result_check(const nsACString& aKey, ping_entry_t aEntry);

{{ ping_string_table }}

{{ ping_by_name_lookup }}

/**
 * Get a ping's name given its entry from the PHF.
 */
static const char* GetPingName(ping_entry_t aEntry) {
  uint32_t idx = GLEAN_PING_INDEX(aEntry);
  MOZ_ASSERT(idx < sizeof(gPingStringTable), "Ping index larger than string table");
  return &gPingStringTable[idx];
}

/**
 * Check if the found entry is pointing at the correct ping.
 * PHF can false-positive a result when the key isn't present, so we check
 * for a string match. If it fails, return Nothing(). If we found it,
 * return the ping's id.
 */
static Maybe<uint32_t> ping_result_check(const nsACString& aKey, ping_entry_t aEntry) {
  uint32_t idx = GLEAN_PING_INDEX(aEntry);
  uint32_t id = GLEAN_PING_ID(aEntry);

  if (MOZ_UNLIKELY(idx > sizeof(gPingStringTable))) {
    return Nothing();
  }

  if (aKey.EqualsASCII(&gPingStringTable[idx])) {
    return Some(id);
  }

  return Nothing();
}

#undef GLEAN_PING_INDEX_BITS
#undef GLEAN_PING_ID
#undef GLEAN_PING_INDEX

}  // namespace mozilla::glean
#endif  // mozilla_GleanJSPingsLookup_h
