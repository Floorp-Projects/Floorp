// -*- mode: C++ -*-

/* This file is auto-generated by run_glean_parser.py.
   It is only for internal use by types in
   toolkit/components/glean/bindings/private */
{# The rendered source is autogenerated, but this
Jinja2 template is not. Pleas file bugs! #}

#include "mozilla/Maybe.h"
#include "mozilla/Telemetry.h"
#include "mozilla/DataMutex.h"
{% if probe_type == "Scalar" %}
#include "mozilla/Tuple.h"
#include "nsClassHashtable.h"
#include "nsTHashMap.h"
{% endif %}

#ifndef mozilla_glean_{{ probe_type }}GifftMap_h
#define mozilla_glean_{{ probe_type }}GifftMap_h

namespace mozilla::glean {

using Telemetry::{{ probe_type }}ID;

{% if probe_type == "Histogram" %}
typedef uint64_t TimerId; // Same as in TimingDistribution.h.
typedef StaticDataMutex<UniquePtr<nsTHashMap<TimerId, TimeStamp>>> TimerToStampMutex;
static inline TimerToStampMutex::AutoLock GetTimerIdToStartsLock() {
  static TimerToStampMutex sTimerIdToStarts("sTimerIdToStarts");
  auto lock = sTimerIdToStarts.Lock();
  if (!*lock) {
    *lock = MakeUnique<nsTHashMap<TimerId, TimeStamp>>();
  }
  return lock;
}
{% elif probe_type == "Scalar" %}
typedef nsUint32HashKey SubmetricIdHashKey;
typedef nsTHashMap<SubmetricIdHashKey, Tuple<ScalarID, nsString>>
    SubmetricToLabeledMirrorMapType;
typedef StaticDataMutex<UniquePtr<SubmetricToLabeledMirrorMapType>>
    SubmetricToMirrorMutex;
static inline SubmetricToMirrorMutex::AutoLock GetLabeledMirrorLock() {
  static SubmetricToMirrorMutex sLabeledMirrors("sLabeledMirrors");
  auto lock = sLabeledMirrors.Lock();
  if (!*lock) {
    *lock = MakeUnique<SubmetricToLabeledMirrorMapType>();
  }
  return lock;
}

namespace {
class ScalarIDHashKey : public PLDHashEntryHdr {
 public:
  typedef const ScalarID& KeyType;
  typedef const ScalarID* KeyTypePointer;

  explicit ScalarIDHashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  ScalarIDHashKey(ScalarIDHashKey&& aOther)
      : PLDHashEntryHdr(std::move(aOther)), mValue(std::move(aOther.mValue)) {}
  ~ScalarIDHashKey() = default;

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) {
    return static_cast<std::underlying_type<ScalarID>::type>(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

 private:
  const ScalarID mValue;
};
}  // namespace
typedef StaticDataMutex<UniquePtr<nsTHashMap<ScalarIDHashKey, TimeStamp>>> TimesToStartsMutex;
static inline TimesToStartsMutex::AutoLock GetTimesToStartsLock() {
  static TimesToStartsMutex sTimespanStarts("sTimespanStarts");
  auto lock = sTimespanStarts.Lock();
  if (!*lock) {
    *lock = MakeUnique<nsTHashMap<ScalarIDHashKey, TimeStamp>>();
  }
  return lock;
}

static inline bool IsSubmetricId(uint32_t aId) {
  return aId > (1 << 27); // Kept in sync with js.py's ID_BITS, rust.py's min_submetric_id
}
{% endif %}

static{% if probe_type == "Event" %} inline{% endif %} Maybe<{{ probe_type }}ID> {{ probe_type }}IdForMetric(uint32_t aId) {
  switch(aId) {
{% for id, (mirror, metric_name) in ids_to_probes.items() %}
    case {{ id }}: { // {{ metric_name }}
      return Some({{ probe_type }}ID::{{ mirror }});
    }
{% endfor %}
    default: {
      return Nothing();
    }
  }
}

}  // namespace mozilla::glean
#endif  // mozilla_glean_{{ probe_type }}GifftMaps_h
