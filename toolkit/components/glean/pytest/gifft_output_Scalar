// -*- mode: C++ -*-

/* This file is auto-generated by run_glean_parser.py.
   It is only for internal use by types in
   toolkit/components/glean/bindings/private */

#include "mozilla/Maybe.h"
#include "mozilla/Telemetry.h"
#include "mozilla/DataMutex.h"
#include "mozilla/Tuple.h"
#include "nsClassHashtable.h"
#include "nsTHashMap.h"

#ifndef mozilla_glean_ScalarGifftMap_h
#define mozilla_glean_ScalarGifftMap_h

namespace mozilla::glean {

using Telemetry::ScalarID;

typedef nsUint32HashKey SubmetricIdHashKey;
typedef nsTHashMap<SubmetricIdHashKey, Tuple<ScalarID, nsString>>
    SubmetricToLabeledMirrorMapType;
typedef StaticDataMutex<UniquePtr<SubmetricToLabeledMirrorMapType>>
    SubmetricToMirrorMutex;
static SubmetricToMirrorMutex::AutoLock GetLabeledMirrorLock() {
  static SubmetricToMirrorMutex sLabeledMirrors("sLabeledMirrors");
  auto lock = sLabeledMirrors.Lock();
  if (!*lock) {
    *lock = MakeUnique<SubmetricToLabeledMirrorMapType>();
  }
  return lock;
}

namespace {
class ScalarIDHashKey : public PLDHashEntryHdr {
 public:
  typedef const ScalarID& KeyType;
  typedef const ScalarID* KeyTypePointer;

  explicit ScalarIDHashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  ScalarIDHashKey(ScalarIDHashKey&& aOther)
      : PLDHashEntryHdr(std::move(aOther)), mValue(std::move(aOther.mValue)) {}
  ~ScalarIDHashKey() = default;

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) {
    return static_cast<std::underlying_type<ScalarID>::type>(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

 private:
  const ScalarID mValue;
};
}  // namespace
typedef StaticDataMutex<UniquePtr<nsTHashMap<ScalarIDHashKey, TimeStamp>>> TimesToStartsMutex;
static TimesToStartsMutex::AutoLock GetTimesToStartsLock() {
  static TimesToStartsMutex sTimespanStarts("sTimespanStarts");
  auto lock = sTimespanStarts.Lock();
  if (!*lock) {
    *lock = MakeUnique<nsTHashMap<ScalarIDHashKey, TimeStamp>>();
  }
  return lock;
}

static inline bool IsSubmetricId(uint32_t aId) {
  return aId > (1 << 27); // Kept in sync with js.py's ID_BITS, rust.py's min_submetric_id
}

static Maybe<ScalarID> ScalarIdForMetric(uint32_t aId) {
  switch(aId) {
    case 1: { // test.boolean_metric
      return Some(ScalarID::SOME_BOOL_SCALAR);
    }
    case 2: { // test.labeled_boolean_metric
      return Some(ScalarID::SOME_KEYED_BOOL_SCALAR);
    }
    case 3: { // test.labeled_boolean_metric_labels
      return Some(ScalarID::SOME_OTHER_KEYED_BOOL_SCALAR);
    }
    case 4: { // test.counter_metric
      return Some(ScalarID::SOME_UINT_SCALAR);
    }
    case 5: { // test.labeled_counter_metric
      return Some(ScalarID::SOME_KEYED_UINT_SCALAR);
    }
    case 6: { // test.labeled_counter_metric_labels
      return Some(ScalarID::SOME_OTHER_KEYED_UINT_SCALAR);
    }
    case 7: { // test.string_metric
      return Some(ScalarID::SOME_STRING_SCALAR);
    }
    case 10: { // test.string_list_metric
      return Some(ScalarID::SOME_KEYED_BOOL_SCALAR);
    }
    case 11: { // test.timespan_metric
      return Some(ScalarID::SOME_OTHER_UINT_SCALAR);
    }
    case 14: { // test.nested.uuid_metric
      return Some(ScalarID::SOME_OTHER_STRING_SCALAR);
    }
    case 15: { // test.nested.datetime_metric
      return Some(ScalarID::SOME_STILL_OTHER_STRING_SCALAR);
    }
    case 18: { // test.nested.quantity_metric
      return Some(ScalarID::TELEMETRY_TEST_MIRROR_FOR_QUANTITY);
    }
    default: {
      return Nothing();
    }
  }
}

}  // namespace mozilla::glean
#endif  // mozilla_glean_ScalarGifftMaps_h
