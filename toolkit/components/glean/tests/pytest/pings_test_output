// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use crate::private::Ping;
use once_cell::sync::Lazy;

#[allow(non_upper_case_globals)]
/// This ping is intended to provide metrics that are managed by the library
/// itself, and not explicitly set by the application or included in the
/// application's `metrics.yaml` file. The `baseline` ping is automatically sent
/// when the application is moved to the background.
pub static not_baseline: Lazy<Ping> = Lazy::new(|| {
    Ping::new(
        "not-baseline",
        true,
        false,
        true,
        vec!["background".into(), "dirty_startup".into(), "foreground".into()],
    )
});

#[allow(non_upper_case_globals)]
/// This ping is submitted when a user opts out of sending technical and
/// interaction data to Mozilla. This ping is intended to communicate to the Data
/// Pipeline that the user wishes to have their reported Telemetry data deleted. As
/// such it attempts to send itself at the moment the user opts out of data
/// collection.
pub static not_deletion_request: Lazy<Ping> = Lazy::new(|| {
    Ping::new(
        "not-deletion-request",
        true,
        true,
        true,
        vec![],
    )
});

#[allow(non_upper_case_globals)]
/// The events ping's purpose is to transport all of the event metric information.
/// The `events` ping is automatically sent when the application is moved to the
/// background.
pub static not_events: Lazy<Ping> = Lazy::new(|| {
    Ping::new(
        "not-events",
        true,
        false,
        true,
        vec!["background".into(), "max_capacity".into(), "startup".into()],
    )
});

#[allow(non_upper_case_globals)]
/// The `metrics` ping is intended for all of the metrics that are explicitly set
/// by the application or are included in the application's `metrics.yaml` file
/// (except events). The reported data is tied to the ping's *measurement window*,
/// which is the time between the collection of two `metrics` ping. Ideally, this
/// window is expected to be about 24 hours, given that the collection is scheduled
/// daily at 4AM. Data in the `ping_info` section of the ping can be used to infer
/// the length of this window.
pub static not_metrics: Lazy<Ping> = Lazy::new(|| {
    Ping::new(
        "not-metrics",
        true,
        false,
        true,
        vec!["overdue".into(), "reschedule".into(), "today".into(), "tomorrow".into(), "upgrade".into()],
    )
});


/// Instantiate custom pings once to trigger registration.
///
/// # Arguments
///
/// application_id: If present, limit to only registering custom pings
///                 assigned to the identified application.
#[doc(hidden)]
pub fn register_pings(application_id: Option<&str>) {
    match application_id {
        _ => {
            let _ = &*not_baseline;
            let _ = &*not_deletion_request;
            let _ = &*not_events;
            let _ = &*not_metrics;
        }
    }
}

#[cfg(feature = "with_gecko")]
pub(crate) fn submit_ping_by_id(id: u32, reason: Option<&str>) {
    if id & (1 << crate::factory::DYNAMIC_PING_BIT) > 0 {
        let map = crate::factory::__jog_metric_maps::PING_MAP
            .read()
            .expect("Read lock for dynamic ping map was poisoned!");
        if let Some(ping) = map.get(&id) {
            ping.submit(reason);
        } else {
            // TODO: instrument this error.
            log::error!("Cannot submit unknown dynamic ping {} by id.", id);
        }
        return;
    }
    match id {
        1 => not_baseline.submit(reason),
        2 => not_deletion_request.submit(reason),
        3 => not_events.submit(reason),
        4 => not_metrics.submit(reason),
        _ => {
            // TODO: instrument this error.
            log::error!("Cannot submit unknown ping {} by id.", id);
        }
    }
}
