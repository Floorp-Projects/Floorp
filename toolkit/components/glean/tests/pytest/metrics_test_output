// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

pub mod test {
    use crate::private::*;
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test.boolean_metric
    ///
    /// A multi-line
    /// description
    pub static boolean_metric: Lazy<BooleanMetric> = Lazy::new(|| {
        BooleanMetric::new(1.into(), CommonMetricData {
            name: "boolean_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric: Lazy<LabeledMetric<LabeledBooleanMetric>> = Lazy::new(|| {
        LabeledMetric::new(2.into(), CommonMetricData {
            name: "labeled_boolean_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, None)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_boolean_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric_labels: Lazy<LabeledMetric<LabeledBooleanMetric>> = Lazy::new(|| {
        LabeledMetric::new(3.into(), CommonMetricData {
            name: "labeled_boolean_metric_labels".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, Some(vec!["one_label".into(), "two_labels".into()]))
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.counter_metric
    ///
    /// A multi-line
    /// description
    pub static counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::new(4.into(), CommonMetricData {
            name: "counter_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_counter_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric: Lazy<LabeledMetric<LabeledCounterMetric>> = Lazy::new(|| {
        LabeledMetric::new(5.into(), CommonMetricData {
            name: "labeled_counter_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, None)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_counter_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric_labels: Lazy<LabeledMetric<LabeledCounterMetric>> = Lazy::new(|| {
        LabeledMetric::new(6.into(), CommonMetricData {
            name: "labeled_counter_metric_labels".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, Some(vec!["one_label".into(), "two_labels".into()]))
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.string_metric
    ///
    /// A multi-line
    /// description
    pub static string_metric: Lazy<StringMetric> = Lazy::new(|| {
        StringMetric::new(7.into(), CommonMetricData {
            name: "string_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_string_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric: Lazy<LabeledMetric<LabeledStringMetric>> = Lazy::new(|| {
        LabeledMetric::new(8.into(), CommonMetricData {
            name: "labeled_string_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, None)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_string_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric_labels: Lazy<LabeledMetric<LabeledStringMetric>> = Lazy::new(|| {
        LabeledMetric::new(9.into(), CommonMetricData {
            name: "labeled_string_metric_labels".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, Some(vec!["one_label".into(), "two_labels".into()]))
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.string_list_metric
    ///
    /// A multi-line
    /// description
    pub static string_list_metric: Lazy<StringListMetric> = Lazy::new(|| {
        StringListMetric::new(10.into(), CommonMetricData {
            name: "string_list_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.timespan_metric
    ///
    /// A multi-line
    /// description
    pub static timespan_metric: Lazy<TimespanMetric> = Lazy::new(|| {
        TimespanMetric::new(11.into(), CommonMetricData {
            name: "timespan_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Millisecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.timing_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static timing_distribution_metric: Lazy<TimingDistributionMetric> = Lazy::new(|| {
        TimingDistributionMetric::new(12.into(), CommonMetricData {
            name: "timing_distribution_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Nanosecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.memory_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static memory_distribution_metric: Lazy<MemoryDistributionMetric> = Lazy::new(|| {
        MemoryDistributionMetric::new(13.into(), CommonMetricData {
            name: "memory_distribution_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, MemoryUnit::Kilobyte)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.custom_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static custom_distribution_metric: Lazy<CustomDistributionMetric> = Lazy::new(|| {
        CustomDistributionMetric::new(14.into(), CommonMetricData {
            name: "custom_distribution_metric".into(),
            category: "test".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, 0, 100, 100, HistogramType::Linear)
    });

}
pub mod test_nested {
    use crate::private::*;
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.uuid_metric
    ///
    /// A multi-line
    /// description
    pub static uuid_metric: Lazy<UuidMetric> = Lazy::new(|| {
        UuidMetric::new(15.into(), CommonMetricData {
            name: "uuid_metric".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.datetime_metric
    ///
    /// A multi-line
    /// description
    pub static datetime_metric: Lazy<DatetimeMetric> = Lazy::new(|| {
        DatetimeMetric::new(16.into(), CommonMetricData {
            name: "datetime_metric".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Millisecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.event_metric
    ///
    /// A multi-line
    /// description
    pub static event_metric: Lazy<EventMetric<NoExtraKeys>> = Lazy::new(|| {
        EventMetric::new(17.into(), CommonMetricData {
            name: "event_metric".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    pub struct EventMetricWithExtraExtra {
        pub an_extra_key: Option<String>,
        pub another_extra_key: Option<String>,
    }

    impl ExtraKeys for EventMetricWithExtraExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["an_extra_key", "another_extra_key"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<String, String> {
          let mut map = ::std::collections::HashMap::new();
          self.an_extra_key.and_then(|val| map.insert("an_extra_key".into(), val.to_string()));
          self.another_extra_key.and_then(|val| map.insert("another_extra_key".into(), val.to_string()));
          map
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test.nested.event_metric_with_extra
    ///
    /// A multi-line
    /// description
    pub static event_metric_with_extra: Lazy<EventMetric<EventMetricWithExtraExtra>> = Lazy::new(|| {
        EventMetric::new(18.into(), CommonMetricData {
            name: "event_metric_with_extra".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.quantity_metric
    ///
    /// A multi-line
    /// description
    pub static quantity_metric: Lazy<QuantityMetric> = Lazy::new(|| {
        QuantityMetric::new(19.into(), CommonMetricData {
            name: "quantity_metric".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.rate_metric
    ///
    /// A multi-line
    /// description
    pub static rate_metric: Lazy<RateMetric> = Lazy::new(|| {
        RateMetric::new(20.into(), CommonMetricData {
            name: "rate_metric".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.rate_with_external_denominator
    ///
    /// A multi-line
    /// description
    pub static rate_with_external_denominator: Lazy<NumeratorMetric> = Lazy::new(|| {
        NumeratorMetric::new(21.into(), CommonMetricData {
            name: "rate_with_external_denominator".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.external_denominator
    ///
    /// A multi-line
    /// description
    pub static external_denominator: Lazy<DenominatorMetric> = Lazy::new(|| {
        DenominatorMetric::new(22.into(), CommonMetricData {
            name: "external_denominator".into(),
            category: "test.nested".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, vec![CommonMetricData {name: "rate_with_external_denominator".into(), category: "test.nested".into(), send_in_pings: vec!["metrics".into()], lifetime: Lifetime::Ping, disabled: false,  ..Default::default()}])
    });

}

#[allow(dead_code)]
pub(crate) mod __glean_metric_maps {
    use std::collections::HashMap;

    use crate::metrics::extra_keys_len;
    use crate::private::*;
    use once_cell::sync::Lazy;

    pub static BOOLEAN_MAP: Lazy<HashMap<MetricId, &Lazy<BooleanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(1.into(), &super::test::boolean_metric);
        map
    });

    pub static LABELED_BOOLEAN_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<LabeledBooleanMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(2.into(), &super::test::labeled_boolean_metric);
        map.insert(3.into(), &super::test::labeled_boolean_metric_labels);
        map
    });

    pub static COUNTER_MAP: Lazy<HashMap<MetricId, &Lazy<CounterMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(4.into(), &super::test::counter_metric);
        map
    });

    pub static LABELED_COUNTER_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<LabeledCounterMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(5.into(), &super::test::labeled_counter_metric);
        map.insert(6.into(), &super::test::labeled_counter_metric_labels);
        map
    });

    pub static STRING_MAP: Lazy<HashMap<MetricId, &Lazy<StringMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(7.into(), &super::test::string_metric);
        map
    });

    pub static LABELED_STRING_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<LabeledStringMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(8.into(), &super::test::labeled_string_metric);
        map.insert(9.into(), &super::test::labeled_string_metric_labels);
        map
    });

    pub static STRING_LIST_MAP: Lazy<HashMap<MetricId, &Lazy<StringListMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(10.into(), &super::test::string_list_metric);
        map
    });

    pub static TIMESPAN_MAP: Lazy<HashMap<MetricId, &Lazy<TimespanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(11.into(), &super::test::timespan_metric);
        map
    });

    pub static TIMING_DISTRIBUTION_MAP: Lazy<HashMap<MetricId, &Lazy<TimingDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(12.into(), &super::test::timing_distribution_metric);
        map
    });

    pub static MEMORY_DISTRIBUTION_MAP: Lazy<HashMap<MetricId, &Lazy<MemoryDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(13.into(), &super::test::memory_distribution_metric);
        map
    });

    pub static CUSTOM_DISTRIBUTION_MAP: Lazy<HashMap<MetricId, &Lazy<CustomDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(14.into(), &super::test::custom_distribution_metric);
        map
    });

    pub static UUID_MAP: Lazy<HashMap<MetricId, &Lazy<UuidMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(15.into(), &super::test_nested::uuid_metric);
        map
    });

    pub static DATETIME_MAP: Lazy<HashMap<MetricId, &Lazy<DatetimeMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(16.into(), &super::test_nested::datetime_metric);
        map
    });

    pub static QUANTITY_MAP: Lazy<HashMap<MetricId, &Lazy<QuantityMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(19.into(), &super::test_nested::quantity_metric);
        map
    });

    pub static RATE_MAP: Lazy<HashMap<MetricId, &Lazy<RateMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(20.into(), &super::test_nested::rate_metric);
        map
    });

    pub static NUMERATOR_MAP: Lazy<HashMap<MetricId, &Lazy<NumeratorMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(21.into(), &super::test_nested::rate_with_external_denominator);
        map
    });

    pub static DENOMINATOR_MAP: Lazy<HashMap<MetricId, &Lazy<DenominatorMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(22.into(), &super::test_nested::external_denominator);
        map
    });


    /// Wrapper to record an event based on its metric ID.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `extra`     - An map of (extra key id, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` type.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` if the `extra` map could not be deserialized.
    pub(crate) fn record_event_by_id(metric_id: u32, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          17 => {
              assert!(
                  extra_keys_len(&super::test_nested::event_metric) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              super::test_nested::event_metric.record_raw(extra);
              Ok(())
          }
          18 => {
              assert!(
                  extra_keys_len(&super::test_nested::event_metric_with_extra) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              super::test_nested::event_metric_with_extra.record_raw(extra);
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to record an event based on its metric ID, with a provided timestamp.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `timestamp` - The time at which this event was recorded.
    /// * `extra`     - An map of (extra key id, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` type.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` if the event doesn't take extra pairs,
    /// but some are passed in.
    pub(crate) fn record_event_by_id_with_time(metric_id: MetricId, timestamp: u64, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          MetricId(17) => {
              if extra_keys_len(&super::test_nested::event_metric) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test_nested::event_metric.record_with_time(timestamp, extra);
              Ok(())
          }
          MetricId(18) => {
              if extra_keys_len(&super::test_nested::event_metric_with_extra) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test_nested::event_metric_with_extra.record_with_time(timestamp, extra);
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to record an event based on its metric ID.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `extra`     - An map of (string, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` types.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` if the `extra` map could not be deserialized.
    pub(crate) fn record_event_by_id_with_strings(metric_id: u32, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          17 => {
              assert!(
                  extra_keys_len(&super::test_nested::event_metric) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              super::test_nested::event_metric.record_raw(extra);
              Ok(())
          }
          18 => {
              assert!(
                  extra_keys_len(&super::test_nested::event_metric_with_extra) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              super::test_nested::event_metric_with_extra.record_raw(extra);
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to get the currently stored events for event metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `ping_name` - (Optional) The ping name to look into.
    ///                 Defaults to the first value in `send_in_pings`.
    ///
    /// # Returns
    ///
    /// Returns the recorded events or `None` if nothing stored.
    ///
    /// # Panics
    ///
    /// Panics if no event by the given metric ID could be found.
    pub(crate) fn event_test_get_value_wrapper(metric_id: u32, ping_name: Option<String>) -> Option<Vec<RecordedEvent>> {
        match metric_id {
           17 => super::test_nested::event_metric.test_get_value(ping_name.as_deref()),
           18 => super::test_nested::event_metric_with_extra.test_get_value(ping_name.as_deref()),
           _ => panic!("No event for metric id {}", metric_id),
        }
    }

    /// Check the provided event for errors.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `ping_name` - (Optional) The ping name to look into.
    ///                 Defaults to the first value in `send_in_pings`.
    ///
    /// # Returns
    ///
    /// Returns a string for the recorded error or `None`.
    ///
    /// # Panics
    ///
    /// Panics if no event by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn event_test_get_error(metric_id: u32) -> Option<String> {
        #[cfg(feature = "with_gecko")]
        match metric_id {
           17 => test_get_errors!(super::test_nested::event_metric),
           18 => test_get_errors!(super::test_nested::event_metric_with_extra),
           _ => panic!("No event for metric id {}", metric_id),
        }

        #[cfg(not(feature = "with_gecko"))]
        {
            return None;
        }
    }

    pub(crate) mod submetric_maps {
        use std::sync::{
          atomic::AtomicU32,
          RwLock,
        };
        use super::*;

        pub(crate) const SUBMETRIC_BIT: u32 = 25;
        pub(crate) static NEXT_LABELED_SUBMETRIC_ID: AtomicU32 = AtomicU32::new((1 << SUBMETRIC_BIT) + 1);
        pub(crate) static LABELED_METRICS_TO_IDS: Lazy<RwLock<HashMap<(u32, String), u32>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );

        pub static BOOLEAN_MAP: Lazy<RwLock<HashMap<MetricId, LabeledBooleanMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static COUNTER_MAP: Lazy<RwLock<HashMap<MetricId, LabeledCounterMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static STRING_MAP: Lazy<RwLock<HashMap<MetricId, LabeledStringMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
    }
}

