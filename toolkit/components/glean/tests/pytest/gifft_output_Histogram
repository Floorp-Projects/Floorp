// -*- mode: C++ -*-

/* This file is auto-generated by run_glean_parser.py.
   It is only for internal use by types in
   toolkit/components/glean/bindings/private */

#include "mozilla/AppShutdown.h"
#include "mozilla/ClearOnShutdown.h"
#include "mozilla/Maybe.h"
#include "mozilla/Telemetry.h"
#include "mozilla/DataMutex.h"
#include "nsThreadUtils.h"

#ifndef mozilla_glean_HistogramGifftMap_h
#define mozilla_glean_HistogramGifftMap_h

namespace mozilla::glean {

using Telemetry::HistogramID;

typedef uint64_t TimerId; // Same as in TimingDistribution.h.
typedef StaticDataMutex<UniquePtr<nsTHashMap<TimerId, TimeStamp>>> TimerToStampMutex;
static inline Maybe<TimerToStampMutex::AutoLock> GetTimerIdToStartsLock() {
  static TimerToStampMutex sTimerIdToStarts("sTimerIdToStarts");
  auto lock = sTimerIdToStarts.Lock();
  // GIFFT will work up to the end of AppShutdownTelemetry.
  if (AppShutdown::IsInOrBeyond(ShutdownPhase::XPCOMWillShutdown)) {
    return Nothing();
  }
  if (!*lock) {
    *lock = MakeUnique<nsTHashMap<TimerId, TimeStamp>>();
    RefPtr<nsIRunnable> cleanupFn = NS_NewRunnableFunction(__func__, [&] {
      if (AppShutdown::IsInOrBeyond(ShutdownPhase::XPCOMWillShutdown)) {
        auto lock = sTimerIdToStarts.Lock();
        *lock = nullptr;  // deletes, see UniquePtr.h
        return;
      }
      RunOnShutdown([&] {
        auto lock = sTimerIdToStarts.Lock();
        *lock = nullptr;  // deletes, see UniquePtr.h
      }, ShutdownPhase::XPCOMWillShutdown);
    });
    // Both getting the main thread and dispatching to it can fail.
    // In that event we leak. Grab a pointer so we have something to NS_RELEASE
    // in that case.
    nsIRunnable* temp = cleanupFn.get();
    nsCOMPtr<nsIThread> mainThread;
    if (NS_FAILED(NS_GetMainThread(getter_AddRefs(mainThread)))
      || NS_FAILED(mainThread->Dispatch(cleanupFn.forget(), nsIThread::DISPATCH_NORMAL))
    ) {
      // Failed to dispatch cleanup routine.
      // First, un-leak the runnable (but only if we actually attempted dispatch)
      if (!cleanupFn) {
        NS_RELEASE(temp);
      }
      // Next, cleanup immediately, and allow metrics to try again later.
      *lock = nullptr;
      return Nothing();
    }
  }
  return Some(std::move(lock));
}

static Maybe<HistogramID> HistogramIdForMetric(uint32_t aId) {
  switch(aId) {
    case 12: { // test.timing_distribution_metric
      return Some(HistogramID::SOME_TIME_HISTOGRAM_MS);
    }
    case 13: { // test.memory_distribution_metric
      return Some(HistogramID::SOME_MEM_HISTOGRAM_KB);
    }
    case 14: { // test.custom_distribution_metric
      return Some(HistogramID::SOME_LINEAR_HISTOGRAM);
    }
    default: {
      return Nothing();
    }
  }
}

}  // namespace mozilla::glean
#endif  // mozilla_glean_HistogramGifftMaps_h
