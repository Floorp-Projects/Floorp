<?xml version="1.0"?>

<bindings id="arrowscrollboxBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="scrollbox-base" extends="chrome://global/content/bindings/general.xml#basecontrol">
    <resources>
      <stylesheet src="chrome://global/skin/scrollbox.css"/>
    </resources>
  </binding>

  <binding id="scrollbox" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content>
      <xul:box class="box-inherit scrollbox-innerbox" xbl:inherits="orient,align,pack,dir" flex="1">
        <children/>
      </xul:box>
    </content>
  </binding>

  <binding id="arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content>
      <xul:autorepeatbutton class="autorepeatbutton-up"
                            anonid="scrollbutton-up"
                            collapsed="true"
                            xbl:inherits="orient"
                            oncommand="_autorepeatbuttonScroll(event);"/>
      <xul:scrollbox xbl:inherits="orient,align,pack,dir" flex="1" anonid="scrollbox">
        <children/>
      </xul:scrollbox>
      <xul:autorepeatbutton class="autorepeatbutton-down"
                            anonid="scrollbutton-down"
                            collapsed="true"
                            xbl:inherits="orient"
                            oncommand="_autorepeatbuttonScroll(event);"/>
    </content>

    <implementation>
      <destructor><![CDATA[
        this._stopSmoothScroll();
      ]]></destructor>

      <field name="_scrollbox">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbox");
      </field>
      <field name="_scrollButtonUp">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up");
      </field>
      <field name="_scrollButtonDown">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down");
      </field>

      <field name="__prefBranch">null</field>
      <property name="_prefBranch" readonly="true">
        <getter><![CDATA[
          if (this.__prefBranch === null) {
            this.__prefBranch = Components.classes['@mozilla.org/preferences-service;1']
                                          .getService(Components.interfaces.nsIPrefBranch2);
          }
          return this.__prefBranch;
        ]]></getter>
      </property>

      <field name="_scrollIncrement">null</field>
      <property name="scrollIncrement" readonly="true">
        <getter><![CDATA[
          if (this._scrollIncrement === null) {
            try {
              this._scrollIncrement = this._prefBranch
                                          .getIntPref("toolkit.scrollbox.scrollIncrement");
            }
            catch (ex) {
              this._scrollIncrement = 20;
            }
          }
          return this._scrollIncrement;
        ]]></getter>
      </property>

      <field name="_smoothScroll">null</field>
      <property name="smoothScroll">
        <getter><![CDATA[
          if (this._smoothScroll === null) {
            if (this.hasAttribute("smoothscroll")) {
              this._smoothScroll = (this.getAttribute("smoothscroll") == "true");
            } else {
              try {
                this._smoothScroll = this._prefBranch
                                         .getBoolPref("toolkit.scrollbox.smoothScroll");
              }
              catch (ex) {
                this._smoothScroll = true;
              }
            }
          }
          return this._smoothScroll;
        ]]></getter>
        <setter><![CDATA[
          this._smoothScroll = val;
          return val;
        ]]></setter>
      </property>

      <field name="_scrollBoxObject">null</field>
      <property name="scrollBoxObject" readonly="true">
        <getter><![CDATA[
          if (!this._scrollBoxObject) {
            this._scrollBoxObject =
              this._scrollbox.boxObject
                             .QueryInterface(Components.interfaces.nsIScrollBoxObject);
          }
          return this._scrollBoxObject;
        ]]></getter>
      </property>

      <property name="scrollClientRect" readonly="true">
        <getter><![CDATA[
          return this._scrollbox.getBoundingClientRect();
        ]]></getter>
      </property>

      <property name="scrollClientSize" readonly="true">
        <getter><![CDATA[
          return this.orient == "vertical" ?
                 this._scrollbox.clientHeight :
                 this._scrollbox.clientWidth;
        ]]></getter>
      </property>

      <property name="scrollSize" readonly="true">
        <getter><![CDATA[
          return this.orient == "vertical" ?
                 this._scrollbox.scrollHeight :
                 this._scrollbox.scrollWidth;
        ]]></getter>
      </property>

      <property name="scrollPosition">
        <getter><![CDATA[
          return this.orient == "vertical" ?
                 this._scrollbox.scrollTop :
                 this._scrollbox.scrollLeft;
        ]]></getter>
        <setter><![CDATA[
          if (this.orient == "vertical")
            this._scrollbox.scrollTop = val;
          else
            this._scrollbox.scrollLeft = val;
          return val;
        ]]></setter>
      </property>

      <property name="_startEndProps" readonly="true">
        <getter><![CDATA[
          return this.orient == "vertical" ?
                 ["top", "bottom"] : ["left", "right"];
        ]]></getter>
      </property>

      <field name="_isRTLScrollbox"><![CDATA[
        this.orient != "vertical" &&
        document.defaultView.getComputedStyle(this._scrollbox, "").direction == "rtl";
      ]]></field>

      <field name="_scrollTarget">null</field>

      <method name="ensureElementIsVisible">
        <parameter name="element"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          var vertical = this.orient == "vertical";
          var rect = this.scrollClientRect;
          var containerStart = vertical ? rect.top : rect.left;
          var containerEnd = vertical ? rect.bottom : rect.right;
          rect = element.getBoundingClientRect();
          var elementStart = vertical ? rect.top : rect.left;
          var elementEnd = vertical ? rect.bottom : rect.right;
          var amountToScroll;

          if (elementStart < containerStart) {
            amountToScroll = elementStart - containerStart;
          } else if (containerEnd < elementEnd) {
            amountToScroll = elementEnd - containerEnd;
          } else if (this._isScrolling) {
            // decelerate if a currently-visible element is selected during the scroll
            const STOP_DISTANCE = 15;
            if (this._isScrolling == -1 && elementStart - STOP_DISTANCE < containerStart)
              amountToScroll = elementStart - containerStart;
            else if (this._isScrolling == 1 && containerEnd - STOP_DISTANCE < elementEnd)
              amountToScroll = elementEnd - containerEnd;
            else
              amountToScroll = this._isScrolling * STOP_DISTANCE;
          } else {
            return;
          }

          this._stopSmoothScroll();

          if (aSmoothScroll != false && this.smoothScroll) {
            this._scrollTarget = element;
            this._smoothScrollByPixels(amountToScroll);
          } else {
            this.scrollByPixels(amountToScroll);
          }
        ]]></body>
      </method>

      <method name="_smoothScrollByPixels">
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          if (amountToScroll == 0)
            return;

          this._stopSmoothScroll();

          // Positive amountToScroll makes us scroll right (elements fly left), negative scrolls left.
          var round;
          if (amountToScroll < 0) {
            this._isScrolling = -1;
            round = Math.floor;
          } else {
            this._isScrolling = 1;
            round = Math.ceil;
          }

          const FRAME_LENGTH = 60;

          function processFrame(self, scrollAmounts, off) {
            var distance = scrollAmounts.shift();

            // Skip frames if we aren't getting the desired frame rate.
            if (off > 0) {
              for (var i = Math.round(off / FRAME_LENGTH); i > 0; i--)
                distance += scrollAmounts.shift() || 0;
            }

            self.scrollByPixels(distance);
            if (!scrollAmounts.length)
              self._stopSmoothScroll();
          }

          // amountToScroll: total distance to scroll
          // scrollAmount: distance to move during the particular effect frame (60ms)
          var scrollAmount, scrollAmounts = [];
          if (amountToScroll > 2 || amountToScroll < -2) {
            scrollAmount = round(amountToScroll * 0.2);
            scrollAmounts.push(scrollAmount, scrollAmount, scrollAmount);
            amountToScroll -= 3 * scrollAmount;
          }
          while (this._isScrolling < 0 && amountToScroll < 0 ||
                 this._isScrolling > 0 && amountToScroll > 0) {
            amountToScroll -= (scrollAmount = round(amountToScroll * 0.5));
            scrollAmounts.push(scrollAmount);
          }
          this._smoothScrollTimer = setInterval(processFrame, FRAME_LENGTH, this, scrollAmounts);
          processFrame(this, scrollAmounts, 0);
        ]]></body>
      </method>

      <method name="scrollByIndex">
        <parameter name="index"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          if (index == 0)
            return;

          // Each scrollByIndex call is expected to scroll the given number of
          // items. If a previous call is still in progress because of smooth
          // scrolling, we need to complete it before starting a new one.
          if (this._scrollTarget) {
            let elements = this._getScrollableElements();
            if (this._scrollTarget != elements[0] &&
                this._scrollTarget != elements[elements.length - 1])
              this.ensureElementIsVisible(this._scrollTarget, false);
          }

          var rect = this.scrollClientRect;
          var [start, end] = this._startEndProps;
          var x = index > 0 ? rect[end] + 1 : rect[start] - 1;
          var nextElement = this._elementFromPoint(x, index);
          if (!nextElement)
            return;

          var targetElement;
          if (this._isRTLScrollbox)
            index *= -1;
          while (index < 0 && nextElement) {
            targetElement = nextElement;
            nextElement = nextElement.previousSibling;
            index++;
          }
          while (index > 0 && nextElement) {
            targetElement = nextElement;
            nextElement = nextElement.nextSibling;
            index--;
          }

          this.ensureElementIsVisible(targetElement, aSmoothScroll);
        ]]></body>
      </method>

      <method name="_getScrollableElements">
        <body><![CDATA[
          return this.hasChildNodes() ?
                   this.childNodes : document.getBindingParent(this).childNodes;
        ]]></body>
      </method>

      <method name="_elementFromPoint">
        <parameter name="aX"/>
        <parameter name="aPhysicalScrollDir"/>
        <body><![CDATA[
          var elements = this._getScrollableElements();
          if (!elements.length)
            return null;

          if (this._isRTLScrollbox) {
            elements = Array.slice(elements);
            elements.reverse();
          }

          var [start, end] = this._startEndProps;
          var low = 0;
          var high = elements.length - 1;

          if (aX < elements[low].getBoundingClientRect()[start] ||
              aX > elements[high].getBoundingClientRect()[end])
            return null;

          var mid, rect;
          while (low <= high) {
            mid = Math.floor((low + high) / 2);
            rect = elements[mid].getBoundingClientRect();
            if (rect[start] > aX)
              high = mid - 1; 
            else if (rect[end] < aX)
              low = mid + 1;
            else
              return elements[mid];
          }

          // There's no element at the requested coordinate, but the algorithm
          // from above yields an element next to it, in a random direction.
          // The desired scrolling direction leads to the correct element.

          if (!aPhysicalScrollDir)
            return null;

          if (aPhysicalScrollDir < 0 && rect[start] > aX)
            mid = Math.max(mid - 1, 0);
          else if (aPhysicalScrollDir > 0 && rect[end] < aX)
            mid = Math.min(mid + 1, elements.length - 1);

          return elements[mid];
        ]]></body>
      </method>

      <method name="_autorepeatbuttonScroll">
        <parameter name="event"/>
        <body><![CDATA[
          var dir = event.originalTarget == this._scrollButtonUp ? -1 : 1;
          if (this._isRTLScrollbox)
            dir *= -1;

          this.scrollByPixels(this.scrollIncrement * dir);

          event.stopPropagation();
        ]]></body>
      </method>

      <method name="scrollByPixels">
        <parameter name="px"/>
        <body><![CDATA[
          this.scrollPosition += px;
        ]]></body>
      </method>

      <!-- 0: idle
           1: scrolling right
          -1: scrolling left -->
      <field name="_isScrolling">0</field>
      <field name="_smoothScrollTimer">0</field>

      <method name="_stopSmoothScroll">
        <body><![CDATA[
          if (this._isScrolling) {
            clearInterval(this._smoothScrollTimer);
            this._isScrolling = 0;
            this._scrollTarget = null;
          }
        ]]></body>
      </method>

      <method name="_updateScrollButtonsDisabledState">
        <body><![CDATA[
          var disableUpButton = false;
          var disableDownButton = false;

          if (this.scrollPosition == 0) {
            // In the RTL case, this means the _last_ element in the
            // scrollbox is visible
            if (this._isRTLScrollbox) 
              disableDownButton = true;
            else
              disableUpButton = true;
          }
          else if (this.scrollClientSize + this.scrollPosition == this.scrollSize) {
            // In the RTL case, this means the _first_ element in the
            // scrollbox is visible
            if (this._isRTLScrollbox)
              disableUpButton = true;
            else
              disableDownButton = true;
          }

          this._scrollButtonUp.disabled = disableUpButton;
          this._scrollButtonDown.disabled = disableDownButton;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="DOMMouseScroll"><![CDATA[
        // prevent horizontal scrolling from scrolling a vertical scrollbox
        if (event.axis == event.HORIZONTAL_AXIS &&
            this.orient == "vertical")
          return;
        // We allow vertical scrolling to scroll a horizontal scrollbox
        // because many users have a vertical scroll wheel but no
        // horizontal support.

        this.scrollByIndex(event.detail);
        event.stopPropagation();
      ]]></handler>

      <handler event="underflow" phase="capturing"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore events that doesn't match our orientation.
        // Scrollport event orientation:
        //   0: vertical
        //   1: horizontal
        //   2: both
        if (this.orient == "vertical") {
          if (event.detail == 1)
            return;
        }
        else {    // horizontal scrollbox
          if (event.detail == 0)
            return;
        }

        this._scrollButtonUp.collapsed = true;
        this._scrollButtonDown.collapsed = true;
        try {
          // See bug 341047 and comments in overflow handler as to why 
          // try..catch is needed here
          let childNodes = this._getScrollableElements();
          if (childNodes && childNodes.length)
            this.ensureElementIsVisible(childNodes[0], false);
        }
        catch(e) {
          this._scrollButtonUp.collapsed = false;
          this._scrollButtonDown.collapsed = false;
        }
      ]]></handler>

      <handler event="overflow" phase="capturing"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore events that doesn't match our orientation.
        // Scrollport event orientation:
        //   0: vertical
        //   1: horizontal
        //   2: both
        if (this.orient == "vertical") {
          if (event.detail == 1)
            return;
        }
        else {    // horizontal scrollbox
          if (event.detail == 0)
            return;
        }

        this._scrollButtonUp.collapsed = false;
        this._scrollButtonDown.collapsed = false;
        try {
          // See bug 341047, the overflow event is dispatched when the 
          // scrollbox already is mostly destroyed. This causes some code in
          // _updateScrollButtonsDisabledState() to throw an error. It also
          // means that the scrollbarbuttons were uncollapsed when that should
          // not be happening, because the whole overflow event should not be
          // happening in that case.
          this._updateScrollButtonsDisabledState();
        } 
        catch(e) {
          this._scrollButtonUp.collapsed = true;
          this._scrollButtonDown.collapsed = true;
        }
      ]]></handler>

      <handler event="scroll" action="this._updateScrollButtonsDisabledState()"/>
    </handlers>
  </binding>

  <binding id="autorepeatbutton" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content repeat="hover">
      <xul:image class="autorepeatbutton-icon"/>
    </content>
  </binding>

  <binding id="arrowscrollbox-clicktoscroll" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox">
    <content>
      <xul:toolbarbutton class="scrollbutton-up" collapsed="true"
                         xbl:inherits="orient"
                         anonid="scrollbutton-up"
                         onclick="_distanceScroll(event);"
                         onmousedown="_startScroll(-1);"
                         onmouseover="_continueScroll(-1);"
                         onmouseup="_stopScroll();"
                         onmouseout="_pauseScroll();"/>
      <xul:scrollbox xbl:inherits="orient,align,pack,dir" flex="1" anonid="scrollbox">
        <children/>
      </xul:scrollbox>
      <xul:toolbarbutton class="scrollbutton-down" collapsed="true"
                         xbl:inherits="orient"
                         anonid="scrollbutton-down"
                         onclick="_distanceScroll(event);"
                         onmousedown="_startScroll(1);"
                         onmouseover="_continueScroll(1);"
                         onmouseup="_stopScroll();"
                         onmouseout="_pauseScroll();"/>
    </content>
    <implementation implements="nsITimerCallback, nsIDOMEventListener">
      <constructor><![CDATA[
        try {
          this._scrollDelay = this._prefBranch
                                  .getIntPref("toolkit.scrollbox.clickToScroll.scrollDelay");
        }
        catch (ex) {
        }
      ]]></constructor>

      <destructor><![CDATA[
        // Release timer to avoid reference cycles.
        if (this._scrollTimer) {
          this._scrollTimer.cancel();
          this._scrollTimer = null;
        }
      ]]></destructor>

      <field name="_scrollIndex">0</field>
      <field name="_scrollDelay">150</field>

      <method name="notify">
        <parameter name="aTimer"/>
        <body>
        <![CDATA[
          if (!document)
            aTimer.cancel();

          if (this.smoothScroll)
            this.scrollByPixels(25 * this._scrollIndex);
          else
            this.scrollByIndex(this._scrollIndex);
        ]]>
        </body>
      </method>

      <method name="_startScroll">
        <parameter name="index"/>
        <body><![CDATA[
          if (this._isRTLScrollbox)
            index *= -1;
          this._scrollIndex = index;
          var scrollDelay = this.smoothScroll ? 60 : this._scrollDelay;
          if (!this._scrollTimer)
            this._scrollTimer =
              Components.classes["@mozilla.org/timer;1"]
                        .createInstance(Components.interfaces.nsITimer);
          else
            this._scrollTimer.cancel();

          this._scrollTimer.initWithCallback(this, scrollDelay,
                                             this._scrollTimer.TYPE_REPEATING_SLACK);
          this.notify(this._scrollTimer);
          this._mousedown = true;
        ]]>
        </body>
      </method>

      <method name="_stopScroll">
        <body><![CDATA[
          if (this._scrollTimer)
            this._scrollTimer.cancel();
          this._mousedown = false;
          if (!this._scrollIndex || !this.smoothScroll)
            return;

          this.scrollByIndex(this._scrollIndex);
          this._scrollIndex = 0;
        ]]></body>
      </method>

      <method name="_pauseScroll">
        <body><![CDATA[
          if (this._mousedown) {
            this._stopScroll();
            this._mousedown = true;
            document.addEventListener("mouseup", this, false);
            document.addEventListener("blur", this, true);
          }
        ]]></body>
      </method>

      <method name="_continueScroll">
        <parameter name="index"/>
        <body><![CDATA[
          if (this._mousedown)
            this._startScroll(index);
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.type == "mouseup" ||
              aEvent.type == "blur" && aEvent.target == document) {
            this._mousedown = false;
            document.removeEventListener("mouseup", this, false);
            document.removeEventListener("blur", this, true);
          }
        ]]></body>
      </method>

      <method name="_distanceScroll">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.detail < 2 || aEvent.detail > 3)
            return;

          var scrollBack = (aEvent.originalTarget == this._scrollButtonUp);
          var scrollLeftOrUp = this._isRTLScrollbox ? !scrollBack : scrollBack;
          var targetElement;

          if (aEvent.detail == 2) {
            // scroll by the size of the scrollbox
            let [start, end] = this._startEndProps;
            let x;
            if (scrollLeftOrUp)
              x = this.scrollClientRect[start] - this.scrollClientSize;
            else
              x = this.scrollClientRect[end] + this.scrollClientSize;
            targetElement = this._elementFromPoint(x, scrollLeftOrUp ? -1 : 1);

            // the next partly-hidden element will become fully visible,
            // so don't scroll too far
            if (targetElement)
              targetElement = scrollBack ?
                              targetElement.nextSibling :
                              targetElement.previousSibling;
          }

          if (!targetElement) {
            // scroll to the first resp. last element
            let elements = this._getScrollableElements();
            targetElement = scrollBack ?
                            elements[0] :
                            elements[elements.length - 1];
          }

          this.ensureElementIsVisible(targetElement);
        ]]></body>
      </method>

    </implementation>
  </binding>
</bindings>
