// SPDX-License-Identifier: MPL-2.0

import * as path from "@std/path";
import {
  BRANDING,
  PLATFORM,
  VERSION,
  PATHS,
  BIN_DIR,
  BIN_ROOT_DIR,
  BIN_PATH_EXE,
  BIN_VERSION,
  getBinArchive,
} from "./defines.ts";
import { Logger, runCommand, exists, safeRemove } from "./utils.ts";

const logger = new Logger("initializer");

/**
 * Entry point: ensure binary is present and preferences saved.
 */
export async function run(): Promise<void> {
  const hasVersion = exists(BIN_VERSION);
  const hasBin = exists(BIN_PATH_EXE);
  let needInit = false;

  logger.info(BIN_VERSION);

  if (hasBin && hasVersion) {
    const version = Deno.readTextFileSync(BIN_VERSION).trim();
    if (VERSION !== version) {
      logger.warn(
        `Version mismatch: ${version} !== ${VERSION}. Re-extracting.`,
      );
      safeRemove(BIN_ROOT_DIR);
      needInit = true;
    } else {
      logger.info("Binary version matches. No initialization needed.");
    }
  } else if (hasBin && !hasVersion) {
    logger.info(
      `Binary exists but version file is missing. Writing ${VERSION}.`,
    );
    Deno.mkdirSync(BIN_DIR, { recursive: true });
    Deno.writeTextFileSync(BIN_VERSION, VERSION);
    logger.success("Initialization complete.");
  } else if (!hasBin && hasVersion) {
    logger.error(
      "Version file exists but binary is missing. Abnormal termination.",
    );
    throw new Error("Unreachable: !has_bin && has_version");
  } else {
    logger.info("Binary not found. Extracting.");
    needInit = true;
  }

  if (needInit) {
    Deno.mkdirSync(BIN_ROOT_DIR, { recursive: true });
    await decompressBin();
    logger.success("Initialization complete.");
  }

  savePrefsForProfile();
}

export function savePrefsForProfile(): void {
  const profileDir = PATHS.profile_test;
  const userJsPath = path.join(profileDir, "user.js");

  const userJsContent = `/**
 *! DO NOT EDIT THIS FILE.
 *
 ** This file is AUTOGENERATED
 ** Please modify the 'tools/lib/initializer.rb' in the repo.
 */
user_pref("devtools.debugger.prompt-connection", false);
user_pref("security.disallow_privileged_https_script_loads", false);
user_pref("security.allow_parent_unrestricted_js_loads", true);
user_pref("remote.active-protocols", 1);
user_pref("browser.newtabpage.enabled", true);
`;

  Deno.mkdirSync(profileDir, { recursive: true });
  Deno.writeTextFileSync(userJsPath, userJsContent);
  logger.info(`Wrote developer preferences to ${userJsPath}`);
}

async function extractNestedZip(outerZipPath: string, extractToDir: string): Promise<void> {
  const tempDir = "_dist/temp_extract_"+Date.now();
  await Deno.mkdir(tempDir);
  
  try {
    logger.info("Extracting outer zip...");
    
    // Extract outer zip to temp directory
    switch (PLATFORM) {
      case "windows":
        try {
          runCommand("tar", ["-xf", outerZipPath, "-C", tempDir]);
        } catch {
          runCommand("powershell", [
            "-NoProfile",
            "-NonInteractive", 
            "-Command",
            `Expand-Archive -LiteralPath '${outerZipPath}' -DestinationPath '${tempDir}' -Force`
          ]);
        }
        break;
      case "darwin":
      case "linux":
        runCommand("unzip", ["-q", outerZipPath, "-d", tempDir]);
        break;
    }

    // Find the inner zip file
    let innerZipPath: string | null = null;
    for (const entry of Deno.readDirSync(tempDir)) {
      if (entry.name.endsWith('.zip')) {
        innerZipPath = path.join(tempDir, entry.name);
        break;
      }
    }

    if (!innerZipPath) {
      throw new Error("No inner zip file found in the extracted archive");
    }

    logger.info("Extracting inner zip...");
    
    // Extract inner zip to final destination
    switch (PLATFORM) {
      case "windows":
        try {
          runCommand("tar", ["-xf", innerZipPath, "-C", extractToDir]);
        } catch {
          runCommand("powershell", [
            "-NoProfile",
            "-NonInteractive",
            "-Command", 
            `Expand-Archive -LiteralPath '${innerZipPath}' -DestinationPath '${extractToDir}' -Force`
          ]);
        }
        break;
      case "darwin":
      case "linux":
        runCommand("unzip", ["-q", innerZipPath, "-d", extractToDir]);
        break;
    }

    // Set proper permissions on Unix-like systems
    if (PLATFORM !== "windows") {
      try {
        runCommand("chmod", ["-R", "755", extractToDir]);
      } catch {
        // Ignore chmod errors
      }
    }

  } finally {
    // Clean up temp directory
    try {
      Deno.removeSync(tempDir, { recursive: true });
    } catch {
      // Ignore cleanup errors
    }
  }
}

export async function decompressBin(): Promise<void> {
  const binArchive = getBinArchive();
  const archivePath = path.resolve(binArchive.filename);
  logger.info(`Binary extraction started: ${binArchive.filename}`);

  if (!exists(binArchive.filename)) {
    logger.warn(
      `${binArchive.filename} not found. Downloading from GitHub release.`,
    );
    await downloadBin(binArchive.filename);
  }

  try {
    // Handle nested zip extraction
    if (binArchive.filename.endsWith('.zip')) {
      await extractNestedZip(archivePath, BIN_ROOT_DIR);
    } else {
      // Handle other archive formats (DMG, tar.xz, etc.)
      switch (PLATFORM) {
        case "windows":
          throw new Error("Non-zip archives not supported on Windows");
          
        case "darwin": {
            logger.info("macOS extraction (hdiutil)");
            const mountPoint = await Deno.makeTempDir({ prefix: "nora_dmg_mount_" });
            try {
            runCommand("hdiutil", ["attach", "-nobrowse", "-quiet", "-mountpoint", mountPoint, archivePath]);
            const subdir = path.join(BIN_ROOT_DIR, BRANDING.base_name);
            Deno.mkdirSync(subdir, { recursive: true });
            runCommand("cp", ["-a", `${mountPoint}/.`, subdir]);

            // Rename .app if it contains "Debug"
            for (const entry of Deno.readDirSync(subdir)) {
              if (entry.isDirectory && entry.name.endsWith('.app') && entry.name.includes('Debug')) {
                const oldPath = path.join(subdir, entry.name);
                const newName = entry.name.replace(/Debug/g, '');
                const newPath = path.join(subdir, newName);
                logger.info(`Renaming ${entry.name} to ${newName}`);
                Deno.renameSync(oldPath, newPath);
              }
            }

            try {
              runCommand("xattr", ["-rc", BIN_ROOT_DIR]);
            } catch {
              // xattr might not be present; ignore
            }
            runCommand("chmod", ["-R", "755", BIN_ROOT_DIR]);
            } finally {
            try {
              runCommand("hdiutil", ["detach", "-quiet", mountPoint]);
            } catch {
              // ignore detach failures
            }
            }
            break;
        }
        
        case "linux": {
          runCommand("tar", ["-xJf", archivePath, "-C", BIN_ROOT_DIR]);
          runCommand("chmod", ["-R", "755", BIN_ROOT_DIR]);
          break;
        }
        
        default:
          throw new Error(`Unsupported platform: ${PLATFORM}`);
      }
    }
    
    Deno.writeTextFileSync(BIN_VERSION, VERSION);
    logger.success("Extraction complete!");
    
  } catch (e: any) {
    logger.error(`Error during extraction: ${e?.message ?? e}`);
    Deno.exit(1);
  }
}

export async function downloadBin(filename: string): Promise<void> {
  const url = `https://github.com/f3liz-dev/noraneko-runtime/releases/latest/download/${filename}`;
  logger.info(`Downloading binary from ${url}`);

  const resp = await fetch(url);
  if (!resp.ok) {
    throw new Error(`HTTP error ${resp.status}`);
  }
  const data = new Uint8Array(await resp.arrayBuffer());
  await Deno.writeFile(filename, data);

  logger.success(`Downloaded binary to ${filename}`);
}