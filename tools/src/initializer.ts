// SPDX-License-Identifier: MPL-2.0

import * as path from "@std/path";
import {
  BRANDING,
  PLATFORM,
  VERSION,
  PATHS,
  BIN_DIR,
  BIN_ROOT_DIR,
  BIN_PATH_EXE,
  BIN_VERSION,
  getBinArchive,
} from "./defines.ts";
import { Logger, runCommand, exists, safeRemove } from "./utils.ts";

const logger = new Logger("initializer");

/**
 * Entry point: ensure binary is present and preferences saved.
 */
export async function run(): Promise<void> {
  const hasVersion = exists(BIN_VERSION);
  const hasBin = exists(BIN_PATH_EXE);
  let needInit = false;

  logger.info(BIN_VERSION);

  if (hasBin && hasVersion) {
    const version = Deno.readTextFileSync(BIN_VERSION).trim();
    if (VERSION !== version) {
      logger.warn(
        `Version mismatch: ${version} !== ${VERSION}. Re-extracting.`,
      );
      safeRemove(BIN_ROOT_DIR);
      needInit = true;
    } else {
      logger.info("Binary version matches. No initialization needed.");
    }
  } else if (hasBin && !hasVersion) {
    logger.info(
      `Binary exists but version file is missing. Writing ${VERSION}.`,
    );
    Deno.mkdirSync(BIN_DIR, { recursive: true });
    Deno.writeTextFileSync(BIN_VERSION, VERSION);
    logger.success("Initialization complete.");
  } else if (!hasBin && hasVersion) {
    logger.error(
      "Version file exists but binary is missing. Abnormal termination.",
    );
    throw new Error("Unreachable: !has_bin && has_version");
  } else {
    logger.info("Binary not found. Extracting.");
    needInit = true;
  }

  if (needInit) {
    Deno.mkdirSync(BIN_DIR, { recursive: true });
    await decompressBin();
    logger.success("Initialization complete.");
  }

  savePrefsForProfile();
}

export function savePrefsForProfile(): void {
  const profileDir = PATHS.profile_test;
  const userJsPath = path.join(profileDir, "user.js");

  const userJsContent = `/**
 *! DO NOT EDIT THIS FILE.
 *
 ** This file is AUTOGENERATED
 ** Please modify the 'tools/lib/initializer.rb' in the repo.
 */
user_pref("devtools.debugger.prompt-connection", false);
user_pref("security.disallow_privileged_https_script_loads", false);
user_pref("security.allow_parent_unrestricted_js_loads", true);
user_pref("remote.active-protocols", 1);
user_pref("browser.newtabpage.enabled", true);
`;

  Deno.mkdirSync(profileDir, { recursive: true });
  Deno.writeTextFileSync(userJsPath, userJsContent);
  logger.info(`Wrote developer preferences to ${userJsPath}`);
}

export async function decompressBin(): Promise<void> {
  const binArchive = getBinArchive();
  logger.info(`Binary extraction started: ${binArchive.filename}`);

  if (!exists(binArchive.filename)) {
    logger.warn(
      `${binArchive.filename} not found. Downloading from GitHub release.`,
    );
    await downloadBin(binArchive.filename);
  }

  try {
    switch (PLATFORM) {
      case "windows":
        logger.info("[stub] Windows extraction (Expand-Archive)");
        break;
      case "darwin":
        logger.info("[stub] macOS extraction (hdiutil, xattr, etc.)");
        break;
      case "linux":
        // Use runCommand which throws on failure
        runCommand("tar", ["-xf", binArchive.filename, "-C", BIN_ROOT_DIR]);
        runCommand("chmod", ["-R", "755", PATHS.bin_root]);
        break;
      default:
        throw new Error(`Unsupported platform: ${PLATFORM}`);
    }

    Deno.writeTextFileSync(BIN_VERSION, VERSION);
    logger.success("Extraction complete!");
  } catch (e: any) {
    logger.error(`Error during extraction: ${e?.message ?? e}`);
    // match original behavior: exit with non-zero code
    Deno.exit(1);
  }
}

export async function downloadBin(filename: string): Promise<void> {
  const url = `https://github.com/f3liz-dev/noraneko-runtime/releases/latest/download/${filename}`;
  logger.info(`Downloading binary from ${url}`);

  const resp = await fetch(url);
  if (!resp.ok) {
    throw new Error(`HTTP error ${resp.status}`);
  }
  const data = new Uint8Array(await resp.arrayBuffer());
  await Deno.writeFile(filename, data);

  logger.success(`Downloaded binary to ${filename}`);
}
