[aborting.any.html]
  [an abort() that happens during a write() should trigger the underlying abort() even with a close() queued]
    expected: FAIL

  [underlying abort() should not be called until underlying write() completes]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to controller.error() before abort() was called]
    expected: FAIL

  [Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied]
    expected: FAIL

  [.closed should not resolve before fulfilled write()]
    expected: FAIL

  [abort() should succeed despite rejection from write]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by ws.abort() rejects]
    expected: FAIL

  [WritableStream should NOT call underlying sink's close if no abort is supplied (historical)]
    expected: FAIL

  [writer abort() during sink start() should replace the writer.ready promise synchronously]
    expected: FAIL

  [WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects]
    expected: FAIL

  [a rejecting sink.write() should not prevent sink.abort() from being called]
    expected: FAIL

  [if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error]
    expected: FAIL

  [underlying abort() should not be called if underlying close() has started]
    expected: FAIL

  [Aborting a WritableStream passes through the given reason]
    expected: FAIL

  [Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one]
    expected: FAIL

  [writer.ready should reject on controller error without waiting for underlying write]
    expected: FAIL

  [if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason]
    expected: FAIL

  [if start attempts to error the controller after abort() has been called, then it should lose]
    expected: FAIL

  [abort with an undefined argument should set the stored error to undefined]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [.closed should not resolve before rejected write(); write() error should not overwrite abort() error]
    expected: FAIL

  [stream abort() promise should still resolve if sink start() rejects]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [Aborting a WritableStream prevents further writes after any that are in progress]
    expected: FAIL

  [writes should be satisfied in order when aborting]
    expected: FAIL

  [abort with a string argument should set the stored error to that argument]
    expected: FAIL

  [abort() should be rejected with the rejection returned from close()]
    expected: FAIL

  [Aborting a WritableStream immediately prevents future writes]
    expected: FAIL

  [Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject]
    expected: FAIL

  [Aborting a WritableStream puts it in an errored state with the error passed to abort()]
    expected: FAIL

  [Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to bad strategy before abort() was called]
    expected: FAIL

  [writes should be satisfied in order after rejected write when aborting]
    expected: FAIL

  [releaseLock() while aborting should reject the original closed promise]
    expected: FAIL

  [when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined]
    expected: FAIL

  [releaseLock() during delayed async abort() should reject the writer.closed promise]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [close() should reject with abort reason why abort() is first error]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects]
    expected: FAIL

  [returning a thenable from abort() should work]
    expected: FAIL

  [when start errors after stream abort(), underlying sink abort() should be called anyway]
    expected: FAIL

  [sink abort() should not be called until sink start() is done]
    expected: FAIL

  [abort() on a released writer rejects]
    expected: FAIL

  [Aborting a WritableStream after it is closed is a no-op]
    expected: FAIL

  [writer close() promise should resolve before abort() promise]
    expected: FAIL

  [promises returned from other writer methods should be rejected when writer abort() happens during sink start()]
    expected: FAIL

  [abort with no arguments should set the stored error to undefined]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [calling abort() on an errored stream should fulfill with undefined]
    expected: FAIL

  [Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by writer.abort() rejects]
    expected: FAIL

  [when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined]
    expected: FAIL

  [writer.abort() while there is an in-flight write, and then finish the write with rejection]
    expected: FAIL

  [Closing but then immediately aborting a WritableStream causes the stream to error]
    expected: FAIL


[aborting.any.worker.html]
  [an abort() that happens during a write() should trigger the underlying abort() even with a close() queued]
    expected: FAIL

  [underlying abort() should not be called until underlying write() completes]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to controller.error() before abort() was called]
    expected: FAIL

  [Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied]
    expected: FAIL

  [.closed should not resolve before fulfilled write()]
    expected: FAIL

  [abort() should succeed despite rejection from write]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by ws.abort() rejects]
    expected: FAIL

  [WritableStream should NOT call underlying sink's close if no abort is supplied (historical)]
    expected: FAIL

  [writer abort() during sink start() should replace the writer.ready promise synchronously]
    expected: FAIL

  [WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects]
    expected: FAIL

  [a rejecting sink.write() should not prevent sink.abort() from being called]
    expected: FAIL

  [if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error]
    expected: FAIL

  [underlying abort() should not be called if underlying close() has started]
    expected: FAIL

  [Aborting a WritableStream passes through the given reason]
    expected: FAIL

  [Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one]
    expected: FAIL

  [writer.ready should reject on controller error without waiting for underlying write]
    expected: FAIL

  [if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason]
    expected: FAIL

  [if start attempts to error the controller after abort() has been called, then it should lose]
    expected: FAIL

  [abort with an undefined argument should set the stored error to undefined]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [.closed should not resolve before rejected write(); write() error should not overwrite abort() error]
    expected: FAIL

  [stream abort() promise should still resolve if sink start() rejects]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [Aborting a WritableStream prevents further writes after any that are in progress]
    expected: FAIL

  [writes should be satisfied in order when aborting]
    expected: FAIL

  [abort with a string argument should set the stored error to that argument]
    expected: FAIL

  [abort() should be rejected with the rejection returned from close()]
    expected: FAIL

  [Aborting a WritableStream immediately prevents future writes]
    expected: FAIL

  [Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject]
    expected: FAIL

  [Aborting a WritableStream puts it in an errored state with the error passed to abort()]
    expected: FAIL

  [Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to bad strategy before abort() was called]
    expected: FAIL

  [writes should be satisfied in order after rejected write when aborting]
    expected: FAIL

  [releaseLock() while aborting should reject the original closed promise]
    expected: FAIL

  [when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined]
    expected: FAIL

  [releaseLock() during delayed async abort() should reject the writer.closed promise]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [close() should reject with abort reason why abort() is first error]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects]
    expected: FAIL

  [returning a thenable from abort() should work]
    expected: FAIL

  [when start errors after stream abort(), underlying sink abort() should be called anyway]
    expected: FAIL

  [sink abort() should not be called until sink start() is done]
    expected: FAIL

  [abort() on a released writer rejects]
    expected: FAIL

  [Aborting a WritableStream after it is closed is a no-op]
    expected: FAIL

  [writer close() promise should resolve before abort() promise]
    expected: FAIL

  [promises returned from other writer methods should be rejected when writer abort() happens during sink start()]
    expected: FAIL

  [abort with no arguments should set the stored error to undefined]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [calling abort() on an errored stream should fulfill with undefined]
    expected: FAIL

  [Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by writer.abort() rejects]
    expected: FAIL

  [when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined]
    expected: FAIL

  [writer.abort() while there is an in-flight write, and then finish the write with rejection]
    expected: FAIL

  [Closing but then immediately aborting a WritableStream causes the stream to error]
    expected: FAIL


[aborting.any.serviceworker.html]
  [an abort() that happens during a write() should trigger the underlying abort() even with a close() queued]
    expected: FAIL

  [underlying abort() should not be called until underlying write() completes]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to controller.error() before abort() was called]
    expected: FAIL

  [Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied]
    expected: FAIL

  [.closed should not resolve before fulfilled write()]
    expected: FAIL

  [abort() should succeed despite rejection from write]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by ws.abort() rejects]
    expected: FAIL

  [WritableStream should NOT call underlying sink's close if no abort is supplied (historical)]
    expected: FAIL

  [writer abort() during sink start() should replace the writer.ready promise synchronously]
    expected: FAIL

  [WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects]
    expected: FAIL

  [a rejecting sink.write() should not prevent sink.abort() from being called]
    expected: FAIL

  [if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error]
    expected: FAIL

  [underlying abort() should not be called if underlying close() has started]
    expected: FAIL

  [Aborting a WritableStream passes through the given reason]
    expected: FAIL

  [Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one]
    expected: FAIL

  [writer.ready should reject on controller error without waiting for underlying write]
    expected: FAIL

  [if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason]
    expected: FAIL

  [if start attempts to error the controller after abort() has been called, then it should lose]
    expected: FAIL

  [abort with an undefined argument should set the stored error to undefined]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [.closed should not resolve before rejected write(); write() error should not overwrite abort() error]
    expected: FAIL

  [stream abort() promise should still resolve if sink start() rejects]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [Aborting a WritableStream prevents further writes after any that are in progress]
    expected: FAIL

  [writes should be satisfied in order when aborting]
    expected: FAIL

  [abort with a string argument should set the stored error to that argument]
    expected: FAIL

  [abort() should be rejected with the rejection returned from close()]
    expected: FAIL

  [Aborting a WritableStream immediately prevents future writes]
    expected: FAIL

  [Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject]
    expected: FAIL

  [Aborting a WritableStream puts it in an errored state with the error passed to abort()]
    expected: FAIL

  [Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to bad strategy before abort() was called]
    expected: FAIL

  [writes should be satisfied in order after rejected write when aborting]
    expected: FAIL

  [releaseLock() while aborting should reject the original closed promise]
    expected: FAIL

  [when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined]
    expected: FAIL

  [releaseLock() during delayed async abort() should reject the writer.closed promise]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [close() should reject with abort reason why abort() is first error]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects]
    expected: FAIL

  [returning a thenable from abort() should work]
    expected: FAIL

  [when start errors after stream abort(), underlying sink abort() should be called anyway]
    expected: FAIL

  [sink abort() should not be called until sink start() is done]
    expected: FAIL

  [abort() on a released writer rejects]
    expected: FAIL

  [Aborting a WritableStream after it is closed is a no-op]
    expected: FAIL

  [writer close() promise should resolve before abort() promise]
    expected: FAIL

  [promises returned from other writer methods should be rejected when writer abort() happens during sink start()]
    expected: FAIL

  [abort with no arguments should set the stored error to undefined]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [calling abort() on an errored stream should fulfill with undefined]
    expected: FAIL

  [Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by writer.abort() rejects]
    expected: FAIL

  [when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined]
    expected: FAIL

  [writer.abort() while there is an in-flight write, and then finish the write with rejection]
    expected: FAIL

  [Closing but then immediately aborting a WritableStream causes the stream to error]
    expected: FAIL


[aborting.any.sharedworker.html]
  [an abort() that happens during a write() should trigger the underlying abort() even with a close() queued]
    expected: FAIL

  [underlying abort() should not be called until underlying write() completes]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to controller.error() before abort() was called]
    expected: FAIL

  [Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied]
    expected: FAIL

  [.closed should not resolve before fulfilled write()]
    expected: FAIL

  [abort() should succeed despite rejection from write]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by ws.abort() rejects]
    expected: FAIL

  [WritableStream should NOT call underlying sink's close if no abort is supplied (historical)]
    expected: FAIL

  [writer abort() during sink start() should replace the writer.ready promise synchronously]
    expected: FAIL

  [WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects]
    expected: FAIL

  [a rejecting sink.write() should not prevent sink.abort() from being called]
    expected: FAIL

  [if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error]
    expected: FAIL

  [underlying abort() should not be called if underlying close() has started]
    expected: FAIL

  [Aborting a WritableStream passes through the given reason]
    expected: FAIL

  [Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one]
    expected: FAIL

  [writer.ready should reject on controller error without waiting for underlying write]
    expected: FAIL

  [if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason]
    expected: FAIL

  [if start attempts to error the controller after abort() has been called, then it should lose]
    expected: FAIL

  [abort with an undefined argument should set the stored error to undefined]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [.closed should not resolve before rejected write(); write() error should not overwrite abort() error]
    expected: FAIL

  [stream abort() promise should still resolve if sink start() rejects]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight close, and then finish the close]
    expected: FAIL

  [Aborting a WritableStream prevents further writes after any that are in progress]
    expected: FAIL

  [writes should be satisfied in order when aborting]
    expected: FAIL

  [abort with a string argument should set the stored error to that argument]
    expected: FAIL

  [abort() should be rejected with the rejection returned from close()]
    expected: FAIL

  [Aborting a WritableStream immediately prevents future writes]
    expected: FAIL

  [Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject]
    expected: FAIL

  [Aborting a WritableStream puts it in an errored state with the error passed to abort()]
    expected: FAIL

  [Fulfillment value of ws.abort() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [sink abort() should not be called if stream was erroring due to bad strategy before abort() was called]
    expected: FAIL

  [writes should be satisfied in order after rejected write when aborting]
    expected: FAIL

  [releaseLock() while aborting should reject the original closed promise]
    expected: FAIL

  [when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined]
    expected: FAIL

  [releaseLock() during delayed async abort() should reject the writer.closed promise]
    expected: FAIL

  [writer.abort(), controller.error() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [close() should reject with abort reason why abort() is first error]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects]
    expected: FAIL

  [returning a thenable from abort() should work]
    expected: FAIL

  [when start errors after stream abort(), underlying sink abort() should be called anyway]
    expected: FAIL

  [sink abort() should not be called until sink start() is done]
    expected: FAIL

  [abort() on a released writer rejects]
    expected: FAIL

  [Aborting a WritableStream after it is closed is a no-op]
    expected: FAIL

  [writer close() promise should resolve before abort() promise]
    expected: FAIL

  [promises returned from other writer methods should be rejected when writer abort() happens during sink start()]
    expected: FAIL

  [abort with no arguments should set the stored error to undefined]
    expected: FAIL

  [controller.error(), writer.abort() while there is an in-flight write, and then finish the write]
    expected: FAIL

  [calling abort() on an errored stream should fulfill with undefined]
    expected: FAIL

  [Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt]
    expected: FAIL

  [WritableStream if sink's abort throws, the promise returned by writer.abort() rejects]
    expected: FAIL

  [when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined]
    expected: FAIL

  [writer.abort() while there is an in-flight write, and then finish the write with rejection]
    expected: FAIL

  [Closing but then immediately aborting a WritableStream causes the stream to error]
    expected: FAIL

