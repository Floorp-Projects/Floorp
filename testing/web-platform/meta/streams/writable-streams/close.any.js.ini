[close.any.serviceworker.html]
  [releaseLock() should not change the result of async close()]
    expected: FAIL

  [promises must fulfill/reject in the expected order on closure]
    expected: FAIL

  [when sink calls error asynchronously while sink close is in-flight, the stream should not become errored]
    expected: FAIL

  [releaseLock on a stream with a pending write in which the stream has been errored]
    expected: FAIL

  [the promise returned by async abort during close should resolve]
    expected: FAIL

  [releaseLock() should not change the result of sync close()]
    expected: FAIL

  [when close is called on a WritableStream in writable state, ready should return a fulfilled promise]
    expected: FAIL

  [releaseLock on a stream with a pending close in which controller.error() was called]
    expected: FAIL

  [close() should set state to CLOSED even if writer has detached]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted closure]
    expected: FAIL

  [returning a thenable from close() should work]
    expected: FAIL

  [when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready promise should be fulfilled]
    expected: FAIL

  [when sink calls error synchronously while closing, the stream should not become errored]
    expected: FAIL

  [fulfillment value of ws.close() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted and errored closure]
    expected: FAIL

  [close() should not reject until no sink methods are in flight]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time]
    expected: FAIL


[close.any.sharedworker.html]
  [releaseLock() should not change the result of async close()]
    expected: FAIL

  [promises must fulfill/reject in the expected order on closure]
    expected: FAIL

  [when sink calls error asynchronously while sink close is in-flight, the stream should not become errored]
    expected: FAIL

  [releaseLock on a stream with a pending write in which the stream has been errored]
    expected: FAIL

  [the promise returned by async abort during close should resolve]
    expected: FAIL

  [releaseLock() should not change the result of sync close()]
    expected: FAIL

  [when close is called on a WritableStream in writable state, ready should return a fulfilled promise]
    expected: FAIL

  [releaseLock on a stream with a pending close in which controller.error() was called]
    expected: FAIL

  [close() should set state to CLOSED even if writer has detached]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted closure]
    expected: FAIL

  [returning a thenable from close() should work]
    expected: FAIL

  [when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready promise should be fulfilled]
    expected: FAIL

  [when sink calls error synchronously while closing, the stream should not become errored]
    expected: FAIL

  [fulfillment value of ws.close() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted and errored closure]
    expected: FAIL

  [close() should not reject until no sink methods are in flight]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time]
    expected: FAIL


[close.any.html]
  [releaseLock() should not change the result of async close()]
    expected: FAIL

  [promises must fulfill/reject in the expected order on closure]
    expected: FAIL

  [when sink calls error asynchronously while sink close is in-flight, the stream should not become errored]
    expected: FAIL

  [releaseLock on a stream with a pending write in which the stream has been errored]
    expected: FAIL

  [the promise returned by async abort during close should resolve]
    expected: FAIL

  [releaseLock() should not change the result of sync close()]
    expected: FAIL

  [when close is called on a WritableStream in writable state, ready should return a fulfilled promise]
    expected: FAIL

  [releaseLock on a stream with a pending close in which controller.error() was called]
    expected: FAIL

  [close() should set state to CLOSED even if writer has detached]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted closure]
    expected: FAIL

  [returning a thenable from close() should work]
    expected: FAIL

  [when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready promise should be fulfilled]
    expected: FAIL

  [when sink calls error synchronously while closing, the stream should not become errored]
    expected: FAIL

  [fulfillment value of ws.close() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted and errored closure]
    expected: FAIL

  [close() should not reject until no sink methods are in flight]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time]
    expected: FAIL


[close.any.worker.html]
  [releaseLock() should not change the result of async close()]
    expected: FAIL

  [promises must fulfill/reject in the expected order on closure]
    expected: FAIL

  [when sink calls error asynchronously while sink close is in-flight, the stream should not become errored]
    expected: FAIL

  [releaseLock on a stream with a pending write in which the stream has been errored]
    expected: FAIL

  [the promise returned by async abort during close should resolve]
    expected: FAIL

  [releaseLock() should not change the result of sync close()]
    expected: FAIL

  [when close is called on a WritableStream in writable state, ready should return a fulfilled promise]
    expected: FAIL

  [releaseLock on a stream with a pending close in which controller.error() was called]
    expected: FAIL

  [close() should set state to CLOSED even if writer has detached]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted closure]
    expected: FAIL

  [returning a thenable from close() should work]
    expected: FAIL

  [when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready promise should be fulfilled]
    expected: FAIL

  [when sink calls error synchronously while closing, the stream should not become errored]
    expected: FAIL

  [fulfillment value of ws.close() call must be undefined even if the underlying sink returns a non-undefined value]
    expected: FAIL

  [promises must fulfill/reject in the expected order on aborted and errored closure]
    expected: FAIL

  [close() should not reject until no sink methods are in flight]
    expected: FAIL

  [when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time]
    expected: FAIL

