[tee.any.worker.html]
  expected:
    if not domstreams: OK
    ERROR

  [ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks should be cloned for each branch]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: errors in the source should propagate to both branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should not impact branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch2 should not impact branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: closing the original should close the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should immediately error the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull any chunks if no branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull when original is already errored]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch2, then read from branch1]
    expected:
      if not domstreams: FAIL
      TIMEOUT

  [ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: read from branch2 with default reader, then close while branch1 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: close when both branches have pending BYOB reads]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: enqueue() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: respond() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN


[tee.any.serviceworker.html]
  expected:
    if not domstreams: OK
    TIMEOUT

  [ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks should be cloned for each branch]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: errors in the source should propagate to both branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should not impact branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch2 should not impact branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: closing the original should close the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should immediately error the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull any chunks if no branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull when original is already errored]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch2, then read from branch1]
    expected:
      if not domstreams: FAIL
      TIMEOUT

  [ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: read from branch2 with default reader, then close while branch1 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: close when both branches have pending BYOB reads]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: enqueue() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: respond() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN


[tee.any.sharedworker.html]
  expected:
    if not domstreams: OK
    ERROR

  [ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks should be cloned for each branch]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: errors in the source should propagate to both branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should not impact branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch2 should not impact branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: closing the original should close the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should immediately error the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull any chunks if no branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull when original is already errored]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch2, then read from branch1]
    expected:
      if not domstreams: FAIL
      TIMEOUT

  [ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: read from branch2 with default reader, then close while branch1 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: close when both branches have pending BYOB reads]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: enqueue() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: respond() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN


[tee.any.html]
  expected:
    if not domstreams: OK
    ERROR

  [ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks should be cloned for each branch]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: errors in the source should propagate to both branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should not impact branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch2 should not impact branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: closing the original should close the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should immediately error the branches]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull any chunks if no branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: should not pull when original is already errored]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay]
    expected: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader]
    expected:
      if not domstreams: FAIL

  [ReadableStream teeing with byte source: read from branch2, then read from branch1]
    expected:
      if not domstreams: FAIL
      TIMEOUT

  [ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: read from branch2 with default reader, then close while branch1 has pending BYOB read]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: close when both branches have pending BYOB reads]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: enqueue() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN

  [ReadableStream teeing with byte source: respond() and close() while both branches are pulling]
    expected:
      if not domstreams: FAIL
      NOTRUN
