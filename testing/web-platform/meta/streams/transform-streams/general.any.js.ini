[general.any.sharedworker.html]
  [TransformStream writable starts in the writable state]
    expected: FAIL

  [Identity TransformStream: can read from readable what is put into writable]
    expected: FAIL

  [Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler sync TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [Uppercaser async TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler async TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable (when there are no queued writes)]
    expected: FAIL

  [TransformStream: by default, closing the writable waits for transforms to finish before closing both]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after sync enqueues and async done]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after async enqueues and async done]
    expected: FAIL

  [Transform stream should call transformer methods as methods]
    expected: FAIL

  [methods should not not have .apply() or .call() called]
    expected: FAIL

  [TransformStream start, transform, and flush should be strictly ordered]
    expected: FAIL

  [it should be possible to call transform() synchronously]
    expected: FAIL

  [closing the writable should close the readable when there are no queued chunks, even with backpressure]
    expected: FAIL

  [enqueue() should throw after readable.cancel()]
    expected: FAIL

  [terminate() should do nothing after readable.cancel()]
    expected: FAIL

  [Subclassing TransformStream should work]
    expected: FAIL

  [enqueue() should throw after controller.terminate()]
    expected: FAIL

  [controller.terminate() should do nothing the second time it is called]
    expected: FAIL


[general.any.html]
  [TransformStream writable starts in the writable state]
    expected: FAIL

  [Identity TransformStream: can read from readable what is put into writable]
    expected: FAIL

  [Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler sync TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [Uppercaser async TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler async TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable (when there are no queued writes)]
    expected: FAIL

  [TransformStream: by default, closing the writable waits for transforms to finish before closing both]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after sync enqueues and async done]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after async enqueues and async done]
    expected: FAIL

  [Transform stream should call transformer methods as methods]
    expected: FAIL

  [methods should not not have .apply() or .call() called]
    expected: FAIL

  [TransformStream start, transform, and flush should be strictly ordered]
    expected: FAIL

  [it should be possible to call transform() synchronously]
    expected: FAIL

  [closing the writable should close the readable when there are no queued chunks, even with backpressure]
    expected: FAIL

  [enqueue() should throw after readable.cancel()]
    expected: FAIL

  [terminate() should do nothing after readable.cancel()]
    expected: FAIL

  [Subclassing TransformStream should work]
    expected: FAIL

  [enqueue() should throw after controller.terminate()]
    expected: FAIL

  [controller.terminate() should do nothing the second time it is called]
    expected: FAIL


[general.any.worker.html]
  [TransformStream writable starts in the writable state]
    expected: FAIL

  [Identity TransformStream: can read from readable what is put into writable]
    expected: FAIL

  [Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler sync TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [Uppercaser async TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler async TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable (when there are no queued writes)]
    expected: FAIL

  [TransformStream: by default, closing the writable waits for transforms to finish before closing both]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after sync enqueues and async done]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after async enqueues and async done]
    expected: FAIL

  [Transform stream should call transformer methods as methods]
    expected: FAIL

  [methods should not not have .apply() or .call() called]
    expected: FAIL

  [TransformStream start, transform, and flush should be strictly ordered]
    expected: FAIL

  [it should be possible to call transform() synchronously]
    expected: FAIL

  [closing the writable should close the readable when there are no queued chunks, even with backpressure]
    expected: FAIL

  [enqueue() should throw after readable.cancel()]
    expected: FAIL

  [terminate() should do nothing after readable.cancel()]
    expected: FAIL

  [Subclassing TransformStream should work]
    expected: FAIL

  [enqueue() should throw after controller.terminate()]
    expected: FAIL

  [controller.terminate() should do nothing the second time it is called]
    expected: FAIL


[general.any.serviceworker.html]
  [TransformStream writable starts in the writable state]
    expected: FAIL

  [Identity TransformStream: can read from readable what is put into writable]
    expected: FAIL

  [Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler sync TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [Uppercaser async TransformStream: can read from readable transformed version of what is put into writable]
    expected: FAIL

  [Uppercaser-doubler async TransformStream: can read both chunks put into the readable]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable (when there are no queued writes)]
    expected: FAIL

  [TransformStream: by default, closing the writable waits for transforms to finish before closing both]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after sync enqueues and async done]
    expected: FAIL

  [TransformStream: by default, closing the writable closes the readable after async enqueues and async done]
    expected: FAIL

  [Transform stream should call transformer methods as methods]
    expected: FAIL

  [methods should not not have .apply() or .call() called]
    expected: FAIL

  [TransformStream start, transform, and flush should be strictly ordered]
    expected: FAIL

  [it should be possible to call transform() synchronously]
    expected: FAIL

  [closing the writable should close the readable when there are no queued chunks, even with backpressure]
    expected: FAIL

  [enqueue() should throw after readable.cancel()]
    expected: FAIL

  [terminate() should do nothing after readable.cancel()]
    expected: FAIL

  [Subclassing TransformStream should work]
    expected: FAIL

  [enqueue() should throw after controller.terminate()]
    expected: FAIL

  [controller.terminate() should do nothing the second time it is called]
    expected: FAIL
