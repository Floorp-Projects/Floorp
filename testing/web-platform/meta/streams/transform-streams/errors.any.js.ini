[errors.any.sharedworker.html]
  [TransformStream errors thrown in transform put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream errors thrown in flush put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream transformer.start() rejected promise should error the stream]
    expected: FAIL

  [when controller.error is followed by a rejection, the error reason should come from controller.error]
    expected: FAIL

  [TransformStream constructor should throw when start does]
    expected: FAIL

  [when strategy.size throws inside start(), the constructor should throw the same error]
    expected: FAIL

  [when strategy.size calls controller.error() then throws, the constructor should throw the first error]
    expected: FAIL

  [cancelling the readable side should error the writable]
    expected: FAIL

  [it should be possible to error the readable between close requested and complete]
    expected: FAIL

  [an exception from transform() should error the stream if terminate has been requested but not completed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during start, but cancel should still succeed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed]
    expected: FAIL

  [controller.error() should do nothing the second time it is called]
    expected: FAIL

  [controller.error() should do nothing after readable.cancel()]
    expected: FAIL

  [controller.error() should do nothing after writable.abort() has completed]
    expected: FAIL

  [controller.error() should do nothing after a transformer method has thrown an exception]
    expected: FAIL

  [erroring during write with backpressure should result in the write failing]
    expected: FAIL

  [a write() that was waiting for backpressure should reject if the writable is aborted]
    expected: FAIL

  [the readable should be errored with the reason passed to the writable abort() method]
    expected: FAIL


[errors.any.serviceworker.html]
  [TransformStream errors thrown in transform put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream errors thrown in flush put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream transformer.start() rejected promise should error the stream]
    expected: FAIL

  [when controller.error is followed by a rejection, the error reason should come from controller.error]
    expected: FAIL

  [TransformStream constructor should throw when start does]
    expected: FAIL

  [when strategy.size throws inside start(), the constructor should throw the same error]
    expected: FAIL

  [when strategy.size calls controller.error() then throws, the constructor should throw the first error]
    expected: FAIL

  [cancelling the readable side should error the writable]
    expected: FAIL

  [it should be possible to error the readable between close requested and complete]
    expected: FAIL

  [an exception from transform() should error the stream if terminate has been requested but not completed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during start, but cancel should still succeed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed]
    expected: FAIL

  [controller.error() should do nothing the second time it is called]
    expected: FAIL

  [controller.error() should do nothing after readable.cancel()]
    expected: FAIL

  [controller.error() should do nothing after writable.abort() has completed]
    expected: FAIL

  [controller.error() should do nothing after a transformer method has thrown an exception]
    expected: FAIL

  [erroring during write with backpressure should result in the write failing]
    expected: FAIL

  [a write() that was waiting for backpressure should reject if the writable is aborted]
    expected: FAIL

  [the readable should be errored with the reason passed to the writable abort() method]
    expected: FAIL


[errors.any.worker.html]
  [TransformStream errors thrown in transform put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream errors thrown in flush put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream transformer.start() rejected promise should error the stream]
    expected: FAIL

  [when controller.error is followed by a rejection, the error reason should come from controller.error]
    expected: FAIL

  [TransformStream constructor should throw when start does]
    expected: FAIL

  [when strategy.size throws inside start(), the constructor should throw the same error]
    expected: FAIL

  [when strategy.size calls controller.error() then throws, the constructor should throw the first error]
    expected: FAIL

  [cancelling the readable side should error the writable]
    expected: FAIL

  [it should be possible to error the readable between close requested and complete]
    expected: FAIL

  [an exception from transform() should error the stream if terminate has been requested but not completed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during start, but cancel should still succeed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed]
    expected: FAIL

  [controller.error() should do nothing the second time it is called]
    expected: FAIL

  [controller.error() should do nothing after readable.cancel()]
    expected: FAIL

  [controller.error() should do nothing after writable.abort() has completed]
    expected: FAIL

  [controller.error() should do nothing after a transformer method has thrown an exception]
    expected: FAIL

  [erroring during write with backpressure should result in the write failing]
    expected: FAIL

  [a write() that was waiting for backpressure should reject if the writable is aborted]
    expected: FAIL

  [the readable should be errored with the reason passed to the writable abort() method]
    expected: FAIL


[errors.any.html]
  [TransformStream errors thrown in transform put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream errors thrown in flush put the writable and readable in an errored state]
    expected: FAIL

  [TransformStream transformer.start() rejected promise should error the stream]
    expected: FAIL

  [when controller.error is followed by a rejection, the error reason should come from controller.error]
    expected: FAIL

  [TransformStream constructor should throw when start does]
    expected: FAIL

  [when strategy.size throws inside start(), the constructor should throw the same error]
    expected: FAIL

  [when strategy.size calls controller.error() then throws, the constructor should throw the first error]
    expected: FAIL

  [cancelling the readable side should error the writable]
    expected: FAIL

  [it should be possible to error the readable between close requested and complete]
    expected: FAIL

  [an exception from transform() should error the stream if terminate has been requested but not completed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during start, but cancel should still succeed]
    expected: FAIL

  [abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed]
    expected: FAIL

  [controller.error() should do nothing the second time it is called]
    expected: FAIL

  [controller.error() should do nothing after readable.cancel()]
    expected: FAIL

  [controller.error() should do nothing after writable.abort() has completed]
    expected: FAIL

  [controller.error() should do nothing after a transformer method has thrown an exception]
    expected: FAIL

  [erroring during write with backpressure should result in the write failing]
    expected: FAIL

  [a write() that was waiting for backpressure should reject if the writable is aborted]
    expected: FAIL

  [the readable should be errored with the reason passed to the writable abort() method]
    expected: FAIL
