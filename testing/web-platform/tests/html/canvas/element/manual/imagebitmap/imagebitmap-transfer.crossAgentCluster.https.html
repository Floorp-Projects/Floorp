<!DOCTYPE html>
<html>
<head>
  <script src='/resources/testharness.js'></script>
  <script src='/resources/testharnessreport.js'></script>
  <script src='/common/get-host-info.sub.js'></script>
  <script id='workerCode' type='javascript/worker'>
    self.onmessage = (e) => {
      let img = e.data.img;
      if (e.data.transfer) {
        postMessage(img, [img]);
      } else {
        postMessage(img);
      }
    };
  </script>
  <script id='sharedWorkerCode' type='javascript/worker'>
    let received = new Map();
    self.onconnect = function (event) {
      const port = event.ports[0];
      port.onmessage = function (e) {
        if (e.data.hasOwnProperty('id')) {
          port.postMessage(
            received.get(e.data.id) ? 'RECEIVED' : 'NOT_RECEIVED');
          return;
        }
        if (e.data.toString() == '[object ImageBitmap]') {
          received.set(e.data.width, e.data);
        }
      };
    };
  </script>
</head>
<body>
<script>
const HELPER = '/html/canvas/element/manual/imagebitmap/imagebitmap-transfer.crossAgentCluster.helper.html';
const SAMEORIGIN_BASE = get_host_info().HTTPS_ORIGIN;
const CROSSORIGIN_BASE = get_host_info().HTTPS_NOTSAMESITE_ORIGIN;
const SAMEORIGIN_HELPER = SAMEORIGIN_BASE + HELPER;
const CROSSORIGIN_HELPER = CROSSORIGIN_BASE + HELPER;

promise_test(async () => {
  const target = (await appendIframe(SAMEORIGIN_HELPER)).contentWindow;
  let img = createImageBitmap(10, 10);
  assert_true(await canSerializeImageBitmap(target, img));
}, 'Verify imagebitmap can be passed within the same agent clusters');

promise_test(async () => {
  const target = (await appendIframe(CROSSORIGIN_HELPER)).contentWindow;
  let img = createImageBitmap(20, 20);
  assert_false(await canSerializeImageBitmap(target, img));
}, 'Verify imagebitmap cannot be passed accross the different agent clusters');

promise_test(async () => {
  const blob = new Blob([document.querySelector('#workerCode').textContent], {
    type: 'text/javascript',
  });
  const worker = new Worker(window.URL.createObjectURL(blob));
  let img = createImageBitmap(30, 30);
  worker.postMessage({img: img, transfer: false});
  const received = await new Promise(resolve => worker.onmessage = e => {
    resolve(e.data);
  });
  assert_equals(received.toString(), '[object ImageBitmap]');
  assert_equals(received.width, 30);
}, 'Verify imagebitmap can be passed back and forth between main and worker');

promise_test(async () => {
  const blob = new Blob([document.querySelector('#sharedWorkerCode').textContent], {
    type: 'text/javascript',
  });
  const worker = new SharedWorker(window.URL.createObjectURL(blob));
  let img = createImageBitmap(40, 40);
  worker.port.postMessage(img);
  worker.port.postMessage({'id': 40});
  const received = await new Promise(resolve => worker.port.onmessage = e => {
    resolve(e.data);
  });
  assert_equals(received, 'RECEIVED');
}, 'Verify imagebitmap can be passed to sharedworker');

promise_test(async () => {
  const target = (await appendIframe(SAMEORIGIN_HELPER)).contentWindow;
  let img = createImageBitmap(50, 50);
  assert_true(await canTransferImageBitmap(target, img));
  assert_true(isImageBitmapClosed(img));
}, 'Verify imagebitmap can be transferred within the same agent clusters');

promise_test(async () => {
  const target = (await appendIframe(CROSSORIGIN_HELPER)).contentWindow;
  let img = createImageBitmap(60, 60);
  assert_false(await canTransferImageBitmap(target, img));
}, 'Verify imagebitmap cannot be transferred accross the different agent clusters');

promise_test(async () => {
  const blob = new Blob([document.querySelector('#workerCode').textContent], {
    type: 'text/javascript',
  });
  const worker = new Worker(window.URL.createObjectURL(blob));
  let img = createImageBitmap(70, 70);
  worker.postMessage({img: img, transfer: true}, [img]);
  const received = await new Promise(resolve => worker.onmessage = e => {
    resolve(e.data);
  });
  assert_equals(received.toString(), '[object ImageBitmap]');
  assert_equals(received.width, 70);
}, 'Verify imagebitmap can be transferred back and forth between main and worker');

promise_test(async () => {
  const blob = new Blob([document.querySelector('#sharedWorkerCode').textContent], {
    type: 'text/javascript',
  });
  const worker = new SharedWorker(window.URL.createObjectURL(blob));
  let img = createImageBitmap(80, 80);
  worker.port.postMessage(img, [img]);
  worker.port.postMessage({'id': 80});
  const received = await new Promise(resolve => worker.port.onmessage = e => {
    resolve(e.data);
  });
  assert_equals(received, 'RECEIVED');
}, 'Verify imagebitmap can be transferred to a sharedworker');

function appendIframe(src) {
  const frame = document.createElement('iframe');
  document.body.appendChild(frame);
  frame.src = src;
  return new Promise(resolve => frame.onload = () => resolve(frame));
};

function createImageBitmap(w, h) {
  let canvas = new OffscreenCanvas(w, h);
  let ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(50, 100, 150, 255)';
  ctx.fillRect(0, 0, w, h);
  return canvas.transferToImageBitmap();
}

function canSerializeImageBitmap(target, img) {
  return canPostImageBitmap(target, img, false);
};

function canTransferImageBitmap(target, img) {
  return canPostImageBitmap(target, img, true);
};

function canPostImageBitmap(target, img, transfer) {
  let id = img.width;
  if (transfer) {
    target.postMessage(img, '*', [img]);
    assert_true(isImageBitmapClosed(img));
  } else {
    target.postMessage(img, '*');
  }
  target.postMessage({'id': id}, '*');
  return new Promise(resolve => window.onmessage = e => {
    resolve(e.data == 'RECEIVED');
  });
};

function isImageBitmapClosed(img) {
  return img.width == 0 && img.height == 0;
}
</script>
</body>
</html>
