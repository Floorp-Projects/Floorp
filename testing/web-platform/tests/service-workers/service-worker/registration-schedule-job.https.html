<!DOCTYPE html>
<meta charset="utf-8">
<title>Service Worker: Schedule Job algorithm</title>
<script src="/resources/testharness.js"></script>
<script src="resources/testharness-helpers.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script>
// Tests for https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
// Non-equivalent register jobs should not be coalesced.
const scope = 'resources/';
const script1 = 'resources/empty.js';
const script2 = 'resources/empty.js?change';

async function cleanup() {
  const registration = await navigator.serviceWorker.getRegistration(scope);
  if (registration)
    await registration.unregister();
}

function absolute_url(url) {
  return new URL(url, self.location).toString();
}

// Test scriptURL and updateViaCache.
promise_test(async t => {
  await cleanup();
  t.add_cleanup(cleanup);

  // Check defaults.
  const registration = await
      navigator.serviceWorker.register(script1, {scope});
  assert_equals(registration.updateViaCache, 'imports');

  // Schedule several register jobs in the same scope.
  // None of the changes should have been coalesced.

  // This resolves without changing anything.
  const p1 = navigator.serviceWorker.register(script1, {scope});
  // This changes the script URL so going with installing a new worker without
  // byte-for-byte update check.
  const p2 = navigator.serviceWorker.register(script2, {scope});
  // This changes the updateViaCache option but the script URL is the same. That
  // results in updating the updateViaCache flag but no worker is going to be
  // stored.
  const p3 = navigator.serviceWorker.register(script2,
                                         {scope, updateViaCache: 'none'});

  // The first call of register() doesn't change anything.
  await p1;
  assert_equals(registration.installing, null);

  // The scriptURL must be updated when `p2` resolves. At that point, a new
  // worker must be in the installing state because changing scriptURL is
  // treated as the same as there's an update in the script.
  await p2;
  assert_equals(registration.installing.scriptURL, absolute_url(script2));
  assert_equals(registration.updateViaCache, 'imports');

  // The updateViaCache must be updated when `p3` resolves.
  await p3;
  assert_equals(registration.installing.scriptURL, absolute_url(script2));
  assert_equals(registration.updateViaCache, 'none');
}, 'different scriptURL and updateViaCache');

// Test |type| in another test case because most browsers don't support it.
promise_test(async t => {
  const script1 = 'resources/empty.js';
  const script2 = 'resources/empty.js?change';

  await cleanup();
  t.add_cleanup(cleanup);

  // Check defaults.
  const registration = await
      navigator.serviceWorker.register(script1, {scope});
  assert_equals(registration.installing.type, 'classic');

  // Schedule several register jobs in the same scope.
  // None of the changes should have been coalesced.

  // This resolves without changing anything.
  const p1 = navigator.serviceWorker.register(script1, {scope});

  // This changes the script URL so going with installing a new worker without
  // byte-for-byte update check.
  const p2 = navigator.serviceWorker.register(script2, {scope});

  // This changes the worker type, and that goes to the same path with updating
  // the worker script or the script URL.
  const p3 = navigator.serviceWorker.register(script2, {scope, type: 'module'});

  // The first call of register() doesn't change anything.
  await p1;
  assert_equals(registration.installing, null);

  // The scriptURL must be updated when `p2` resolves. At this point, a new
  // worker must be in the installing state because changing scriptURL is
  // treated as the same as there's an update in the script.
  await p2;
  assert_equals(registration.installing.scriptURL, absolute_url(script2));
  assert_equals(registration.installing.type, 'classic');

  // The script type must be updated when `p3` resolves. At this point, a new
  // worker must be in the installing state because changing script type is also
  // treated as the same as there's an update in the script.
  await p3;
  assert_equals(registration.installing.scriptURL, absolute_url(script2));
  assert_equals(registration.installing.type, 'module');
}, 'different type');
</script>
