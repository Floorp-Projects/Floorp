<!DOCTYPE html>
<head>
<meta charset="utf-8">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/common/utils.js"></script>
<script src="./resources/compression-dictionary-util.js"></script>
</head>
<body>
<script>

function addIframeWithLinkRelDictionaryHeader(dict_url) {
  const base_page_url = './resources/empty.html';
  const page_url =
      base_page_url + `?pipe=header(link,<${dict_url}>; rel="dictionary")`;
  const iframe = document.createElement('iframe');
  iframe.src = page_url;
  document.body.appendChild(iframe);
  return iframe;
}

compression_dictionary_promise_test(async (t) => {
  const dict_token = token();
  const url = new URL(
      `${kRegisterDictionaryPath}?save_header=${dict_token}`, location.href);
  const iframe = addIframeWithLinkRelDictionaryHeader(url.href);
  t.add_cleanup(() => {
    iframe.remove();
  });
  const headers = await waitUntilPreviousRequestHeaders(t, dict_token);
  assert_true(headers !== undefined, 'Headers should be available');
  assert_equals(headers['sec-fetch-mode'], 'cors');
  // Wait until `available-dictionary` header is available.
  assert_equals(
      await waitUntilAvailableDictionaryHeader(t, {}),
      kDefaultDictionaryHashBase64);
  // Check if the data compressed using Brotli with the dictionary can be
  // decompressed.
  const data_url = `${kCompressedDataPath}?content_encoding=br-d`;
  assert_equals(await (await fetch(data_url)).text(), kExpectedCompressedData);
}, 'Fetch same origin dictionary using link header');

</script>
</body>
