<!doctype html>
<html>
<meta name="timeout" content="long">

<head>
  <title>MediaRecorder peer connection</title>
  <link rel="help"
        href="https://w3c.github.io/mediacapture-record/MediaRecorder.html#dom-mediarecorder-mimeType">
  <script src="/resources/testharness.js"></script>
  <script src="/resources/testharnessreport.js"></script>
  <script src="utils/peerconnection.js"></script>
</head>

<body>
  <video id="remote" autoplay width="240" />
  <script>

function runTests({kind, mimeType}) {
    const formatString =
        `${JSON.stringify(kind)} with format ${mimeType || "[passthrough]"}.`;
    promise_test(async t => {
      const [localPc, remotePc, stream] = await startConnection(
          t, kind.audio, kind.video);
      const recorder = new MediaRecorder(stream, { mimeType });
      // Small timeslice (but not too small to be web compatible).
      recorder.start(200);
      await new Promise(r => recorder.onstart = r);
      let combinedSize = 0;
      // Wait for an arbitrary amount of data to appear before we resolve.
      // Keep it small for android tests
      while (combinedSize < 2000) {
        const {data} = await new Promise(r => recorder.ondataavailable = r);
        combinedSize += data.size;
      }
      recorder.stop();
    }, "PeerConnection MediaRecorder receives data after onstart, " +
          formatString);

    promise_test(async t => {
      const [localPc, remotePc, stream] = await startConnection(
          t, kind.audio, kind.video);
      const recorder = new MediaRecorder(stream, { mimeType });
      recorder.start();
      await new Promise(r => recorder.onstart = r);
      await waitForReceivedFramesOrPackets(
        t, remotePc, kind.audio, kind.video, 10);
      for (transceiver of remotePc.getTransceivers()) {
        transceiver.receiver.track.stop();
      }
      // As the tracks ended, we'd like to see data from the recorder.
      // For details:
      // https://www.w3.org/TR/mediastream-recording/#mediarecorder-methods
      const stopPromise = new Promise(r => recorder.onstop = r);
      await new Promise(r => recorder.ondataavailable = r);
      await stopPromise;
    }, "PeerConnection MediaRecorder gets ondata on stopping recorded " +
            "tracks " + formatString);
}

[{ kind: { video: true, audio: false }, mimeType: "" },
 { kind: { video: false, audio: true }, mimeType: "" },
 { kind: { video: true, audio: true }, mimeType: "" }].forEach(runTests);

[{ kind: { video: false, audio: true }, mimeType: "audio/webm;codecs=opus" },
 { kind: { video: true, audio: false }, mimeType: "video/webm;codecs=vp8" },
 { kind: { video: true, audio: true }, mimeType: "video/webm;codecs=vp8,opus" },
 { kind: { video: true, audio: false }, mimeType: "video/webm;codecs=vp9" },
 { kind: { video: true, audio: true }, mimeType: "video/webm;codecs=vp9,opus" }]
  .forEach(({kind, mimeType}) => {
    if (MediaRecorder.isTypeSupported(mimeType)) {
      return runTests({kind, mimeType});
    }
    const formatString = `${JSON.stringify(kind)} with format ${mimeType}.`;
    promise_test(async t => {
      const [,, stream] = await startConnection(t, kind.audio, kind.video);
      assert_throws_dom('NotSupportedError', () => {
        new MediaRecorder(stream, {mimeType});
      });
    }, "MediaRecorder constructor throws when not supporting " + formatString);
  });

  </script>
</body>

</html>
