<html style="ime-mode: disabled;">
<head>
  <title>Test for IME state controlling</title>
  <script src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
  <script src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>
  <script src="file_ime_state_test_helper.js"></script>
  <link rel="stylesheet" type="text/css"
          href="chrome://mochikit/content/tests/SimpleTest/test.css" />
</head>
<body onload="setTimeout(runTests, 0);" style="ime-mode: disabled;">
<div id="display" style="ime-mode: disabled;">
  <!-- input elements -->
  <input type="text"     id="text"/><br/>
  <input type="text"     id="text_readonly" readonly="readonly"/><br/>

  <!-- form controls -->
  <button id="button">button</button><br/>
  <textarea id="textarea">textarea</textarea><br/>
  <textarea id="textarea_readonly" readonly="readonly">textarea[readonly]</textarea><br/>

  <!-- contenteditable editor -->
  <div id="contenteditableEditor" contenteditable="true"></div>
</div>
<div id="content" style="display: none">
  
</div>
<pre id="test">
</pre>

<script class="testbody" type="application/javascript">

SimpleTest.waitForExplicitFinish();

function hitEventLoop(aFunc, aTimes) {
  if (--aTimes) {
    setTimeout(hitEventLoop, 0, aFunc, aTimes);
  } else {
    setTimeout(aFunc, 20);
  }
}

var gUtils = window.windowUtils;
var gFM = Services.focus;

function runComplexContenteditableTests() {
  var description = "runReadonlyChangingOnContenteditable: ";

  var container = document.getElementById("display");
  var button = document.getElementById("button");

  // the editor has focus directly.
  container.setAttribute("contenteditable", "true");
  container.focus();

  is(gFM.focusedElement, container,
     description + "The editor doesn't get focus");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "IME isn't enabled on HTML editor");
  const kReadonly = Ci.nsIEditor.eEditorReadonlyMask;
  var editor = window.docShell.editor;
  var flags = editor.flags;
  editor.flags = flags | kReadonly;
  is(gFM.focusedElement, container,
     description + "The editor loses focus by flag change");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_DISABLED,
     description + "IME is still enabled on readonly HTML editor");
  editor.flags = flags;
  is(gFM.focusedElement, container,
     description + "The editor loses focus by flag change #2");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "IME is still disabled, the editor isn't readonly now");
  container.removeAttribute("contenteditable");
  todo_is(gFM.focusedElement, null,
          description + "The container still has focus, the editor has been no editable");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_DISABLED,
     description + "IME is still enabled on the editor, the editor has been no editable");

  // a button which is in the editor has focus
  button.focus();
  is(gFM.focusedElement, button,
     description + "The button doesn't get focus");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_DISABLED,
     description + "IME is enabled on the button");
  container.setAttribute("contenteditable", "true");
  is(gFM.focusedElement, button,
     description + "The button loses focus, the container is editable now");
  todo_is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
          description + "IME is still disabled on the button, the container is editable now");
  editor = window.docShell.editor;
  flags = editor.flags;
  editor.flags = flags | kReadonly;
  is(gFM.focusedElement, button,
     description + "The button loses focus by changing editor flags");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_DISABLED,
     description + "IME is still enabled on the button, the container is readonly now");
  editor.flags = flags;
  is(gFM.focusedElement, button,
     description + "The button loses focus by changing editor flags #2");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "IME is still disabled on the button, the container isn't readonly now");
  container.removeAttribute("contenteditable");
  is(gFM.focusedElement, button,
     description + "The button loses focus, the container has been no editable");
  todo_is(gUtils.IMEStatus, gUtils.IME_STATUS_DISABLED,
          description + "IME is still enabled on the button, the container has been no editable");

  description = "testOnIndependentEditor: ";
  function testOnIndependentEditor(aEditor, aEditorDescription) {
    var expectedState =
      aEditor.readOnly ? gUtils.IME_STATUS_DISABLED : gUtils.IME_STATUS_ENABLED;
    var unexpectedStateDescription =
      expectedState != gUtils.IME_STATUS_ENABLED ? "enabled" : "disabled";
    aEditor.focus();
    is(gFM.focusedElement, aEditor,
       description + "The " + aEditorDescription + " doesn't get focus");
    is(gUtils.IMEStatus, expectedState,
       description + "IME is " + unexpectedStateDescription +
         " on the " + aEditorDescription);
    container.setAttribute("contenteditable", "true");
    is(gFM.focusedElement, aEditor,
       description + "The " + aEditorDescription +
         " loses focus, the container is editable now");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription +
         " on the " + aEditorDescription + ", the container is editable now");
    editor = window.docShell.editor;
    flags = editor.flags;
    editor.flags = flags | kReadonly;
    is(gFM.focusedElement, aEditor,
       description + "The " + aEditorDescription +
         " loses focus by changing editor flags");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on the " +
         aEditorDescription + ", the container is readonly now");
    editor.flags = flags;
    is(gFM.focusedElement, aEditor,
       description + "The " + aEditorDescription +
         " loses focus by changing editor flags #2");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on the " +
         aEditorDescription + ", the container isn't readonly now");
    container.removeAttribute("contenteditable");
    is(gFM.focusedElement, aEditor,
       description + "The " + aEditorDescription +
         " loses focus, the container has been no editable");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on the " +
         aEditorDescription + ", the container has been no editable");
  }

  // a textarea which is in the editor has focus
  testOnIndependentEditor(document.getElementById("textarea"),
                          "textarea");
  // a readonly textarea which is in the editor has focus
  testOnIndependentEditor(document.getElementById("textarea_readonly"),
                          "textarea[readonly]");
  // an input field which is in the editor has focus
  testOnIndependentEditor(document.getElementById("text"),
                          "input[type=\"text\"]");
  // a readonly input field which is in the editor has focus
  testOnIndependentEditor(document.getElementById("text_readonly"),
                          "input[type=\"text\"][readonly]");

  description = "testOnOutsideOfEditor: ";
  function testOnOutsideOfEditor(aFocusNode, aFocusNodeDescription, aEditor) {
    if (aFocusNode) {
      aFocusNode.focus();
      is(gFM.focusedElement, aFocusNode,
         description + "The " + aFocusNodeDescription + " doesn't get focus");
    } else {
      if (document.activeElement) {
        document.activeElement.blur();
      }
      is(gFM.focusedElement, null,
         description + "Unexpected element has focus");
    }
    var expectedState =
      aFocusNode ? gUtils.IMEStatus : gUtils.IME_STATUS_DISABLED;
    var unexpectedStateDescription =
      expectedState != gUtils.IME_STATUS_ENABLED ? "enabled" : "disabled";

    aEditor.setAttribute("contenteditable", "true");
    is(gFM.focusedElement, aFocusNode,
       description + "The " + aFocusNodeDescription +
         " loses focus, a HTML editor is editable now");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription +
         " on the " + aFocusNodeDescription +
         ", the HTML editor is editable now");
    editor = window.docShell.editor;
    flags = editor.flags;
    editor.flags = flags | kReadonly;
    is(gFM.focusedElement, aFocusNode,
       description + aFocusNodeDescription +
         " loses focus by changing HTML editor flags");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on " +
         aFocusNodeDescription + ", the HTML editor is readonly now");
    editor.flags = flags;
    is(gFM.focusedElement, aFocusNode,
       description + aFocusNodeDescription +
         " loses focus by changing HTML editor flags #2");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on " +
         aFocusNodeDescription + ", the HTML editor isn't readonly now");
    container.removeAttribute("contenteditable");
    is(gFM.focusedElement, aFocusNode,
       description + aFocusNodeDescription +
         " loses focus, the HTML editor has been no editable");
    is(gUtils.IMEStatus, expectedState,
       description + "IME becomes " + unexpectedStateDescription + " on " +
         aFocusNodeDescription + ", the HTML editor has been no editable");
  }

  var div = document.getElementById("contenteditableEditor");
  // a textarea which is outside of the editor has focus
  testOnOutsideOfEditor(document.getElementById("textarea"), "textarea", div);
  // a readonly textarea which is outside of the editor has focus
  testOnOutsideOfEditor(document.getElementById("textarea_readonly"),
                        "textarea[readonly]", div);
  // an input field which is outside of the editor has focus
  testOnOutsideOfEditor(document.getElementById("text"),
                        "input[type=\"text\"]", div);
  // a readonly input field which outside of the editor has focus
  testOnOutsideOfEditor(document.getElementById("text_readonly"),
                        "input[type=\"text\"][readonly]", div);
  // a readonly input field which outside of the editor has focus
  testOnOutsideOfEditor(document.getElementById("button"), "button", div);
  // nobody has focus.
  testOnOutsideOfEditor(null, "nobody", div);
}

function runEditorFlagChangeTests() {
  var description = "runEditorFlagChangeTests: ";

  var container = document.getElementById("display");

  // Reset selection from previous tests.
  window.getSelection().collapse(container, 0);

  // the editor has focus directly.
  container.setAttribute("contenteditable", "true");
  container.focus();

  is(gFM.focusedElement, container,
     description + "The editor doesn't get focus");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "IME isn't enabled on HTML editor");
  const kIMEStateChangeFlags = Ci.nsIEditor.eEditorReadonlyMask;
  const kFlagsNotAllowedWithHTMLEditor =
    Ci.nsIEditor.eEditorPasswordMask |
    Ci.nsIEditor.eEditorSingleLineMask;
  var editor = window.docShell.editor;
  var flags = editor.flags;

  // input characters
  synthesizeCompositionChange(
    { "composition":
      { "string": "\u3078\u3093\u3057\u3093",
        "clauses":
        [
          { "length": 4, "attr": COMPOSITION_ATTR_RAW_CLAUSE },
        ],
      },
      "caret": { "start": 4, "length": 0 },
    });

  editor.flags &= ~kIMEStateChangeFlags;
  ok(editor.composing,
     description + "#1 IME composition was committed unexpectedly");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "#1 IME isn't enabled on HTML editor");

  editor.flags |=
      ~(kIMEStateChangeFlags | kFlagsNotAllowedWithHTMLEditor);
  ok(editor.composing,
     description + "#2 IME composition was committed unexpectedly");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "#2 IME isn't enabled on HTML editor");

  editor.flags = flags;
  ok(editor.composing,
     description + "#3 IME composition was committed unexpectedly");
  is(gUtils.IMEStatus, gUtils.IME_STATUS_ENABLED,
     description + "#3 IME isn't enabled on HTML editor");

  // cancel the composition
  synthesizeComposition({ type: "compositioncommit", data: "" });

  container.removeAttribute("contenteditable");
}

function runEditableSubframeTests() {
  window.open("window_imestate_iframes.html", "_blank",
              "width=600,height=600");
}

function runTestPasswordFieldOnDialog() {
  if (document.activeElement) {
    document.activeElement.blur();
  }

  var dialog;

  function WindowObserver() {
    Services.obs.addObserver(this, "domwindowopened");
  }

  WindowObserver.prototype = {
    QueryInterface: ChromeUtils.generateQI(["nsIObserver"]),

    observe(subject, topic, data) {
      if (topic === "domwindowopened") {
        ok(true, "dialog window is created");
        dialog = subject;
        dialog.addEventListener("load", onPasswordDialogLoad);
      }
    },
  };

  var observer = new WindowObserver();
  var arg1 = {}, arg2 = {};
  Services.prompt.promptPassword(window, "title", "text", arg1, "msg", arg2);

  ok(true, "password dialog was closed");

  Services.obs.removeObserver(observer, "domwindowopened");

  var passwordField;

  function onPasswordDialogLoad() {
    ok(true, "onPasswordDialogLoad is called");
    dialog.removeEventListener("load", onPasswordDialogLoad);
    passwordField = dialog.document.getElementById("password1Textbox");
    passwordField.addEventListener("focus", onPasswordFieldFocus);
  }

  function onPasswordFieldFocus() {
    ok(true, "onPasswordFieldFocus is called");
    passwordField.removeEventListener("focus", onPasswordFieldFocus);
    var utils = dialog.windowUtils;
    is(utils.IMEStatus, utils.IME_STATUS_PASSWORD,
       "IME isn't disabled on a password field of password dialog");
    synthesizeKey("VK_ESCAPE", { }, dialog);
  }
}

// Bug 580388 and bug 808287
async function runEditorReframeTests() {
  if (document.activeElement) {
    document.activeElement.blur();
  }

  var IMEFocus = 0;
  var IMEBlur = 0;
  var IMEHasFocus = false;
  var TIPCallback = function(aTIP, aNotification) {
    switch (aNotification.type) {
      case "request-to-commit":
        aTIP.commitComposition();
        break;
      case "request-to-cancel":
        aTIP.cancelComposition();
        break;
      case "notify-focus":
        IMEFocus++;
        IMEHasFocus = true;
        break;
      case "notify-blur":
        IMEBlur++;
        IMEHasFocus = false;
        break;
    }
    return true;
  };

  var TIP = Cc["@mozilla.org/text-input-processor;1"]
              .createInstance(Ci.nsITextInputProcessor);
  if (!TIP.beginInputTransactionForTests(window, TIPCallback)) {
    ok(false, "runEditorReframeTests(): failed to begin input transaction");
    return;
  }

  var input = document.getElementById("text");
  input.focus();

  is(IMEFocus, 1, "runEditorReframeTests(): IME should receive a focus notification by a call of <input>.focus()");
  is(IMEBlur, 0, "runEditorReframeTests(): IME shouldn't receive a blur notification by a call of <input>.focus()");
  ok(IMEHasFocus, "runEditorReframeTests(): IME should have focus because <input>.focus() is called");

  IMEFocus = IMEBlur = 0;

  input.style.overflow = "visible";

  var onInput = function(aEvent) {
    aEvent.target.style.overflow = "hidden";
  };
  input.addEventListener("input", onInput, true);

  var AKey = new KeyboardEvent("", { key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A });
  TIP.keydown(AKey);
  TIP.keyup(AKey);

  await new Promise(r => hitEventLoop(r, 20));

  is(IMEFocus, 0, "runEditorReframeTests(): IME shouldn't receive a focus notification during reframing");
  is(IMEBlur, 0, "runEditorReframeTests(): IME shouldn't receive a blur notification during reframing");
  ok(IMEHasFocus, "runEditorReframeTests(): IME must have focus even after reframing");

  var onFocus = function(aEvent) {
    // Perform a style change and query during focus to trigger reframing
    input.style.overflow = "visible";
    synthesizeQuerySelectedText();
  };
  input.addEventListener("focus", onFocus);
  IMEFocus = IMEBlur = 0;

  input.blur();
  input.focus();
  await new Promise(
    resolve => requestAnimationFrame(
      () => requestAnimationFrame(resolve)
    )
  ); // wait for notify-focus
  TIP.keydown(AKey);
  TIP.keyup(AKey);

  await new Promise(r => hitEventLoop(r, 20));

  is(IMEFocus, 1, "runEditorReframeTests(): IME should receive a focus notification at focus but shouldn't receive it during reframing");
  is(IMEBlur, 1, "runEditorReframeTests(): IME should receive a blur notification at blur but shouldn't receive it during reframing");
  ok(IMEHasFocus, "runEditorReframeTests(): IME sould have focus after reframing during focus");

  input.removeEventListener("input", onInput, true);
  input.removeEventListener("focus", onFocus);

  input.style.overflow = "visible";
  input.value = "";

  TIP = null;

  await new Promise(r => hitEventLoop(r, 20));
}

async function runTests() {

  await SpecialPowers.pushPrefEnv({
    set: [["dom.forms.always_allow_key_and_focus_events.enabled", true]],
  });
  // complex contenteditable editor's tests
  runComplexContenteditableTests();

  // test whether the IME state and composition are not changed unexpectedly
  runEditorFlagChangeTests();

  // test password field on dialog
  // XXX temporary disable against failure
  // runTestPasswordFieldOnDialog();

  // Asynchronous tests
  await runEditorReframeTests();

  // This will call onFinish(), so, this test must be the last.
  runEditableSubframeTests();
}

function onFinish() {
  SimpleTest.finish();
}

</script>
</body>

</html>
