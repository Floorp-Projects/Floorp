<?xml version="1.0"?>
<?xml-stylesheet type="text/css" href="chrome://global/skin"?>
<?xml-stylesheet type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css"?>
<!--
https://bugzilla.mozilla.org/show_bug.cgi?id=1123480
-->
<window title="Mozilla Bug 1123480"
        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
        onload="RunTest();">
  <title>nsTransferable PBM Overflow Selection Test</title>
  <script type="application/javascript"
          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"/>

  <script type="application/javascript">
  <![CDATA[
  // Create 1 Mo of sample garbage text
  // Since JS strings are saved as UTF16 strings, the string size is 2 MB,
  // which is well above the kLargeDatasetSize threshold in nsTransferable.h
  var Ipsum = "0123456789".repeat(100000);
  var SHORT_STRING_NO_CACHE = "short string that will never be cached to the disk";

  // Get a list of open file descriptors, and ASSUME that any mutations in file
  // descriptor counts are caused by our test. This is a bold assumption,
  // but better than the alternatives (spawning lsof as a subprocess and parsing
  // its output, or adding test-only code to nsAnonymousTemporaryFile).
  function getOpenFileDescriptorCount() {
    // Note: /dev/fd is only available on Linux and macOS, not Windows.
    var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsIFile);
    file.initWithPath("/dev/fd");
    var count = 0;
    for (var de = file.directoryEntries; de.hasMoreElements(); de.getNext()) {
      ++count;
    }
    return count;
  }

  function RunTest() {
    const gClipboardHelper = Components.classes["@mozilla.org/widget/clipboardhelper;1"].getService(Components.interfaces.nsIClipboardHelper);

    // Sanitize environment
    gClipboardHelper.copyString(SHORT_STRING_NO_CACHE);

    var initialFdCount = getOpenFileDescriptorCount();
    var expectedFdCount = initialFdCount + 1;

    // Overflow a nsTransferable region by using the clipboard helper
    gClipboardHelper.copyString(Ipsum);

    // Disabled private browsing mode should cache large selections to disk
    is(getOpenFileDescriptorCount(), expectedFdCount, "correctly saved memory by caching to disk");

    // Sanitize environment again
    gClipboardHelper.copyString(SHORT_STRING_NO_CACHE);
    is(getOpenFileDescriptorCount(), initialFdCount, "failed to evict the file descriptor of the clipboard cache");

    // Repeat procedure of plain text selection with private browsing enabled
    Components.utils.import("resource://gre/modules/PrivateBrowsingUtils.jsm");
    var Winpriv = window.open("about:blank", "_blank", "chrome, width=500, height=200, private");
    ok(Winpriv, "failed to open private window");
    ok(PrivateBrowsingUtils.isContentWindowPrivate(Winpriv), "correctly used a private window context");

    // Select plaintext in private channel
    Components.utils.import('resource://gre/modules/Services.jsm');
    const nsTransferable = Components.Constructor("@mozilla.org/widget/transferable;1", "nsITransferable");
    const nsSupportsString = Components.Constructor("@mozilla.org/supports-string;1", "nsISupportsString");
    var Loadctx = PrivateBrowsingUtils.privacyContextFromWindow(Winpriv);
    var Transfer = nsTransferable();
    var Suppstr = nsSupportsString();
    Suppstr.data = Ipsum;
    Transfer.init(Loadctx);
    Transfer.addDataFlavor("text/plain");
    Transfer.setTransferData("text/plain", Suppstr, Ipsum.length);
    Services.clipboard.setData(Transfer, null, Services.clipboard.kGlobalClipboard);

    // Enabled private browsing mode should not cache any selection to disk
    is(getOpenFileDescriptorCount(), initialFdCount, "did not violate private browsing mode");
  }
  ]]>
  </script>

  <!-- test results are displayed in the html:body -->
  <body xmlns="http://www.w3.org/1999/xhtml">
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1123480"
     target="_blank">Mozilla Bug 1123480</a>
  </body>
</window>
